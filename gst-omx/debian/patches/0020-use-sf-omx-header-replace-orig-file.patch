Description: <short summary of the patch>
 TODO: Put a short summary on the line above and replace this paragraph
 with a longer explanation of this change. Complete the meta-information
 with other relevant fields (see below for details). To make it easier, the
 information below has been extracted from the changelog. Adjust it or drop
 it.
 .
 gst-omx (1.22.0-1) unstable; urgency=low
 .
   * New upstream release.
Author: Ying-Chun Liu (PaulLiu) <paulliu@debian.org>

---
The information above should follow the Patch Tagging Guidelines, please
checkout https://dep.debian.net/deps/dep3/ to learn about the format. Here
are templates for supplementary fields that you might want to add:

Origin: (upstream|backport|vendor|other), (<patch-url>|commit:<commit-id>)
Bug: <upstream-bugtracker-url>
Bug-Debian: https://bugs.debian.org/<bugnumber>
Bug-Ubuntu: https://launchpad.net/bugs/<bugnumber>
Forwarded: (no|not-needed|<patch-forwarded-url>)
Applied-Upstream: <version>, (<commit-url>|commit:<commid-id>)
Reviewed-By: <name and email of someone who approved/reviewed the patch>
Last-Update: 2023-03-01

Index: gst-omx-1.22.0/omx/openmax/OMX_Audio.h
===================================================================
--- gst-omx-1.22.0.orig/omx/openmax/OMX_Audio.h	2023-03-02 08:48:43.000000000 +0000
+++ gst-omx-1.22.0/omx/openmax/OMX_Audio.h	2023-03-02 08:58:22.000000000 +0000
@@ -1,23 +1,23 @@
 /*
- * Copyright (c) 2008 The Khronos Group Inc. 
- * 
+ * Copyright (c) 2008 The Khronos Group Inc.
+ *
  * Permission is hereby granted, free of charge, to any person obtaining
  * a copy of this software and associated documentation files (the
  * "Software"), to deal in the Software without restriction, including
  * without limitation the rights to use, copy, modify, merge, publish,
  * distribute, sublicense, and/or sell copies of the Software, and to
  * permit persons to whom the Software is furnished to do so, subject
- * to the following conditions: 
+ * to the following conditions:
  * The above copyright notice and this permission notice shall be included
- * in all copies or substantial portions of the Software. 
- * 
+ * in all copies or substantial portions of the Software.
+ *
  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
  * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
  * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  *
  */
 
@@ -36,7 +36,7 @@
 
 /* Each OMX header must include all required header files to allow the
  *  header to compile without errors.  The includes below are required
- *  for this header file to compile successfully 
+ *  for this header file to compile successfully
  */
 
 #include <OMX_Core.h>
@@ -44,7 +44,7 @@
 /** @defgroup midi MIDI
  * @ingroup audio
  */
- 
+
 /** @defgroup effects Audio effects
  * @ingroup audio
  */
@@ -54,10 +54,10 @@
  * @{
  */
 
-/** Enumeration used to define the possible audio codings.  
- *  If "OMX_AUDIO_CodingUnused" is selected, the coding selection must 
- *  be done in a vendor specific way.  Since this is for an audio 
- *  processing element this enum is relevant.  However, for another 
+/** Enumeration used to define the possible audio codings.
+ *  If "OMX_AUDIO_CodingUnused" is selected, the coding selection must
+ *  be done in a vendor specific way.  Since this is for an audio
+ *  processing element this enum is relevant.  However, for another
  *  type of component other enums would be in this area.
  */
 typedef enum OMX_AUDIO_CODINGTYPE {
@@ -89,14 +89,14 @@
     OMX_AUDIO_CodingWMA,         /**< Any variant of WMA encoded data */
     OMX_AUDIO_CodingRA,          /**< Any variant of RA encoded data */
     OMX_AUDIO_CodingMIDI,        /**< Any variant of MIDI encoded data */
-    OMX_AUDIO_CodingKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_AUDIO_CodingKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
     OMX_AUDIO_CodingVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_AUDIO_CodingMax = 0x7FFFFFFF
 } OMX_AUDIO_CODINGTYPE;
 
 
-/** The PortDefinition structure is used to define all of the parameters 
- *  necessary for the compliant component to setup an input or an output audio 
+/** The PortDefinition structure is used to define all of the parameters
+ *  necessary for the compliant component to setup an input or an output audio
  *  path.  If additional information is needed to define the parameters of the
  *  port (such as frequency), additional structures must be sent such as the
  *  OMX_AUDIO_PARAM_PCMMODETYPE structure to supply the extra parameters for the port.
@@ -104,11 +104,11 @@
 typedef struct OMX_AUDIO_PORTDEFINITIONTYPE {
     OMX_STRING cMIMEType;            /**< MIME type of data for the port */
     OMX_NATIVE_DEVICETYPE pNativeRender; /** < platform specific reference
-                                               for an output device, 
+                                               for an output device,
                                                otherwise this field is 0 */
-    OMX_BOOL bFlagErrorConcealment;  /**< Turns on error concealment if it is 
+    OMX_BOOL bFlagErrorConcealment;  /**< Turns on error concealment if it is
                                           supported by the OMX component */
-    OMX_AUDIO_CODINGTYPE eEncoding;  /**< Type of data expected for this 
+    OMX_AUDIO_CODINGTYPE eEncoding;  /**< Type of data expected for this
                                           port (e.g. PCM, AMR, MP3, etc) */
 } OMX_AUDIO_PORTDEFINITIONTYPE;
 
@@ -125,15 +125,15 @@
 } OMX_AUDIO_PARAM_PORTFORMATTYPE;
 
 
-/** PCM mode type  */ 
-typedef enum OMX_AUDIO_PCMMODETYPE { 
-    OMX_AUDIO_PCMModeLinear = 0,  /**< Linear PCM encoded data */ 
-    OMX_AUDIO_PCMModeALaw,        /**< A law PCM encoded data (G.711) */ 
-    OMX_AUDIO_PCMModeMULaw,       /**< Mu law PCM encoded data (G.711)  */ 
-    OMX_AUDIO_PCMModeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+/** PCM mode type  */
+typedef enum OMX_AUDIO_PCMMODETYPE {
+    OMX_AUDIO_PCMModeLinear = 0,  /**< Linear PCM encoded data */
+    OMX_AUDIO_PCMModeALaw,        /**< A law PCM encoded data (G.711) */
+    OMX_AUDIO_PCMModeMULaw,       /**< Mu law PCM encoded data (G.711)  */
+    OMX_AUDIO_PCMModeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
     OMX_AUDIO_PCMModeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_AUDIO_PCMModeMax = 0x7FFFFFFF 
-} OMX_AUDIO_PCMMODETYPE; 
+    OMX_AUDIO_PCMModeMax = 0x7FFFFFFF
+} OMX_AUDIO_PCMMODETYPE;
 
 
 typedef enum OMX_AUDIO_CHANNELTYPE {
@@ -147,45 +147,45 @@
     OMX_AUDIO_ChannelCS   = 0x7,    /**< Back surround */
     OMX_AUDIO_ChannelLR   = 0x8,    /**< Left rear. */
     OMX_AUDIO_ChannelRR   = 0x9,    /**< Right rear. */
-    OMX_AUDIO_ChannelKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_AUDIO_ChannelKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
     OMX_AUDIO_ChannelVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_AUDIO_ChannelMax  = 0x7FFFFFFF 
+    OMX_AUDIO_ChannelMax  = 0x7FFFFFFF
 } OMX_AUDIO_CHANNELTYPE;
 
 #define OMX_AUDIO_MAXCHANNELS 16  /**< maximum number distinct audio channels that a buffer may contain */
 #define OMX_MIN_PCMPAYLOAD_MSEC 5 /**< Minimum audio buffer payload size for uncompressed (PCM) audio */
 
-/** PCM format description */ 
-typedef struct OMX_AUDIO_PARAM_PCMMODETYPE { 
-    OMX_U32 nSize;                    /**< Size of this structure, in Bytes */ 
-    OMX_VERSIONTYPE nVersion;         /**< OMX specification version information */ 
-    OMX_U32 nPortIndex;               /**< port that this structure applies to */ 
-    OMX_U32 nChannels;                /**< Number of channels (e.g. 2 for stereo) */ 
-    OMX_NUMERICALDATATYPE eNumData;   /**< indicates PCM data as signed or unsigned */ 
-    OMX_ENDIANTYPE eEndian;           /**< indicates PCM data as little or big endian */ 
-    OMX_BOOL bInterleaved;            /**< True for normal interleaved data; false for 
-                                           non-interleaved data (e.g. block data) */ 
-    OMX_U32 nBitPerSample;            /**< Bit per sample */ 
-    OMX_U32 nSamplingRate;            /**< Sampling rate of the source data.  Use 0 for 
-                                           variable or unknown sampling rate. */ 
-    OMX_AUDIO_PCMMODETYPE ePCMMode;   /**< PCM mode enumeration */ 
+/** PCM format description */
+typedef struct OMX_AUDIO_PARAM_PCMMODETYPE {
+    OMX_U32 nSize;                    /**< Size of this structure, in Bytes */
+    OMX_VERSIONTYPE nVersion;         /**< OMX specification version information */
+    OMX_U32 nPortIndex;               /**< port that this structure applies to */
+    OMX_U32 nChannels;                /**< Number of channels (e.g. 2 for stereo) */
+    OMX_NUMERICALDATATYPE eNumData;   /**< indicates PCM data as signed or unsigned */
+    OMX_ENDIANTYPE eEndian;           /**< indicates PCM data as little or big endian */
+    OMX_BOOL bInterleaved;            /**< True for normal interleaved data; false for
+                                           non-interleaved data (e.g. block data) */
+    OMX_U32 nBitPerSample;            /**< Bit per sample */
+    OMX_U32 nSamplingRate;            /**< Sampling rate of the source data.  Use 0 for
+                                           variable or unknown sampling rate. */
+    OMX_AUDIO_PCMMODETYPE ePCMMode;   /**< PCM mode enumeration */
     OMX_AUDIO_CHANNELTYPE eChannelMapping[OMX_AUDIO_MAXCHANNELS]; /**< Slot i contains channel defined by eChannelMap[i] */
 
-} OMX_AUDIO_PARAM_PCMMODETYPE; 
+} OMX_AUDIO_PARAM_PCMMODETYPE;
 
 
 /** Audio channel mode.  This is used by both AAC and MP3, although the names are more appropriate
- * for the MP3.  For example, JointStereo for MP3 is CouplingChannels for AAC. 
+ * for the MP3.  For example, JointStereo for MP3 is CouplingChannels for AAC.
  */
 typedef enum OMX_AUDIO_CHANNELMODETYPE {
-    OMX_AUDIO_ChannelModeStereo = 0,  /**< 2 channels, the bitrate allocation between those 
+    OMX_AUDIO_ChannelModeStereo = 0,  /**< 2 channels, the bitrate allocation between those
                                           two channels changes accordingly to each channel information */
-    OMX_AUDIO_ChannelModeJointStereo, /**< mode that takes advantage of what is common between 
+    OMX_AUDIO_ChannelModeJointStereo, /**< mode that takes advantage of what is common between
                                            2 channels for higher compression gain */
-    OMX_AUDIO_ChannelModeDual,        /**< 2 mono-channels, each channel is encoded with half 
+    OMX_AUDIO_ChannelModeDual,        /**< 2 mono-channels, each channel is encoded with half
                                            the bitrate of the overall bitrate */
     OMX_AUDIO_ChannelModeMono,        /**< Mono channel mode */
-    OMX_AUDIO_ChannelModeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_AUDIO_ChannelModeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
     OMX_AUDIO_ChannelModeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_AUDIO_ChannelModeMax = 0x7FFFFFFF
 } OMX_AUDIO_CHANNELMODETYPE;
@@ -195,7 +195,7 @@
     OMX_AUDIO_MP3StreamFormatMP1Layer3 = 0, /**< MP3 Audio MPEG 1 Layer 3 Stream format */
     OMX_AUDIO_MP3StreamFormatMP2Layer3,     /**< MP3 Audio MPEG 2 Layer 3 Stream format */
     OMX_AUDIO_MP3StreamFormatMP2_5Layer3,   /**< MP3 Audio MPEG2.5 Layer 3 Stream format */
-    OMX_AUDIO_MP3StreamFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_AUDIO_MP3StreamFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
     OMX_AUDIO_MP3StreamFormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_AUDIO_MP3StreamFormatMax = 0x7FFFFFFF
 } OMX_AUDIO_MP3STREAMFORMATTYPE;
@@ -225,7 +225,7 @@
     OMX_AUDIO_AACStreamFormatADIF,        /**< AAC Audio Data Interchange Format */
     OMX_AUDIO_AACStreamFormatMP4FF,       /**< AAC inside MPEG-4/ISO File Format */
     OMX_AUDIO_AACStreamFormatRAW,         /**< AAC Raw Format */
-    OMX_AUDIO_AACStreamFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_AUDIO_AACStreamFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
     OMX_AUDIO_AACStreamFormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_AUDIO_AACStreamFormatMax = 0x7FFFFFFF
 } OMX_AUDIO_AACSTREAMFORMATTYPE;
@@ -233,20 +233,20 @@
 
 /** AAC mode type.  Note that the term profile is used with the MPEG-2
  * standard and the term object type and profile is used with MPEG-4 */
-typedef enum OMX_AUDIO_AACPROFILETYPE{
-  OMX_AUDIO_AACObjectNull = 0,      /**< Null, not used */
-  OMX_AUDIO_AACObjectMain = 1,      /**< AAC Main object */
-  OMX_AUDIO_AACObjectLC,            /**< AAC Low Complexity object (AAC profile) */
-  OMX_AUDIO_AACObjectSSR,           /**< AAC Scalable Sample Rate object */
-  OMX_AUDIO_AACObjectLTP,           /**< AAC Long Term Prediction object */
-  OMX_AUDIO_AACObjectHE,            /**< AAC High Efficiency (object type SBR, HE-AAC profile) */
-  OMX_AUDIO_AACObjectScalable,      /**< AAC Scalable object */
-  OMX_AUDIO_AACObjectERLC = 17,     /**< ER AAC Low Complexity object (Error Resilient AAC-LC) */
-  OMX_AUDIO_AACObjectLD = 23,       /**< AAC Low Delay object (Error Resilient) */
-  OMX_AUDIO_AACObjectHE_PS = 29,    /**< AAC High Efficiency with Parametric Stereo coding (HE-AAC v2, object type PS) */
-  OMX_AUDIO_AACObjectKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
-  OMX_AUDIO_AACObjectVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-  OMX_AUDIO_AACObjectMax = 0x7FFFFFFF
+typedef enum OMX_AUDIO_AACPROFILETYPE {
+    OMX_AUDIO_AACObjectNull = 0,      /**< Null, not used */
+    OMX_AUDIO_AACObjectMain = 1,      /**< AAC Main object */
+    OMX_AUDIO_AACObjectLC,            /**< AAC Low Complexity object (AAC profile) */
+    OMX_AUDIO_AACObjectSSR,           /**< AAC Scalable Sample Rate object */
+    OMX_AUDIO_AACObjectLTP,           /**< AAC Long Term Prediction object */
+    OMX_AUDIO_AACObjectHE,            /**< AAC High Efficiency (object type SBR, HE-AAC profile) */
+    OMX_AUDIO_AACObjectScalable,      /**< AAC Scalable object */
+    OMX_AUDIO_AACObjectERLC = 17,     /**< ER AAC Low Complexity object (Error Resilient AAC-LC) */
+    OMX_AUDIO_AACObjectLD = 23,       /**< AAC Low Delay object (Error Resilient) */
+    OMX_AUDIO_AACObjectHE_PS = 29,    /**< AAC High Efficiency with Parametric Stereo coding (HE-AAC v2, object type PS) */
+    OMX_AUDIO_AACObjectKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_AUDIO_AACObjectVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_AACObjectMax = 0x7FFFFFFF
 } OMX_AUDIO_AACPROFILETYPE;
 
 
@@ -309,40 +309,40 @@
                                    variable or unknown sampling rate. */
     OMX_U32 nAudioBandWidth;  /**< Audio band width (in Hz) to which an encoder should
                                    limit the audio signal. Use 0 to let encoder decide */
-    OMX_S32 nQuality;		  /**< Sets encoding quality to n, between -1 (low) and 10 (high).
+    OMX_S32 nQuality;         /**< Sets encoding quality to n, between -1 (low) and 10 (high).
                                    In the default mode of operation, teh quality level is 3.
                                    Normal quality range is 0 - 10. */
-    OMX_BOOL bManaged;		  /**< Set  bitrate  management  mode. This turns off the
+    OMX_BOOL bManaged;        /**< Set  bitrate  management  mode. This turns off the
                                    normal VBR encoding, but allows hard or soft bitrate
                                    constraints to be enforced by the encoder. This mode can
                                    be slower, and may also be lower quality. It is
                                    primarily useful for streaming. */
-    OMX_BOOL bDownmix;		  /**< Downmix input from stereo to mono (has no effect on 
-                                   non-stereo streams). Useful for lower-bitrate encoding. */     
+    OMX_BOOL bDownmix;        /**< Downmix input from stereo to mono (has no effect on
+                                   non-stereo streams). Useful for lower-bitrate encoding. */
 } OMX_AUDIO_PARAM_VORBISTYPE;
 
 
 /** WMA Version */
 typedef enum OMX_AUDIO_WMAFORMATTYPE {
-  OMX_AUDIO_WMAFormatUnused = 0, /**< format unused or unknown */
-  OMX_AUDIO_WMAFormat7,          /**< Windows Media Audio format 7 */
-  OMX_AUDIO_WMAFormat8,          /**< Windows Media Audio format 8 */
-  OMX_AUDIO_WMAFormat9,          /**< Windows Media Audio format 9 */
-  OMX_AUDIO_WMAFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
-  OMX_AUDIO_WMAFormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-  OMX_AUDIO_WMAFormatMax = 0x7FFFFFFF
+    OMX_AUDIO_WMAFormatUnused = 0, /**< format unused or unknown */
+    OMX_AUDIO_WMAFormat7,          /**< Windows Media Audio format 7 */
+    OMX_AUDIO_WMAFormat8,          /**< Windows Media Audio format 8 */
+    OMX_AUDIO_WMAFormat9,          /**< Windows Media Audio format 9 */
+    OMX_AUDIO_WMAFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_AUDIO_WMAFormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_WMAFormatMax = 0x7FFFFFFF
 } OMX_AUDIO_WMAFORMATTYPE;
 
 
 /** WMA Profile */
 typedef enum OMX_AUDIO_WMAPROFILETYPE {
-  OMX_AUDIO_WMAProfileUnused = 0,  /**< profile unused or unknown */
-  OMX_AUDIO_WMAProfileL1,          /**< Windows Media audio version 9 profile L1 */
-  OMX_AUDIO_WMAProfileL2,          /**< Windows Media audio version 9 profile L2 */
-  OMX_AUDIO_WMAProfileL3,          /**< Windows Media audio version 9 profile L3 */
-  OMX_AUDIO_WMAProfileKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
-  OMX_AUDIO_WMAProfileVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-  OMX_AUDIO_WMAProfileMax = 0x7FFFFFFF
+    OMX_AUDIO_WMAProfileUnused = 0,  /**< profile unused or unknown */
+    OMX_AUDIO_WMAProfileL1,          /**< Windows Media audio version 9 profile L1 */
+    OMX_AUDIO_WMAProfileL2,          /**< Windows Media audio version 9 profile L2 */
+    OMX_AUDIO_WMAProfileL3,          /**< Windows Media audio version 9 profile L3 */
+    OMX_AUDIO_WMAProfileKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_AUDIO_WMAProfileVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_WMAProfileMax = 0x7FFFFFFF
 } OMX_AUDIO_WMAPROFILETYPE;
 
 
@@ -355,14 +355,14 @@
     OMX_U32 nBitRate;         /**< Bit rate of the input data.  Use 0 for variable
                                    rate or unknown bit rates */
     OMX_AUDIO_WMAFORMATTYPE eFormat; /**< Version of WMA stream / data */
-	OMX_AUDIO_WMAPROFILETYPE eProfile;  /**< Profile of WMA stream / data */
+    OMX_AUDIO_WMAPROFILETYPE eProfile;  /**< Profile of WMA stream / data */
     OMX_U32 nSamplingRate;    /**< Sampling rate of the source data */
     OMX_U16 nBlockAlign;      /**< is the block alignment, or block size, in bytes of the audio codec */
     OMX_U16 nEncodeOptions;   /**< WMA Type-specific data */
     OMX_U32 nSuperBlockAlign; /**< WMA Type-specific data */
 } OMX_AUDIO_PARAM_WMATYPE;
 
-/** 
+/**
  * RealAudio format
  */
 typedef enum OMX_AUDIO_RAFORMATTYPE {
@@ -374,34 +374,34 @@
     OMX_AUDIO_RA10_LOSSLESS,      /**< RealAudio Lossless */
     OMX_AUDIO_RA10_MULTICHANNEL,  /**< RealAudio Multichannel */
     OMX_AUDIO_RA10_VOICE,         /**< RealAudio Voice for bitrates below 15 kbps */
-    OMX_AUDIO_RAFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_AUDIO_RAFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
     OMX_AUDIO_RAFormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_VIDEO_RAFormatMax = 0x7FFFFFFF
 } OMX_AUDIO_RAFORMATTYPE;
 
-/** RA (Real Audio) params */ 
-typedef struct OMX_AUDIO_PARAM_RATYPE { 
-    OMX_U32 nSize;              /**< Size of this structure, in Bytes */ 
-    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */ 
-    OMX_U32 nPortIndex;         /**< Port that this structure applies to */ 
-    OMX_U32 nChannels;          /**< Number of channels */ 
-    OMX_U32 nSamplingRate;      /**< is the sampling rate of the source data */ 
-    OMX_U32 nBitsPerFrame;      /**< is the value for bits per frame  */ 
-    OMX_U32 nSamplePerFrame;    /**< is the value for samples per frame */ 
-    OMX_U32 nCouplingQuantBits; /**< is the number of coupling quantization bits in the stream */ 
-    OMX_U32 nCouplingStartRegion;   /**< is the coupling start region in the stream  */ 
-    OMX_U32 nNumRegions;        /**< is the number of regions value */ 
+/** RA (Real Audio) params */
+typedef struct OMX_AUDIO_PARAM_RATYPE {
+    OMX_U32 nSize;              /**< Size of this structure, in Bytes */
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
+    OMX_U32 nPortIndex;         /**< Port that this structure applies to */
+    OMX_U32 nChannels;          /**< Number of channels */
+    OMX_U32 nSamplingRate;      /**< is the sampling rate of the source data */
+    OMX_U32 nBitsPerFrame;      /**< is the value for bits per frame  */
+    OMX_U32 nSamplePerFrame;    /**< is the value for samples per frame */
+    OMX_U32 nCouplingQuantBits; /**< is the number of coupling quantization bits in the stream */
+    OMX_U32 nCouplingStartRegion;   /**< is the coupling start region in the stream  */
+    OMX_U32 nNumRegions;        /**< is the number of regions value */
     OMX_AUDIO_RAFORMATTYPE eFormat; /**< is the RealAudio audio format */
-} OMX_AUDIO_PARAM_RATYPE; 
+} OMX_AUDIO_PARAM_RATYPE;
 
 
 /** SBC Allocation Method Type */
 typedef enum OMX_AUDIO_SBCALLOCMETHODTYPE {
-  OMX_AUDIO_SBCAllocMethodLoudness, /**< Loudness allocation method */
-  OMX_AUDIO_SBCAllocMethodSNR,      /**< SNR allocation method */
-  OMX_AUDIO_SBCAllocMethodKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
-  OMX_AUDIO_SBCAllocMethodVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-  OMX_AUDIO_SBCAllocMethodMax = 0x7FFFFFFF
+    OMX_AUDIO_SBCAllocMethodLoudness, /**< Loudness allocation method */
+    OMX_AUDIO_SBCAllocMethodSNR,      /**< SNR allocation method */
+    OMX_AUDIO_SBCAllocMethodKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_AUDIO_SBCAllocMethodVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_SBCAllocMethodMax = 0x7FFFFFFF
 } OMX_AUDIO_SBCALLOCMETHODTYPE;
 
 
@@ -424,18 +424,18 @@
 } OMX_AUDIO_PARAM_SBCTYPE;
 
 
-/** ADPCM stream format parameters */ 
-typedef struct OMX_AUDIO_PARAM_ADPCMTYPE { 
-    OMX_U32 nSize;              /**< size of the structure in bytes */ 
-    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */ 
-    OMX_U32 nPortIndex;         /**< port that this structure applies to */ 
-    OMX_U32 nChannels;          /**< Number of channels in the data stream (not 
-                                     necessarily the same as the number of channels 
-                                     to be rendered. */ 
-    OMX_U32 nBitsPerSample;     /**< Number of bits in each sample */ 
-    OMX_U32 nSampleRate;        /**< Sampling rate of the source data.  Use 0 for 
-                                    variable or unknown sampling rate. */ 
-} OMX_AUDIO_PARAM_ADPCMTYPE; 
+/** ADPCM stream format parameters */
+typedef struct OMX_AUDIO_PARAM_ADPCMTYPE {
+    OMX_U32 nSize;              /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
+    OMX_U32 nPortIndex;         /**< port that this structure applies to */
+    OMX_U32 nChannels;          /**< Number of channels in the data stream (not
+                                     necessarily the same as the number of channels
+                                     to be rendered. */
+    OMX_U32 nBitsPerSample;     /**< Number of bits in each sample */
+    OMX_U32 nSampleRate;        /**< Sampling rate of the source data.  Use 0 for
+                                    variable or unknown sampling rate. */
+} OMX_AUDIO_PARAM_ADPCMTYPE;
 
 
 /** G723 rate */
@@ -443,25 +443,25 @@
     OMX_AUDIO_G723ModeUnused = 0,  /**< AMRNB Mode unused / unknown */
     OMX_AUDIO_G723ModeLow,         /**< 5300 bps */
     OMX_AUDIO_G723ModeHigh,        /**< 6300 bps */
-    OMX_AUDIO_G723ModeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_AUDIO_G723ModeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
     OMX_AUDIO_G723ModeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_AUDIO_G723ModeMax = 0x7FFFFFFF
 } OMX_AUDIO_G723RATE;
 
 
 /** G723 - Sample rate must be 8 KHz */
-typedef struct OMX_AUDIO_PARAM_G723TYPE { 
-    OMX_U32 nSize;                /**< size of the structure in bytes */ 
-    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */ 
-    OMX_U32 nPortIndex;           /**< port that this structure applies to */ 
-    OMX_U32 nChannels;            /**< Number of channels in the data stream (not 
-                                       necessarily the same as the number of channels 
-                                       to be rendered. */ 
-    OMX_BOOL bDTX;                /**< Enable Discontinuous Transmisssion */ 
+typedef struct OMX_AUDIO_PARAM_G723TYPE {
+    OMX_U32 nSize;                /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
+    OMX_U32 nPortIndex;           /**< port that this structure applies to */
+    OMX_U32 nChannels;            /**< Number of channels in the data stream (not
+                                       necessarily the same as the number of channels
+                                       to be rendered. */
+    OMX_BOOL bDTX;                /**< Enable Discontinuous Transmisssion */
     OMX_AUDIO_G723RATE eBitRate;  /**< todo: Should this be moved to a config? */
-    OMX_BOOL bHiPassFilter;       /**< Enable High Pass Filter */ 
-    OMX_BOOL bPostFilter;         /**< Enable Post Filter */ 
-} OMX_AUDIO_PARAM_G723TYPE; 
+    OMX_BOOL bHiPassFilter;       /**< Enable High Pass Filter */
+    OMX_BOOL bPostFilter;         /**< Enable Post Filter */
+} OMX_AUDIO_PARAM_G723TYPE;
 
 
 /** ITU G726 (ADPCM) rate */
@@ -471,22 +471,22 @@
     OMX_AUDIO_G726Mode24,          /**< 24 kbps */
     OMX_AUDIO_G726Mode32,          /**< 32 kbps, most common rate, also G721 */
     OMX_AUDIO_G726Mode40,          /**< 40 kbps */
-    OMX_AUDIO_G726ModeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_AUDIO_G726ModeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
     OMX_AUDIO_G726ModeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_AUDIO_G726ModeMax = 0x7FFFFFFF
 } OMX_AUDIO_G726MODE;
 
 
-/** G.726 stream format parameters - must be at 8KHz */ 
-typedef struct OMX_AUDIO_PARAM_G726TYPE { 
-    OMX_U32 nSize;              /**< size of the structure in bytes */ 
-    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */ 
-    OMX_U32 nPortIndex;         /**< port that this structure applies to */ 
-    OMX_U32 nChannels;          /**< Number of channels in the data stream (not 
-                                     necessarily the same as the number of channels 
-                                     to be rendered. */ 
-     OMX_AUDIO_G726MODE eG726Mode;
-} OMX_AUDIO_PARAM_G726TYPE; 
+/** G.726 stream format parameters - must be at 8KHz */
+typedef struct OMX_AUDIO_PARAM_G726TYPE {
+    OMX_U32 nSize;              /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
+    OMX_U32 nPortIndex;         /**< port that this structure applies to */
+    OMX_U32 nChannels;          /**< Number of channels in the data stream (not
+                                     necessarily the same as the number of channels
+                                     to be rendered. */
+    OMX_AUDIO_G726MODE eG726Mode;
+} OMX_AUDIO_PARAM_G726TYPE;
 
 
 /** G729 coder type */
@@ -495,7 +495,7 @@
     OMX_AUDIO_G729A,              /**< ITU G.729 annex A  encoded data */
     OMX_AUDIO_G729B,              /**< ITU G.729 with annex B encoded data */
     OMX_AUDIO_G729AB,             /**< ITU G.729 annexes A and B encoded data */
-    OMX_AUDIO_G729KhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_AUDIO_G729KhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
     OMX_AUDIO_G729VendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_AUDIO_G729Max = 0x7FFFFFFF
 } OMX_AUDIO_G729TYPE;
@@ -514,23 +514,23 @@
 } OMX_AUDIO_PARAM_G729TYPE;
 
 
-/** AMR Frame format */ 
-typedef enum OMX_AUDIO_AMRFRAMEFORMATTYPE { 
-    OMX_AUDIO_AMRFrameFormatConformance = 0,  /**< Frame Format is AMR Conformance 
-                                                   (Standard) Format */ 
-    OMX_AUDIO_AMRFrameFormatIF1,              /**< Frame Format is AMR Interface 
-                                                   Format 1 */ 
-    OMX_AUDIO_AMRFrameFormatIF2,              /**< Frame Format is AMR Interface 
-                                                   Format 2*/ 
-    OMX_AUDIO_AMRFrameFormatFSF,              /**< Frame Format is AMR File Storage 
-                                                   Format */ 
-    OMX_AUDIO_AMRFrameFormatRTPPayload,       /**< Frame Format is AMR Real-Time 
-                                                   Transport Protocol Payload Format */ 
-    OMX_AUDIO_AMRFrameFormatITU,              /**< Frame Format is ITU Format (added at Motorola request) */ 
-    OMX_AUDIO_AMRFrameFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+/** AMR Frame format */
+typedef enum OMX_AUDIO_AMRFRAMEFORMATTYPE {
+    OMX_AUDIO_AMRFrameFormatConformance = 0,  /**< Frame Format is AMR Conformance
+                                                   (Standard) Format */
+    OMX_AUDIO_AMRFrameFormatIF1,              /**< Frame Format is AMR Interface
+                                                   Format 1 */
+    OMX_AUDIO_AMRFrameFormatIF2,              /**< Frame Format is AMR Interface
+                                                   Format 2*/
+    OMX_AUDIO_AMRFrameFormatFSF,              /**< Frame Format is AMR File Storage
+                                                   Format */
+    OMX_AUDIO_AMRFrameFormatRTPPayload,       /**< Frame Format is AMR Real-Time
+                                                   Transport Protocol Payload Format */
+    OMX_AUDIO_AMRFrameFormatITU,              /**< Frame Format is ITU Format (added at Motorola request) */
+    OMX_AUDIO_AMRFrameFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
     OMX_AUDIO_AMRFrameFormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_AUDIO_AMRFrameFormatMax = 0x7FFFFFFF 
-} OMX_AUDIO_AMRFRAMEFORMATTYPE; 
+    OMX_AUDIO_AMRFrameFormatMax = 0x7FFFFFFF
+} OMX_AUDIO_AMRFRAMEFORMATTYPE;
 
 
 /** AMR band mode */
@@ -538,7 +538,7 @@
     OMX_AUDIO_AMRBandModeUnused = 0,          /**< AMRNB Mode unused / unknown */
     OMX_AUDIO_AMRBandModeNB0,                 /**< AMRNB Mode 0 =  4750 bps */
     OMX_AUDIO_AMRBandModeNB1,                 /**< AMRNB Mode 1 =  5150 bps */
-    OMX_AUDIO_AMRBandModeNB2,                 /**< AMRNB Mode 2 =  5900 bps */ 
+    OMX_AUDIO_AMRBandModeNB2,                 /**< AMRNB Mode 2 =  5900 bps */
     OMX_AUDIO_AMRBandModeNB3,                 /**< AMRNB Mode 3 =  6700 bps */
     OMX_AUDIO_AMRBandModeNB4,                 /**< AMRNB Mode 4 =  7400 bps */
     OMX_AUDIO_AMRBandModeNB5,                 /**< AMRNB Mode 5 =  7950 bps */
@@ -546,36 +546,36 @@
     OMX_AUDIO_AMRBandModeNB7,                 /**< AMRNB Mode 7 = 12200 bps */
     OMX_AUDIO_AMRBandModeWB0,                 /**< AMRWB Mode 0 =  6600 bps */
     OMX_AUDIO_AMRBandModeWB1,                 /**< AMRWB Mode 1 =  8850 bps */
-    OMX_AUDIO_AMRBandModeWB2,                 /**< AMRWB Mode 2 = 12650 bps */ 
-    OMX_AUDIO_AMRBandModeWB3,                 /**< AMRWB Mode 3 = 14250 bps */ 
+    OMX_AUDIO_AMRBandModeWB2,                 /**< AMRWB Mode 2 = 12650 bps */
+    OMX_AUDIO_AMRBandModeWB3,                 /**< AMRWB Mode 3 = 14250 bps */
     OMX_AUDIO_AMRBandModeWB4,                 /**< AMRWB Mode 4 = 15850 bps */
     OMX_AUDIO_AMRBandModeWB5,                 /**< AMRWB Mode 5 = 18250 bps */
     OMX_AUDIO_AMRBandModeWB6,                 /**< AMRWB Mode 6 = 19850 bps */
     OMX_AUDIO_AMRBandModeWB7,                 /**< AMRWB Mode 7 = 23050 bps */
-    OMX_AUDIO_AMRBandModeWB8,                 /**< AMRWB Mode 8 = 23850 bps */      
-    OMX_AUDIO_AMRBandModeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_AUDIO_AMRBandModeWB8,                 /**< AMRWB Mode 8 = 23850 bps */
+    OMX_AUDIO_AMRBandModeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
     OMX_AUDIO_AMRBandModeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_AUDIO_AMRBandModeMax = 0x7FFFFFFF
 } OMX_AUDIO_AMRBANDMODETYPE;
-     
 
-/** AMR Discontinuous Transmission mode */ 
-typedef enum OMX_AUDIO_AMRDTXMODETYPE { 
-    OMX_AUDIO_AMRDTXModeOff = 0,        /**< AMR Discontinuous Transmission Mode is disabled */ 
-    OMX_AUDIO_AMRDTXModeOnVAD1,         /**< AMR Discontinuous Transmission Mode using 
-                                             Voice Activity Detector 1 (VAD1) is enabled */ 
-    OMX_AUDIO_AMRDTXModeOnVAD2,         /**< AMR Discontinuous Transmission Mode using 
-                                             Voice Activity Detector 2 (VAD2) is enabled */       
-    OMX_AUDIO_AMRDTXModeOnAuto,         /**< The codec will automatically select between 
-                                             Off, VAD1 or VAD2 modes */ 
+
+/** AMR Discontinuous Transmission mode */
+typedef enum OMX_AUDIO_AMRDTXMODETYPE {
+    OMX_AUDIO_AMRDTXModeOff = 0,        /**< AMR Discontinuous Transmission Mode is disabled */
+    OMX_AUDIO_AMRDTXModeOnVAD1,         /**< AMR Discontinuous Transmission Mode using
+                                             Voice Activity Detector 1 (VAD1) is enabled */
+    OMX_AUDIO_AMRDTXModeOnVAD2,         /**< AMR Discontinuous Transmission Mode using
+                                             Voice Activity Detector 2 (VAD2) is enabled */
+    OMX_AUDIO_AMRDTXModeOnAuto,         /**< The codec will automatically select between
+                                             Off, VAD1 or VAD2 modes */
 
     OMX_AUDIO_AMRDTXasEFR,             /**< DTX as EFR instead of AMR standard (3GPP 26.101, frame type =8,9,10) */
 
-    OMX_AUDIO_AMRDTXModeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_AUDIO_AMRDTXModeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
     OMX_AUDIO_AMRDTXModeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_AUDIO_AMRDTXModeMax = 0x7FFFFFFF 
-} OMX_AUDIO_AMRDTXMODETYPE; 
- 
+    OMX_AUDIO_AMRDTXModeMax = 0x7FFFFFFF
+} OMX_AUDIO_AMRDTXMODETYPE;
+
 
 /** AMR params */
 typedef struct OMX_AUDIO_PARAM_AMRTYPE {
@@ -584,7 +584,7 @@
     OMX_U32 nPortIndex;                     /**< port that this structure applies to */
     OMX_U32 nChannels;                      /**< Number of channels */
     OMX_U32 nBitRate;                       /**< Bit rate read only field */
-    OMX_AUDIO_AMRBANDMODETYPE eAMRBandMode; /**< AMR Band Mode enumeration */ 
+    OMX_AUDIO_AMRBANDMODETYPE eAMRBandMode; /**< AMR Band Mode enumeration */
     OMX_AUDIO_AMRDTXMODETYPE  eAMRDTXMode;  /**< AMR DTX Mode enumeration */
     OMX_AUDIO_AMRFRAMEFORMATTYPE eAMRFrameFormat; /**< AMR frame format enumeration */
 } OMX_AUDIO_PARAM_AMRTYPE;
@@ -692,7 +692,7 @@
     OMX_AUDIO_CDMARateQuarter,            /**< CDMA encoded frame in quarter rate */
     OMX_AUDIO_CDMARateEighth,             /**< CDMA encoded frame in eighth rate (DTX)*/
     OMX_AUDIO_CDMARateErasure,            /**< CDMA erasure frame */
-    OMX_AUDIO_CDMARateKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_AUDIO_CDMARateKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
     OMX_AUDIO_CDMARateVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_AUDIO_CDMARateMax = 0x7FFFFFFF
 } OMX_AUDIO_CDMARATETYPE;
@@ -764,11 +764,10 @@
 } OMX_AUDIO_PARAM_SMVTYPE;
 
 
-/** MIDI Format 
+/** MIDI Format
  * @ingroup midi
  */
-typedef enum OMX_AUDIO_MIDIFORMATTYPE
-{
+typedef enum OMX_AUDIO_MIDIFORMATTYPE {
     OMX_AUDIO_MIDIFormatUnknown = 0, /**< MIDI Format unknown or don't care */
     OMX_AUDIO_MIDIFormatSMF0,        /**< Standard MIDI File Type 0 */
     OMX_AUDIO_MIDIFormatSMF1,        /**< Standard MIDI File Type 1 */
@@ -777,33 +776,33 @@
     OMX_AUDIO_MIDIFormatXMF0,        /**< eXtensible Music Format type 0 */
     OMX_AUDIO_MIDIFormatXMF1,        /**< eXtensible Music Format type 1 */
     OMX_AUDIO_MIDIFormatMobileXMF,   /**< Mobile XMF (eXtensible Music Format type 2) */
-    OMX_AUDIO_MIDIFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_AUDIO_MIDIFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
     OMX_AUDIO_MIDIFormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_AUDIO_MIDIFormatMax = 0x7FFFFFFF
 } OMX_AUDIO_MIDIFORMATTYPE;
 
 
-/** MIDI params 
+/** MIDI params
  * @ingroup midi
  */
 typedef struct OMX_AUDIO_PARAM_MIDITYPE {
     OMX_U32 nSize;                 /**< size of the structure in bytes */
     OMX_VERSIONTYPE nVersion;      /**< OMX specification version information */
     OMX_U32 nPortIndex;            /**< port that this structure applies to */
-    OMX_U32 nFileSize;             /**< size of the MIDI file in bytes, where the entire 
-                                        MIDI file passed in, otherwise if 0x0, the MIDI data 
-                                        is merged and streamed (instead of passed as an 
+    OMX_U32 nFileSize;             /**< size of the MIDI file in bytes, where the entire
+                                        MIDI file passed in, otherwise if 0x0, the MIDI data
+                                        is merged and streamed (instead of passed as an
                                         entire MIDI file) */
-    OMX_BU32 sMaxPolyphony;        /**< Specifies the maximum simultaneous polyphonic 
-                                        voices. A value of zero indicates that the default 
-                                        polyphony of the device is used  */                                    
-    OMX_BOOL bLoadDefaultSound;    /**< Whether to load default sound 
+    OMX_BU32 sMaxPolyphony;        /**< Specifies the maximum simultaneous polyphonic
+                                        voices. A value of zero indicates that the default
+                                        polyphony of the device is used  */
+    OMX_BOOL bLoadDefaultSound;    /**< Whether to load default sound
                                         bank at initialization */
-    OMX_AUDIO_MIDIFORMATTYPE eMidiFormat; /**< Version of the MIDI file */                                                                           
+    OMX_AUDIO_MIDIFORMATTYPE eMidiFormat; /**< Version of the MIDI file */
 } OMX_AUDIO_PARAM_MIDITYPE;
 
 
-/** Type of the MIDI sound bank 
+/** Type of the MIDI sound bank
  * @ingroup midi
  */
 typedef enum OMX_AUDIO_MIDISOUNDBANKTYPE {
@@ -812,27 +811,27 @@
     OMX_AUDIO_MIDISoundBankDLS2,                 /**< DLS version 2 */
     OMX_AUDIO_MIDISoundBankMobileDLSBase,        /**< Mobile DLS, using the base functionality */
     OMX_AUDIO_MIDISoundBankMobileDLSPlusOptions, /**< Mobile DLS, using the specification-defined optional feature set */
-    OMX_AUDIO_MIDISoundBankKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_AUDIO_MIDISoundBankKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
     OMX_AUDIO_MIDISoundBankVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_AUDIO_MIDISoundBankMax = 0x7FFFFFFF
 } OMX_AUDIO_MIDISOUNDBANKTYPE;
 
 
-/** Bank Layout describes how bank MSB & LSB are used in the DLS instrument definitions sound bank 
+/** Bank Layout describes how bank MSB & LSB are used in the DLS instrument definitions sound bank
  * @ingroup midi
  */
 typedef enum OMX_AUDIO_MIDISOUNDBANKLAYOUTTYPE {
-   OMX_AUDIO_MIDISoundBankLayoutUnused = 0,   /**< unused/unknown soundbank type */
-   OMX_AUDIO_MIDISoundBankLayoutGM,           /**< GS layout (based on bank MSB 0x00) */
-   OMX_AUDIO_MIDISoundBankLayoutGM2,          /**< General MIDI 2 layout (using MSB 0x78/0x79, LSB 0x00) */
-   OMX_AUDIO_MIDISoundBankLayoutUser,         /**< Does not conform to any bank numbering standards */
-   OMX_AUDIO_MIDISoundBankLayoutKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
-   OMX_AUDIO_MIDISoundBankLayoutVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-   OMX_AUDIO_MIDISoundBankLayoutMax = 0x7FFFFFFF
+    OMX_AUDIO_MIDISoundBankLayoutUnused = 0,   /**< unused/unknown soundbank type */
+    OMX_AUDIO_MIDISoundBankLayoutGM,           /**< GS layout (based on bank MSB 0x00) */
+    OMX_AUDIO_MIDISoundBankLayoutGM2,          /**< General MIDI 2 layout (using MSB 0x78/0x79, LSB 0x00) */
+    OMX_AUDIO_MIDISoundBankLayoutUser,         /**< Does not conform to any bank numbering standards */
+    OMX_AUDIO_MIDISoundBankLayoutKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_AUDIO_MIDISoundBankLayoutVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_MIDISoundBankLayoutMax = 0x7FFFFFFF
 } OMX_AUDIO_MIDISOUNDBANKLAYOUTTYPE;
 
 
-/** MIDI params to load/unload user soundbank 
+/** MIDI params to load/unload user soundbank
  * @ingroup midi
  */
 typedef struct OMX_AUDIO_PARAM_MIDILOADUSERSOUNDTYPE {
@@ -847,8 +846,8 @@
 } OMX_AUDIO_PARAM_MIDILOADUSERSOUNDTYPE;
 
 
-/** Structure for Live MIDI events and MIP messages. 
- * (MIP = Maximum Instantaneous Polyphony; part of the SP-MIDI standard.) 
+/** Structure for Live MIDI events and MIP messages.
+ * (MIP = Maximum Instantaneous Polyphony; part of the SP-MIDI standard.)
  * @ingroup midi
  */
 typedef struct OMX_AUDIO_CONFIG_MIDIIMMEDIATEEVENTTYPE {
@@ -857,12 +856,12 @@
     OMX_U32 nPortIndex;       /**< Port that this structure applies to */
     OMX_U32 nMidiEventSize;   /**< Size of immediate MIDI events or MIP message in bytes  */
     OMX_U8 nMidiEvents[1];    /**< MIDI event array to be rendered immediately, or an
-                                   array for the MIP message buffer, where the size is 
+                                   array for the MIP message buffer, where the size is
                                    indicated by nMidiEventSize */
 } OMX_AUDIO_CONFIG_MIDIIMMEDIATEEVENTTYPE;
 
 
-/** MIDI sound bank/ program pair in a given channel 
+/** MIDI sound bank/ program pair in a given channel
  * @ingroup midi
  */
 typedef struct OMX_AUDIO_CONFIG_MIDISOUNDBANKPROGRAMTYPE {
@@ -872,29 +871,29 @@
     OMX_U32 nChannel;           /**< Valid channel values range from 1 to 16 */
     OMX_U16 nIDProgram;         /**< Valid program ID range is 1 to 128 */
     OMX_U16 nIDSoundBank;       /**< Sound bank ID */
-    OMX_U32 nUserSoundBankIndex;/**< User soundbank index, easier to access soundbanks 
+    OMX_U32 nUserSoundBankIndex;/**< User soundbank index, easier to access soundbanks
                                      by index if multiple banks are present */
 } OMX_AUDIO_CONFIG_MIDISOUNDBANKPROGRAMTYPE;
 
 
-/** MIDI control 
+/** MIDI control
  * @ingroup midi
  */
 typedef struct OMX_AUDIO_CONFIG_MIDICONTROLTYPE {
     OMX_U32 nSize;                /**< size of the structure in bytes */
     OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
     OMX_U32 nPortIndex;           /**< port that this structure applies to */
-    OMX_BS32 sPitchTransposition; /**< Pitch transposition in semitones, stored as Q22.10 
+    OMX_BS32 sPitchTransposition; /**< Pitch transposition in semitones, stored as Q22.10
                                        format based on JAVA MMAPI (JSR-135) requirement */
     OMX_BU32 sPlayBackRate;       /**< Relative playback rate, stored as Q14.17 fixed-point
                                        number based on JSR-135 requirement */
-    OMX_BU32 sTempo ;             /**< Tempo in beats per minute (BPM), stored as Q22.10 
+    OMX_BU32 sTempo ;             /**< Tempo in beats per minute (BPM), stored as Q22.10
                                        fixed-point number based on JSR-135 requirement */
-    OMX_U32 nMaxPolyphony;        /**< Specifies the maximum simultaneous polyphonic 
-                                       voices. A value of zero indicates that the default 
+    OMX_U32 nMaxPolyphony;        /**< Specifies the maximum simultaneous polyphonic
+                                       voices. A value of zero indicates that the default
                                        polyphony of the device is used  */
     OMX_U32 nNumRepeat;           /**< Number of times to repeat playback */
-    OMX_U32 nStopTime;            /**< Time in milliseconds to indicate when playback 
+    OMX_U32 nStopTime;            /**< Time in milliseconds to indicate when playback
                                        will stop automatically.  Set to zero if not used */
     OMX_U16 nChannelMuteMask;     /**< 16 bit mask for channel mute status */
     OMX_U16 nChannelSoloMask;     /**< 16 bit mask for channel solo status */
@@ -906,125 +905,125 @@
 } OMX_AUDIO_CONFIG_MIDICONTROLTYPE;
 
 
-/** MIDI Playback States 
+/** MIDI Playback States
  * @ingroup midi
  */
 typedef enum OMX_AUDIO_MIDIPLAYBACKSTATETYPE {
-  OMX_AUDIO_MIDIPlayBackStateUnknown = 0,      /**< Unknown state or state does not map to 
-  													other defined states */
-  OMX_AUDIO_MIDIPlayBackStateClosedEngaged,    /**< No MIDI resource is currently open. 
-                                                    The MIDI engine is currently processing 
+    OMX_AUDIO_MIDIPlayBackStateUnknown = 0,      /**< Unknown state or state does not map to
+                                                    other defined states */
+    OMX_AUDIO_MIDIPlayBackStateClosedEngaged,    /**< No MIDI resource is currently open.
+                                                    The MIDI engine is currently processing
                                                     MIDI events. */
-  OMX_AUDIO_MIDIPlayBackStateParsing,          /**< A MIDI resource is open and is being 
-                                                    primed. The MIDI engine is currently 
+    OMX_AUDIO_MIDIPlayBackStateParsing,          /**< A MIDI resource is open and is being
+                                                    primed. The MIDI engine is currently
                                                     processing MIDI events. */
-  OMX_AUDIO_MIDIPlayBackStateOpenEngaged,      /**< A MIDI resource is open and primed but 
+    OMX_AUDIO_MIDIPlayBackStateOpenEngaged,      /**< A MIDI resource is open and primed but
                                                     not playing. The MIDI engine is currently
                                                     processing MIDI events. The transition to
-                                                    this state is only possible from the 
+                                                    this state is only possible from the
                                                     OMX_AUDIO_MIDIPlayBackStatePlaying state,
                                                     when the 'playback head' reaches the end
                                                     of media data or the playback stops due
                                                     to stop time set.*/
-  OMX_AUDIO_MIDIPlayBackStatePlaying,          /**< A MIDI resource is open and currently
+    OMX_AUDIO_MIDIPlayBackStatePlaying,          /**< A MIDI resource is open and currently
                                                     playing. The MIDI engine is currently
                                                     processing MIDI events.*/
-  OMX_AUDIO_MIDIPlayBackStatePlayingPartially, /**< Best-effort playback due to SP-MIDI/DLS
+    OMX_AUDIO_MIDIPlayBackStatePlayingPartially, /**< Best-effort playback due to SP-MIDI/DLS
                                                     resource constraints */
-  OMX_AUDIO_MIDIPlayBackStatePlayingSilently,  /**< Due to system resource constraints and
+    OMX_AUDIO_MIDIPlayBackStatePlayingSilently,  /**< Due to system resource constraints and
                                                     SP-MIDI content constraints, there is
                                                     no audible MIDI content during playback
                                                     currently. The situation may change if
                                                     resources are freed later.*/
-  OMX_AUDIO_MIDIPlayBackStateKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
-  OMX_AUDIO_MIDIPlayBackStateVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-  OMX_AUDIO_MIDIPlayBackStateMax = 0x7FFFFFFF
+    OMX_AUDIO_MIDIPlayBackStateKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_AUDIO_MIDIPlayBackStateVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_MIDIPlayBackStateMax = 0x7FFFFFFF
 } OMX_AUDIO_MIDIPLAYBACKSTATETYPE;
 
 
-/** MIDI status 
+/** MIDI status
  * @ingroup midi
  */
 typedef struct OMX_AUDIO_CONFIG_MIDISTATUSTYPE {
     OMX_U32 nSize;              /**< size of the structure in bytes */
     OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
     OMX_U32 nPortIndex;         /**< port that this structure applies to */
-    OMX_U16 nNumTracks;         /**< Number of MIDI tracks in the file, read only field. 
-                                     NOTE: May not return a meaningful value until the entire 
+    OMX_U16 nNumTracks;         /**< Number of MIDI tracks in the file, read only field.
+                                     NOTE: May not return a meaningful value until the entire
                                      file is parsed and buffered.  */
-    OMX_U32 nDuration;          /**< The length of the currently open MIDI resource 
-                                     in milliseconds. NOTE: May not return a meaningful value 
-                                     until the entire file is parsed and buffered.  */  
-    OMX_U32 nPosition;          /**< Current Position of the MIDI resource being played 
+    OMX_U32 nDuration;          /**< The length of the currently open MIDI resource
+                                     in milliseconds. NOTE: May not return a meaningful value
+                                     until the entire file is parsed and buffered.  */
+    OMX_U32 nPosition;          /**< Current Position of the MIDI resource being played
                                      in milliseconds */
-    OMX_BOOL bVibra;            /**< Does Vibra track exist? NOTE: May not return a meaningful 
+    OMX_BOOL bVibra;            /**< Does Vibra track exist? NOTE: May not return a meaningful
                                      value until the entire file is parsed and buffered. */
-    OMX_U32 nNumMetaEvents;     /**< Total number of MIDI Meta Events in the currently 
-                                     open MIDI resource. NOTE: May not return a meaningful value 
+    OMX_U32 nNumMetaEvents;     /**< Total number of MIDI Meta Events in the currently
+                                     open MIDI resource. NOTE: May not return a meaningful value
                                      until the entire file is parsed and buffered.  */
-    OMX_U32 nNumActiveVoices;   /**< Number of active voices in the currently playing 
-                                     MIDI resource. NOTE: May not return a meaningful value until 
+    OMX_U32 nNumActiveVoices;   /**< Number of active voices in the currently playing
+                                     MIDI resource. NOTE: May not return a meaningful value until
                                      the entire file is parsed and buffered. */
     OMX_AUDIO_MIDIPLAYBACKSTATETYPE eMIDIPlayBackState;  /**< MIDI playback state enumeration, read only field */
 } OMX_AUDIO_CONFIG_MIDISTATUSTYPE;
 
 
 /** MIDI Meta Event structure one per Meta Event.
- *  MIDI Meta Events are like audio metadata, except that they are interspersed 
- *  with the MIDI content throughout the file and are not localized in the header. 
- *  As such, it is necessary to retrieve information about these Meta Events from 
- *  the engine, as it encounters these Meta Events within the MIDI content. 
- *  For example, SMF files can have up to 14 types of MIDI Meta Events (copyright, 
- *  author, default tempo, etc.) scattered throughout the file. 
+ *  MIDI Meta Events are like audio metadata, except that they are interspersed
+ *  with the MIDI content throughout the file and are not localized in the header.
+ *  As such, it is necessary to retrieve information about these Meta Events from
+ *  the engine, as it encounters these Meta Events within the MIDI content.
+ *  For example, SMF files can have up to 14 types of MIDI Meta Events (copyright,
+ *  author, default tempo, etc.) scattered throughout the file.
  *  @ingroup midi
  */
-typedef struct OMX_AUDIO_CONFIG_MIDIMETAEVENTTYPE{ 
-    OMX_U32 nSize;            /**< size of the structure in bytes */ 
-    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */ 
-    OMX_U32 nPortIndex;       /**< port that this structure applies to */ 
-    OMX_U32 nIndex;           /**< Index of Meta Event */ 
-    OMX_U8 nMetaEventType;    /**< Meta Event Type, 7bits (i.e. 0 - 127) */ 
-    OMX_U32 nMetaEventSize;   /**< size of the Meta Event in bytes */ 
+typedef struct OMX_AUDIO_CONFIG_MIDIMETAEVENTTYPE {
+    OMX_U32 nSize;            /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    OMX_U32 nPortIndex;       /**< port that this structure applies to */
+    OMX_U32 nIndex;           /**< Index of Meta Event */
+    OMX_U8 nMetaEventType;    /**< Meta Event Type, 7bits (i.e. 0 - 127) */
+    OMX_U32 nMetaEventSize;   /**< size of the Meta Event in bytes */
     OMX_U32 nTrack;           /**< track number for the meta event */
     OMX_U32 nPosition;        /**< Position of the meta-event in milliseconds */
-} OMX_AUDIO_CONFIG_MIDIMETAEVENTTYPE; 
+} OMX_AUDIO_CONFIG_MIDIMETAEVENTTYPE;
 
 
-/** MIDI Meta Event Data structure - one per Meta Event. 
+/** MIDI Meta Event Data structure - one per Meta Event.
  * @ingroup midi
- */ 
-typedef struct OMX_AUDIO_CONFIG_MIDIMETAEVENTDATATYPE{ 
-    OMX_U32 nSize;            /**< size of the structure in bytes */ 
-    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */ 
-    OMX_U32 nPortIndex;       /**< port that this structure applies to */ 
-    OMX_U32 nIndex;           /**< Index of Meta Event */ 
-    OMX_U32 nMetaEventSize;   /**< size of the Meta Event in bytes */ 
-    OMX_U8 nData[1];          /**< array of one or more bytes of meta data 
-                                   as indicated by the nMetaEventSize field */ 
-} OMX_AUDIO_CONFIG__MIDIMETAEVENTDATATYPE; 
+ */
+typedef struct OMX_AUDIO_CONFIG_MIDIMETAEVENTDATATYPE {
+    OMX_U32 nSize;            /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    OMX_U32 nPortIndex;       /**< port that this structure applies to */
+    OMX_U32 nIndex;           /**< Index of Meta Event */
+    OMX_U32 nMetaEventSize;   /**< size of the Meta Event in bytes */
+    OMX_U8 nData[1];          /**< array of one or more bytes of meta data
+                                   as indicated by the nMetaEventSize field */
+} OMX_AUDIO_CONFIG__MIDIMETAEVENTDATATYPE;
 
 
 /** Audio Volume adjustment for a port */
 typedef struct OMX_AUDIO_CONFIG_VOLUMETYPE {
     OMX_U32 nSize;              /**< size of the structure in bytes */
     OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
-    OMX_U32 nPortIndex;         /**< Port index indicating which port to 
-                                     set.  Select the input port to set 
-                                     just that port's volume.  Select the 
-                                     output port to adjust the master 
+    OMX_U32 nPortIndex;         /**< Port index indicating which port to
+                                     set.  Select the input port to set
+                                     just that port's volume.  Select the
+                                     output port to adjust the master
                                      volume. */
-    OMX_BOOL bLinear;           /**< Is the volume to be set in linear (0.100) 
+    OMX_BOOL bLinear;           /**< Is the volume to be set in linear (0.100)
                                      or logarithmic scale (mB) */
     OMX_BS32 sVolume;           /**< Volume linear setting in the 0..100 range, OR
                                      Volume logarithmic setting for this port.  The values
                                      for volume are in mB (millibels = 1/100 dB) relative
-                                     to a gain of 1 (e.g. the output is the same as the 
-                                     input level).  Values are in mB from nMax 
+                                     to a gain of 1 (e.g. the output is the same as the
+                                     input level).  Values are in mB from nMax
                                      (maximum volume) to nMin mB (typically negative).
                                      Since the volume is "voltage"
                                      and not a "power", it takes a setting of
                                      -600 mB to decrease the volume by 1/2.  If
-                                     a component cannot accurately set the 
+                                     a component cannot accurately set the
                                      volume to the requested value, it must
                                      set the volume to the closest value BELOW
                                      the requested value.  When getting the
@@ -1037,27 +1036,27 @@
 typedef struct OMX_AUDIO_CONFIG_CHANNELVOLUMETYPE {
     OMX_U32 nSize;              /**< size of the structure in bytes */
     OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
-    OMX_U32 nPortIndex;         /**< Port index indicating which port to 
-                                     set.  Select the input port to set 
-                                     just that port's volume.  Select the 
-                                     output port to adjust the master 
+    OMX_U32 nPortIndex;         /**< Port index indicating which port to
+                                     set.  Select the input port to set
+                                     just that port's volume.  Select the
+                                     output port to adjust the master
                                      volume. */
-    OMX_U32 nChannel;           /**< channel to select from 0 to N-1, 
+    OMX_U32 nChannel;           /**< channel to select from 0 to N-1,
                                      using OMX_ALL to apply volume settings
                                      to all channels */
-    OMX_BOOL bLinear;           /**< Is the volume to be set in linear (0.100) or 
+    OMX_BOOL bLinear;           /**< Is the volume to be set in linear (0.100) or
                                      logarithmic scale (mB) */
     OMX_BS32 sVolume;           /**< Volume linear setting in the 0..100 range, OR
-                                     Volume logarithmic setting for this port.  
-                                     The values for volume are in mB 
+                                     Volume logarithmic setting for this port.
+                                     The values for volume are in mB
                                      (millibels = 1/100 dB) relative to a gain
-                                     of 1 (e.g. the output is the same as the 
-                                     input level).  Values are in mB from nMax 
-                                     (maximum volume) to nMin mB (typically negative).  
+                                     of 1 (e.g. the output is the same as the
+                                     input level).  Values are in mB from nMax
+                                     (maximum volume) to nMin mB (typically negative).
                                      Since the volume is "voltage"
                                      and not a "power", it takes a setting of
                                      -600 mB to decrease the volume by 1/2.  If
-                                     a component cannot accurately set the 
+                                     a component cannot accurately set the
                                      volume to the requested value, it must
                                      set the volume to the closest value BELOW
                                      the requested value.  When getting the
@@ -1072,12 +1071,12 @@
 typedef struct OMX_AUDIO_CONFIG_BALANCETYPE {
     OMX_U32 nSize;              /**< size of the structure in bytes */
     OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
-    OMX_U32 nPortIndex;         /**< Port index indicating which port to 
-                                     set.  Select the input port to set 
-                                     just that port's balance.  Select the 
-                                     output port to adjust the master 
+    OMX_U32 nPortIndex;         /**< Port index indicating which port to
+                                     set.  Select the input port to set
+                                     just that port's balance.  Select the
+                                     output port to adjust the master
                                      balance. */
-    OMX_S32 nBalance;           /**< balance setting for this port 
+    OMX_S32 nBalance;           /**< balance setting for this port
                                      (-100 to 100, where -100 indicates
                                      all left, and no right */
 } OMX_AUDIO_CONFIG_BALANCETYPE;
@@ -1087,10 +1086,10 @@
 typedef struct OMX_AUDIO_CONFIG_MUTETYPE {
     OMX_U32 nSize;              /**< size of the structure in bytes */
     OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
-    OMX_U32 nPortIndex;         /**< Port index indicating which port to 
-                                     set.  Select the input port to set 
-                                     just that port's mute.  Select the 
-                                     output port to adjust the master 
+    OMX_U32 nPortIndex;         /**< Port index indicating which port to
+                                     set.  Select the input port to set
+                                     just that port's mute.  Select the
+                                     output port to adjust the master
                                      mute. */
     OMX_BOOL bMute;             /**< Mute setting for this port */
 } OMX_AUDIO_CONFIG_MUTETYPE;
@@ -1101,20 +1100,20 @@
     OMX_U32 nSize;              /**< size of the structure in bytes */
     OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
     OMX_U32 nPortIndex;         /**< port that this structure applies to */
-    OMX_U32 nChannel;           /**< channel to select from 0 to N-1, 
+    OMX_U32 nChannel;           /**< channel to select from 0 to N-1,
                                      using OMX_ALL to apply mute settings
                                      to all channels */
     OMX_BOOL bMute;             /**< Mute setting for this channel */
     OMX_BOOL bIsMIDI;           /**< TRUE if nChannel refers to a MIDI channel,
-                                     FALSE otherwise */ 
+                                     FALSE otherwise */
 } OMX_AUDIO_CONFIG_CHANNELMUTETYPE;
 
 
 
-/** Enable / Disable for loudness control, which boosts bass and to a 
+/** Enable / Disable for loudness control, which boosts bass and to a
  *  smaller extent high end frequencies to compensate for hearing
  *  ability at the extreme ends of the audio spectrum
- */ 
+ */
 typedef struct OMX_AUDIO_CONFIG_LOUDNESSTYPE {
     OMX_U32 nSize;             /**< size of the structure in bytes */
     OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
@@ -1124,33 +1123,33 @@
 
 
 /** Enable / Disable for bass, which controls low frequencies
- */ 
+ */
 typedef struct OMX_AUDIO_CONFIG_BASSTYPE {
     OMX_U32 nSize;             /**< size of the structure in bytes */
     OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
     OMX_U32 nPortIndex;        /**< port that this structure applies to */
     OMX_BOOL bEnable;          /**< Enable/disable for bass control */
-    OMX_S32 nBass;             /**< bass setting for the port, as a 
-                                    continuous value from -100 to 100  
+    OMX_S32 nBass;             /**< bass setting for the port, as a
+                                    continuous value from -100 to 100
                                     (0 means no change in bass level)*/
 } OMX_AUDIO_CONFIG_BASSTYPE;
 
 
 /** Enable / Disable for treble, which controls high frequencies tones
- */ 
+ */
 typedef struct OMX_AUDIO_CONFIG_TREBLETYPE {
     OMX_U32 nSize;             /**< size of the structure in bytes */
     OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
     OMX_U32 nPortIndex;        /**< port that this structure applies to */
     OMX_BOOL bEnable;          /**< Enable/disable for treble control */
     OMX_S32  nTreble;          /**< treble setting for the port, as a
-                                    continuous value from -100 to 100  
+                                    continuous value from -100 to 100
                                     (0 means no change in treble level) */
 } OMX_AUDIO_CONFIG_TREBLETYPE;
 
 
-/** An equalizer is typically used for two reasons: to compensate for an 
- *  sub-optimal frequency response of a system to make it sound more natural 
+/** An equalizer is typically used for two reasons: to compensate for an
+ *  sub-optimal frequency response of a system to make it sound more natural
  *  or to create intentionally some unnatural coloring to the sound to create
  *  an effect.
  *  @ingroup effects
@@ -1160,33 +1159,33 @@
     OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
     OMX_U32 nPortIndex;        /**< port that this structure applies to */
     OMX_BOOL bEnable;          /**< Enable/disable for equalizer */
-    OMX_BU32 sBandIndex;       /**< Band number to be set.  Upper Limit is 
+    OMX_BU32 sBandIndex;       /**< Band number to be set.  Upper Limit is
                                     N-1, where N is the number of bands, lower limit is 0 */
     OMX_BU32 sCenterFreq;      /**< Center frequecies in Hz.  This is a
-                                    read only element and is used to determine 
-                                    the lower, center and upper frequency of 
+                                    read only element and is used to determine
+                                    the lower, center and upper frequency of
                                     this band.  */
     OMX_BS32 sBandLevel;       /**< band level in millibels */
 } OMX_AUDIO_CONFIG_EQUALIZERTYPE;
 
 
-/** Stereo widening mode type 
+/** Stereo widening mode type
  * @ingroup effects
- */ 
+ */
 typedef enum OMX_AUDIO_STEREOWIDENINGTYPE {
     OMX_AUDIO_StereoWideningHeadphones,    /**< Stereo widening for loudspeakers */
     OMX_AUDIO_StereoWideningLoudspeakers,  /**< Stereo widening for closely spaced loudspeakers */
-    OMX_AUDIO_StereoWideningKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_AUDIO_StereoWideningKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
     OMX_AUDIO_StereoWideningVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_AUDIO_StereoWideningMax = 0x7FFFFFFF
 } OMX_AUDIO_STEREOWIDENINGTYPE;
 
 
 /** Control for stereo widening, which is a special 2-channel
- *  case of the audio virtualizer effect. For example, for 5.1-channel 
- *  output, it translates to virtual surround sound. 
+ *  case of the audio virtualizer effect. For example, for 5.1-channel
+ *  output, it translates to virtual surround sound.
  * @ingroup effects
- */ 
+ */
 typedef struct OMX_AUDIO_CONFIG_STEREOWIDENINGTYPE {
     OMX_U32 nSize;             /**< size of the structure in bytes */
     OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
@@ -1199,10 +1198,10 @@
 
 
 /** The chorus effect (or ``choralizer'') is any signal processor which makes
- *  one sound source (such as a voice) sound like many such sources singing 
- *  (or playing) in unison. Since performance in unison is never exact, chorus 
- *  effects simulate this by making independently modified copies of the input 
- *  signal. Modifications may include (1) delay, (2) frequency shift, and 
+ *  one sound source (such as a voice) sound like many such sources singing
+ *  (or playing) in unison. Since performance in unison is never exact, chorus
+ *  effects simulate this by making independently modified copies of the input
+ *  signal. Modifications may include (1) delay, (2) frequency shift, and
  *  (3) amplitude modulation.
  * @ingroup effects
  */
@@ -1213,16 +1212,16 @@
     OMX_BOOL bEnable;          /**< Enable/disable for chorus */
     OMX_BU32 sDelay;           /**< average delay in milliseconds */
     OMX_BU32 sModulationRate;  /**< rate of modulation in millihertz */
-    OMX_U32 nModulationDepth;  /**< depth of modulation as a percentage of 
+    OMX_U32 nModulationDepth;  /**< depth of modulation as a percentage of
                                     delay (i.e. 0 to 100) */
     OMX_BU32 nFeedback;        /**< Feedback from chorus output to input in percentage */
 } OMX_AUDIO_CONFIG_CHORUSTYPE;
 
 
-/** Reverberation is part of the reflected sound that follows the early 
- *  reflections. In a typical room, this consists of a dense succession of 
- *  echoes whose energy decays exponentially. The reverberation effect structure 
- *  as defined here includes both (early) reflections as well as (late) reverberations. 
+/** Reverberation is part of the reflected sound that follows the early
+ *  reflections. In a typical room, this consists of a dense succession of
+ *  echoes whose energy decays exponentially. The reverberation effect structure
+ *  as defined here includes both (early) reflections as well as (late) reverberations.
  * @ingroup effects
  */
 typedef struct OMX_AUDIO_CONFIG_REVERBERATIONTYPE {
@@ -1230,57 +1229,57 @@
     OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
     OMX_U32 nPortIndex;           /**< port that this structure applies to */
     OMX_BOOL bEnable;             /**< Enable/disable for reverberation control */
-    OMX_BS32 sRoomLevel;          /**< Intensity level for the whole room effect 
-                                       (i.e. both early reflections and late 
+    OMX_BS32 sRoomLevel;          /**< Intensity level for the whole room effect
+                                       (i.e. both early reflections and late
                                        reverberation) in millibels */
     OMX_BS32 sRoomHighFreqLevel;  /**< Attenuation at high frequencies
                                        relative to the intensity at low
                                        frequencies in millibels */
     OMX_BS32 sReflectionsLevel;   /**< Intensity level of early reflections
                                        (relative to room value), in millibels */
-    OMX_BU32 sReflectionsDelay;   /**< Delay time of the first reflection relative 
+    OMX_BU32 sReflectionsDelay;   /**< Delay time of the first reflection relative
                                        to the direct path, in milliseconds */
     OMX_BS32 sReverbLevel;        /**< Intensity level of late reverberation
                                        relative to room level, in millibels */
-    OMX_BU32 sReverbDelay;        /**< Time delay from the first early reflection 
-                                       to the beginning of the late reverberation 
+    OMX_BU32 sReverbDelay;        /**< Time delay from the first early reflection
+                                       to the beginning of the late reverberation
                                        section, in milliseconds */
     OMX_BU32 sDecayTime;          /**< Late reverberation decay time at low
                                        frequencies, in milliseconds */
-    OMX_BU32 nDecayHighFreqRatio; /**< Ratio of high frequency decay time relative 
+    OMX_BU32 nDecayHighFreqRatio; /**< Ratio of high frequency decay time relative
                                        to low frequency decay time in percent  */
     OMX_U32 nDensity;             /**< Modal density in the late reverberation decay,
                                        in percent (i.e. 0 - 100) */
     OMX_U32 nDiffusion;           /**< Echo density in the late reverberation decay,
                                        in percent (i.e. 0 - 100) */
-    OMX_BU32 sReferenceHighFreq;  /**< Reference high frequency in Hertz. This is 
-                                       the frequency used as the reference for all 
+    OMX_BU32 sReferenceHighFreq;  /**< Reference high frequency in Hertz. This is
+                                       the frequency used as the reference for all
                                        the high-frequency settings above */
 
 } OMX_AUDIO_CONFIG_REVERBERATIONTYPE;
 
 
-/** Possible settings for the Echo Cancelation structure to use 
+/** Possible settings for the Echo Cancelation structure to use
  * @ingroup effects
  */
 typedef enum OMX_AUDIO_ECHOCANTYPE {
-   OMX_AUDIO_EchoCanOff = 0,    /**< Echo Cancellation is disabled */
-   OMX_AUDIO_EchoCanNormal,     /**< Echo Cancellation normal operation - 
+    OMX_AUDIO_EchoCanOff = 0,    /**< Echo Cancellation is disabled */
+    OMX_AUDIO_EchoCanNormal,     /**< Echo Cancellation normal operation -
                                      echo from plastics and face */
-   OMX_AUDIO_EchoCanHFree,      /**< Echo Cancellation optimized for 
+    OMX_AUDIO_EchoCanHFree,      /**< Echo Cancellation optimized for
                                      Hands Free operation */
-   OMX_AUDIO_EchoCanCarKit,    /**< Echo Cancellation optimized for 
+    OMX_AUDIO_EchoCanCarKit,    /**< Echo Cancellation optimized for
                                      Car Kit (longer echo) */
-   OMX_AUDIO_EchoCanKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
-   OMX_AUDIO_EchoCanVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-   OMX_AUDIO_EchoCanMax = 0x7FFFFFFF
+    OMX_AUDIO_EchoCanKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_AUDIO_EchoCanVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_EchoCanMax = 0x7FFFFFFF
 } OMX_AUDIO_ECHOCANTYPE;
 
 
 /** Enable / Disable for echo cancelation, which removes undesired echo's
  *  from the audio
  * @ingroup effects
- */ 
+ */
 typedef struct OMX_AUDIO_CONFIG_ECHOCANCELATIONTYPE {
     OMX_U32 nSize;             /**< size of the structure in bytes */
     OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
@@ -1292,7 +1291,7 @@
 /** Enable / Disable for noise reduction, which undesired noise from
  * the audio
  * @ingroup effects
- */ 
+ */
 typedef struct OMX_AUDIO_CONFIG_NOISEREDUCTIONTYPE {
     OMX_U32 nSize;             /**< size of the structure in bytes */
     OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
Index: gst-omx-1.22.0/omx/openmax/OMX_Component.h
===================================================================
--- gst-omx-1.22.0.orig/omx/openmax/OMX_Component.h	2023-03-02 08:48:43.000000000 +0000
+++ gst-omx-1.22.0/omx/openmax/OMX_Component.h	2023-03-02 08:58:22.000000000 +0000
@@ -1,23 +1,23 @@
 /*
- * Copyright (c) 2008 The Khronos Group Inc. 
- * 
+ * Copyright (c) 2008 The Khronos Group Inc.
+ *
  * Permission is hereby granted, free of charge, to any person obtaining
  * a copy of this software and associated documentation files (the
  * "Software"), to deal in the Software without restriction, including
  * without limitation the rights to use, copy, modify, merge, publish,
  * distribute, sublicense, and/or sell copies of the Software, and to
  * permit persons to whom the Software is furnished to do so, subject
- * to the following conditions: 
+ * to the following conditions:
  * The above copyright notice and this permission notice shall be included
- * in all copies or substantial portions of the Software. 
- * 
+ * in all copies or substantial portions of the Software.
+ *
  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
  * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
  * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  *
  */
 
@@ -38,7 +38,7 @@
 
 /* Each OMX header must include all required header files to allow the
  *  header to compile without errors.  The includes below are required
- *  for this header file to compile successfully 
+ *  for this header file to compile successfully
  */
 
 #include <OMX_Audio.h>
@@ -47,12 +47,12 @@
 #include <OMX_Other.h>
 
 /** @ingroup comp */
-typedef enum OMX_PORTDOMAINTYPE { 
-    OMX_PortDomainAudio, 
-    OMX_PortDomainVideo, 
-    OMX_PortDomainImage, 
+typedef enum OMX_PORTDOMAINTYPE {
+    OMX_PortDomainAudio,
+    OMX_PortDomainVideo,
+    OMX_PortDomainImage,
     OMX_PortDomainOther,
-    OMX_PortDomainKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_PortDomainKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
     OMX_PortDomainVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_PortDomainMax = 0x7ffffff
 } OMX_PORTDOMAINTYPE;
@@ -71,7 +71,7 @@
                                         When disabled a port is unpopulated. A disabled port
                                         is not populated with buffers on a transition to IDLE. */
     OMX_BOOL bPopulated;           /**< Port is populated with all of its buffers as indicated by
-                                        nBufferCountActual. A disabled port is always unpopulated. 
+                                        nBufferCountActual. A disabled port is always unpopulated.
                                         An enabled port is populated on a transition to OMX_StateIdle
                                         and unpopulated on a transition to loaded. */
     OMX_PORTDOMAINTYPE eDomain;    /**< Domain of the port. Determines the contents of metadata below. */
@@ -86,26 +86,26 @@
 } OMX_PARAM_PORTDEFINITIONTYPE;
 
 /** @ingroup comp */
-typedef struct OMX_PARAM_U32TYPE { 
-    OMX_U32 nSize;                    /**< Size of this structure, in Bytes */ 
-    OMX_VERSIONTYPE nVersion;         /**< OMX specification version information */ 
-    OMX_U32 nPortIndex;               /**< port that this structure applies to */ 
+typedef struct OMX_PARAM_U32TYPE {
+    OMX_U32 nSize;                    /**< Size of this structure, in Bytes */
+    OMX_VERSIONTYPE nVersion;         /**< OMX specification version information */
+    OMX_U32 nPortIndex;               /**< port that this structure applies to */
     OMX_U32 nU32;                     /**< U32 value */
 } OMX_PARAM_U32TYPE;
 
 /** @ingroup rpm */
 typedef enum OMX_SUSPENSIONPOLICYTYPE {
     OMX_SuspensionDisabled, /**< No suspension; v1.0 behavior */
-    OMX_SuspensionEnabled,  /**< Suspension allowed */   
-    OMX_SuspensionPolicyKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_SuspensionEnabled,  /**< Suspension allowed */
+    OMX_SuspensionPolicyKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
     OMX_SuspensionPolicyStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_SuspensionPolicyMax = 0x7fffffff
 } OMX_SUSPENSIONPOLICYTYPE;
 
 /** @ingroup rpm */
 typedef struct OMX_PARAM_SUSPENSIONPOLICYTYPE {
-    OMX_U32 nSize;                  
-    OMX_VERSIONTYPE nVersion;        
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
     OMX_SUSPENSIONPOLICYTYPE ePolicy;
 } OMX_PARAM_SUSPENSIONPOLICYTYPE;
 
@@ -113,28 +113,27 @@
 typedef enum OMX_SUSPENSIONTYPE {
     OMX_NotSuspended, /**< component is not suspended */
     OMX_Suspended,    /**< component is suspended */
-    OMX_SuspensionKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_SuspensionKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
     OMX_SuspensionVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_SuspendMax = 0x7FFFFFFF
 } OMX_SUSPENSIONTYPE;
 
 /** @ingroup rpm */
 typedef struct OMX_PARAM_SUSPENSIONTYPE {
-    OMX_U32 nSize;                  
-    OMX_VERSIONTYPE nVersion;       
-    OMX_SUSPENSIONTYPE eType;             
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_SUSPENSIONTYPE eType;
 } OMX_PARAM_SUSPENSIONTYPE ;
 
 typedef struct OMX_CONFIG_BOOLEANTYPE {
     OMX_U32 nSize;
     OMX_VERSIONTYPE nVersion;
-    OMX_BOOL bEnabled;    
+    OMX_BOOL bEnabled;
 } OMX_CONFIG_BOOLEANTYPE;
 
 /* Parameter specifying the content uri to use. */
 /** @ingroup cp */
-typedef struct OMX_PARAM_CONTENTURITYPE
-{
+typedef struct OMX_PARAM_CONTENTURITYPE {
     OMX_U32 nSize;                      /**< size of the structure in bytes, including
                                              actual URI name */
     OMX_VERSIONTYPE nVersion;           /**< OMX specification version information */
@@ -143,8 +142,7 @@
 
 /* Parameter specifying the pipe to use. */
 /** @ingroup cp */
-typedef struct OMX_PARAM_CONTENTPIPETYPE
-{
+typedef struct OMX_PARAM_CONTENTPIPETYPE {
     OMX_U32 nSize;              /**< size of the structure in bytes */
     OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
     OMX_HANDLETYPE hPipe;       /**< The pipe handle*/
@@ -154,9 +152,9 @@
 typedef struct OMX_RESOURCECONCEALMENTTYPE {
     OMX_U32 nSize;             /**< size of the structure in bytes */
     OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
-    OMX_BOOL bResourceConcealmentForbidden; /**< disallow the use of resource concealment 
-                                            methods (like degrading algorithm quality to 
-                                            lower resource consumption or functional bypass) 
+    OMX_BOOL bResourceConcealmentForbidden; /**< disallow the use of resource concealment
+                                            methods (like degrading algorithm quality to
+                                            lower resource consumption or functional bypass)
                                             on a component as a resolution to resource conflicts. */
 } OMX_RESOURCECONCEALMENTTYPE;
 
@@ -171,7 +169,7 @@
     OMX_MetadataCharsetJavaConformantUTF8,
     OMX_MetadataCharsetUTF7,
     OMX_MetadataCharsetImapUTF7,
-    OMX_MetadataCharsetUTF16LE, 
+    OMX_MetadataCharsetUTF16LE,
     OMX_MetadataCharsetUTF16BE,
     OMX_MetadataCharsetGB12345,
     OMX_MetadataCharsetHZGB2312,
@@ -197,36 +195,33 @@
     OMX_MetadataCharsetISO2022JP1,
     OMX_MetadataCharsetISOEUCJP,
     OMX_MetadataCharsetSMS7Bit,
-    OMX_MetadataCharsetKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_MetadataCharsetKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
     OMX_MetadataCharsetVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_MetadataCharsetTypeMax= 0x7FFFFFFF
+    OMX_MetadataCharsetTypeMax = 0x7FFFFFFF
 } OMX_METADATACHARSETTYPE;
 
 /** @ingroup metadata */
-typedef enum OMX_METADATASCOPETYPE
-{
+typedef enum OMX_METADATASCOPETYPE {
     OMX_MetadataScopeAllLevels,
     OMX_MetadataScopeTopLevel,
     OMX_MetadataScopePortLevel,
     OMX_MetadataScopeNodeLevel,
-    OMX_MetadataScopeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_MetadataScopeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
     OMX_MetadataScopeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_MetadataScopeTypeMax = 0x7fffffff
 } OMX_METADATASCOPETYPE;
 
 /** @ingroup metadata */
-typedef enum OMX_METADATASEARCHMODETYPE
-{
+typedef enum OMX_METADATASEARCHMODETYPE {
     OMX_MetadataSearchValueSizeByIndex,
     OMX_MetadataSearchItemByIndex,
     OMX_MetadataSearchNextItemByKey,
-    OMX_MetadataSearchKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_MetadataSearchKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
     OMX_MetadataSearchVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_MetadataSearchTypeMax = 0x7fffffff
 } OMX_METADATASEARCHMODETYPE;
 /** @ingroup metadata */
-typedef struct OMX_CONFIG_METADATAITEMCOUNTTYPE
-{
+typedef struct OMX_CONFIG_METADATAITEMCOUNTTYPE {
     OMX_U32 nSize;
     OMX_VERSIONTYPE nVersion;
     OMX_METADATASCOPETYPE eScopeMode;
@@ -235,13 +230,12 @@
 } OMX_CONFIG_METADATAITEMCOUNTTYPE;
 
 /** @ingroup metadata */
-typedef struct OMX_CONFIG_METADATAITEMTYPE
-{
+typedef struct OMX_CONFIG_METADATAITEMTYPE {
     OMX_U32 nSize;
     OMX_VERSIONTYPE nVersion;
     OMX_METADATASCOPETYPE eScopeMode;
     OMX_U32 nScopeSpecifier;
-    OMX_U32 nMetadataItemIndex;  
+    OMX_U32 nMetadataItemIndex;
     OMX_METADATASEARCHMODETYPE eSearchMode;
     OMX_METADATACHARSETTYPE eKeyCharset;
     OMX_U8 nKeySizeUsed;
@@ -254,8 +248,7 @@
 } OMX_CONFIG_METADATAITEMTYPE;
 
 /* @ingroup metadata */
-typedef struct OMX_CONFIG_CONTAINERNODECOUNTTYPE
-{
+typedef struct OMX_CONFIG_CONTAINERNODECOUNTTYPE {
     OMX_U32 nSize;
     OMX_VERSIONTYPE nVersion;
     OMX_BOOL bAllKeys;
@@ -264,36 +257,34 @@
 } OMX_CONFIG_CONTAINERNODECOUNTTYPE;
 
 /** @ingroup metadata */
-typedef struct OMX_CONFIG_CONTAINERNODEIDTYPE
-{
+typedef struct OMX_CONFIG_CONTAINERNODEIDTYPE {
     OMX_U32 nSize;
     OMX_VERSIONTYPE nVersion;
     OMX_BOOL bAllKeys;
     OMX_U32 nParentNodeID;
-    OMX_U32 nNodeIndex; 
-    OMX_U32 nNodeID; 
+    OMX_U32 nNodeIndex;
+    OMX_U32 nNodeID;
     OMX_STRING cNodeName;
     OMX_BOOL bIsLeafType;
 } OMX_CONFIG_CONTAINERNODEIDTYPE;
 
 /** @ingroup metadata */
-typedef struct OMX_PARAM_METADATAFILTERTYPE 
-{ 
-    OMX_U32 nSize; 
-    OMX_VERSIONTYPE nVersion; 
-    OMX_BOOL bAllKeys;	/* if true then this structure refers to all keys and 
+typedef struct OMX_PARAM_METADATAFILTERTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_BOOL bAllKeys;  /* if true then this structure refers to all keys and
                          * the three key fields below are ignored */
     OMX_METADATACHARSETTYPE eKeyCharset;
-    OMX_U32 nKeySizeUsed; 
-    OMX_U8   nKey [128]; 
+    OMX_U32 nKeySizeUsed;
+    OMX_U8   nKey [128];
     OMX_U32 nLanguageCountrySizeUsed;
     OMX_U8 nLanguageCountry[128];
-    OMX_BOOL bEnabled;	/* if true then key is part of filter (e.g. 
+    OMX_BOOL bEnabled;  /* if true then key is part of filter (e.g.
                          * retained for query later). If false then
                          * key is not part of filter */
-} OMX_PARAM_METADATAFILTERTYPE; 
+} OMX_PARAM_METADATAFILTERTYPE;
 
-/** The OMX_HANDLETYPE structure defines the component handle.  The component 
+/** The OMX_HANDLETYPE structure defines the component handle.  The component
  *  handle is used to access all of the component's public methods and also
  *  contains pointers to the component's private data area.  The component
  *  handle is initialized by the OMX core (with help from the component)
@@ -301,144 +292,143 @@
  *  successfully loaded, the application can safely access any of the
  *  component's public functions (although some may return an error because
  *  the state is inappropriate for the access).
- * 
+ *
  *  @ingroup comp
  */
-typedef struct OMX_COMPONENTTYPE
-{
+typedef struct OMX_COMPONENTTYPE {
     /** The size of this structure, in bytes.  It is the responsibility
         of the allocator of this structure to fill in this value.  Since
         this structure is allocated by the GetHandle function, this
         function will fill in this value. */
     OMX_U32 nSize;
 
-    /** nVersion is the version of the OMX specification that the structure 
-        is built against.  It is the responsibility of the creator of this 
-        structure to initialize this value and every user of this structure 
-        should verify that it knows how to use the exact version of 
+    /** nVersion is the version of the OMX specification that the structure
+        is built against.  It is the responsibility of the creator of this
+        structure to initialize this value and every user of this structure
+        should verify that it knows how to use the exact version of
         this structure found herein. */
     OMX_VERSIONTYPE nVersion;
 
-    /** pComponentPrivate is a pointer to the component private data area.  
-        This member is allocated and initialized by the component when the 
-        component is first loaded.  The application should not access this 
+    /** pComponentPrivate is a pointer to the component private data area.
+        This member is allocated and initialized by the component when the
+        component is first loaded.  The application should not access this
         data area. */
     OMX_PTR pComponentPrivate;
 
-    /** pApplicationPrivate is a pointer that is a parameter to the 
-        OMX_GetHandle method, and contains an application private value 
-        provided by the IL client.  This application private data is 
+    /** pApplicationPrivate is a pointer that is a parameter to the
+        OMX_GetHandle method, and contains an application private value
+        provided by the IL client.  This application private data is
         returned to the IL Client by OMX in all callbacks */
     OMX_PTR pApplicationPrivate;
 
-    /** refer to OMX_GetComponentVersion in OMX_core.h or the OMX IL 
+    /** refer to OMX_GetComponentVersion in OMX_core.h or the OMX IL
         specification for details on the GetComponentVersion method.
      */
     OMX_ERRORTYPE (*GetComponentVersion)(
-            OMX_IN  OMX_HANDLETYPE hComponent,
-            OMX_OUT OMX_STRING pComponentName,
-            OMX_OUT OMX_VERSIONTYPE* pComponentVersion,
-            OMX_OUT OMX_VERSIONTYPE* pSpecVersion,
-            OMX_OUT OMX_UUIDTYPE* pComponentUUID);
+        OMX_IN  OMX_HANDLETYPE hComponent,
+        OMX_OUT OMX_STRING pComponentName,
+        OMX_OUT OMX_VERSIONTYPE* pComponentVersion,
+        OMX_OUT OMX_VERSIONTYPE* pSpecVersion,
+        OMX_OUT OMX_UUIDTYPE* pComponentUUID);
 
-    /** refer to OMX_SendCommand in OMX_core.h or the OMX IL 
+    /** refer to OMX_SendCommand in OMX_core.h or the OMX IL
         specification for details on the SendCommand method.
      */
     OMX_ERRORTYPE (*SendCommand)(
-            OMX_IN  OMX_HANDLETYPE hComponent,
-            OMX_IN  OMX_COMMANDTYPE Cmd,
-            OMX_IN  OMX_U32 nParam1,
-            OMX_IN  OMX_PTR pCmdData);
+        OMX_IN  OMX_HANDLETYPE hComponent,
+        OMX_IN  OMX_COMMANDTYPE Cmd,
+        OMX_IN  OMX_U32 nParam1,
+        OMX_IN  OMX_PTR pCmdData);
 
-    /** refer to OMX_GetParameter in OMX_core.h or the OMX IL 
+    /** refer to OMX_GetParameter in OMX_core.h or the OMX IL
         specification for details on the GetParameter method.
      */
     OMX_ERRORTYPE (*GetParameter)(
-            OMX_IN  OMX_HANDLETYPE hComponent, 
-            OMX_IN  OMX_INDEXTYPE nParamIndex,  
-            OMX_INOUT OMX_PTR pComponentParameterStructure);
+        OMX_IN  OMX_HANDLETYPE hComponent,
+        OMX_IN  OMX_INDEXTYPE nParamIndex,
+        OMX_INOUT OMX_PTR pComponentParameterStructure);
 
 
-    /** refer to OMX_SetParameter in OMX_core.h or the OMX IL 
+    /** refer to OMX_SetParameter in OMX_core.h or the OMX IL
         specification for details on the SetParameter method.
      */
     OMX_ERRORTYPE (*SetParameter)(
-            OMX_IN  OMX_HANDLETYPE hComponent, 
-            OMX_IN  OMX_INDEXTYPE nIndex,
-            OMX_IN  OMX_PTR pComponentParameterStructure);
+        OMX_IN  OMX_HANDLETYPE hComponent,
+        OMX_IN  OMX_INDEXTYPE nIndex,
+        OMX_IN  OMX_PTR pComponentParameterStructure);
 
 
-    /** refer to OMX_GetConfig in OMX_core.h or the OMX IL 
+    /** refer to OMX_GetConfig in OMX_core.h or the OMX IL
         specification for details on the GetConfig method.
      */
     OMX_ERRORTYPE (*GetConfig)(
-            OMX_IN  OMX_HANDLETYPE hComponent,
-            OMX_IN  OMX_INDEXTYPE nIndex, 
-            OMX_INOUT OMX_PTR pComponentConfigStructure);
+        OMX_IN  OMX_HANDLETYPE hComponent,
+        OMX_IN  OMX_INDEXTYPE nIndex,
+        OMX_INOUT OMX_PTR pComponentConfigStructure);
 
 
-    /** refer to OMX_SetConfig in OMX_core.h or the OMX IL 
+    /** refer to OMX_SetConfig in OMX_core.h or the OMX IL
         specification for details on the SetConfig method.
      */
     OMX_ERRORTYPE (*SetConfig)(
-            OMX_IN  OMX_HANDLETYPE hComponent,
-            OMX_IN  OMX_INDEXTYPE nIndex, 
-            OMX_IN  OMX_PTR pComponentConfigStructure);
+        OMX_IN  OMX_HANDLETYPE hComponent,
+        OMX_IN  OMX_INDEXTYPE nIndex,
+        OMX_IN  OMX_PTR pComponentConfigStructure);
 
 
-    /** refer to OMX_GetExtensionIndex in OMX_core.h or the OMX IL 
+    /** refer to OMX_GetExtensionIndex in OMX_core.h or the OMX IL
         specification for details on the GetExtensionIndex method.
      */
     OMX_ERRORTYPE (*GetExtensionIndex)(
-            OMX_IN  OMX_HANDLETYPE hComponent,
-            OMX_IN  OMX_STRING cParameterName,
-            OMX_OUT OMX_INDEXTYPE* pIndexType);
+        OMX_IN  OMX_HANDLETYPE hComponent,
+        OMX_IN  OMX_STRING cParameterName,
+        OMX_OUT OMX_INDEXTYPE* pIndexType);
 
 
-    /** refer to OMX_GetState in OMX_core.h or the OMX IL 
+    /** refer to OMX_GetState in OMX_core.h or the OMX IL
         specification for details on the GetState method.
      */
     OMX_ERRORTYPE (*GetState)(
-            OMX_IN  OMX_HANDLETYPE hComponent,
-            OMX_OUT OMX_STATETYPE* pState);
+        OMX_IN  OMX_HANDLETYPE hComponent,
+        OMX_OUT OMX_STATETYPE* pState);
+
 
-    
     /** The ComponentTunnelRequest method will interact with another OMX
         component to determine if tunneling is possible and to setup the
-        tunneling.  The return codes for this method can be used to 
+        tunneling.  The return codes for this method can be used to
         determine if tunneling is not possible, or if tunneling is not
-        supported.  
-        
+        supported.
+
         Base profile components (i.e. non-interop) do not support this
-        method and should return OMX_ErrorNotImplemented 
+        method and should return OMX_ErrorNotImplemented
 
-        The interop profile component MUST support tunneling to another 
-        interop profile component with a compatible port parameters.  
+        The interop profile component MUST support tunneling to another
+        interop profile component with a compatible port parameters.
         A component may also support proprietary communication.
-        
-        If proprietary communication is supported the negotiation of 
-        proprietary communication is done outside of OMX in a vendor 
-        specific way. It is only required that the proper result be 
-        returned and the details of how the setup is done is left 
-        to the component implementation.  
-    
+
+        If proprietary communication is supported the negotiation of
+        proprietary communication is done outside of OMX in a vendor
+        specific way. It is only required that the proper result be
+        returned and the details of how the setup is done is left
+        to the component implementation.
+
         When this method is invoked when nPort in an output port, the
         component will:
-        1.  Populate the pTunnelSetup structure with the output port's 
+        1.  Populate the pTunnelSetup structure with the output port's
             requirements and constraints for the tunnel.
 
         When this method is invoked when nPort in an input port, the
         component will:
-        1.  Query the necessary parameters from the output port to 
+        1.  Query the necessary parameters from the output port to
             determine if the ports are compatible for tunneling
         2.  If the ports are compatible, the component should store
             the tunnel step provided by the output port
         3.  Determine which port (either input or output) is the buffer
             supplier, and call OMX_SetParameter on the output port to
             indicate this selection.
-        
+
         The component will return from this call within 5 msec.
-    
+
         @param [in] hComp
             Handle of the component to be accessed.  This is the component
             handle returned by the call to the OMX_GetHandle method.
@@ -446,7 +436,7 @@
             nPort is used to select the port on the component to be used
             for tunneling.
         @param [in] hTunneledComp
-            Handle of the component to tunnel with.  This is the component 
+            Handle of the component to tunnel with.  This is the component
             handle returned by the call to the OMX_GetHandle method.  When
             this parameter is 0x0 the component should setup the port for
             communication with the application / IL Client.
@@ -469,55 +459,55 @@
         OMX_IN  OMX_U32 nPort,
         OMX_IN  OMX_HANDLETYPE hTunneledComp,
         OMX_IN  OMX_U32 nTunneledPort,
-        OMX_INOUT  OMX_TUNNELSETUPTYPE* pTunnelSetup); 
+        OMX_INOUT  OMX_TUNNELSETUPTYPE* pTunnelSetup);
 
-    /** refer to OMX_UseBuffer in OMX_core.h or the OMX IL 
+    /** refer to OMX_UseBuffer in OMX_core.h or the OMX IL
         specification for details on the UseBuffer method.
         @ingroup buf
      */
     OMX_ERRORTYPE (*UseBuffer)(
-            OMX_IN OMX_HANDLETYPE hComponent,
-            OMX_INOUT OMX_BUFFERHEADERTYPE** ppBufferHdr,
-            OMX_IN OMX_U32 nPortIndex,
-            OMX_IN OMX_PTR pAppPrivate,
-            OMX_IN OMX_U32 nSizeBytes,
-            OMX_IN OMX_U8* pBuffer);
+        OMX_IN OMX_HANDLETYPE hComponent,
+        OMX_INOUT OMX_BUFFERHEADERTYPE** ppBufferHdr,
+        OMX_IN OMX_U32 nPortIndex,
+        OMX_IN OMX_PTR pAppPrivate,
+        OMX_IN OMX_U32 nSizeBytes,
+        OMX_IN OMX_U8* pBuffer);
 
-    /** refer to OMX_AllocateBuffer in OMX_core.h or the OMX IL 
+    /** refer to OMX_AllocateBuffer in OMX_core.h or the OMX IL
         specification for details on the AllocateBuffer method.
         @ingroup buf
      */
     OMX_ERRORTYPE (*AllocateBuffer)(
-            OMX_IN OMX_HANDLETYPE hComponent,
-            OMX_INOUT OMX_BUFFERHEADERTYPE** ppBuffer,
-            OMX_IN OMX_U32 nPortIndex,
-            OMX_IN OMX_PTR pAppPrivate,
-            OMX_IN OMX_U32 nSizeBytes);
+        OMX_IN OMX_HANDLETYPE hComponent,
+        OMX_INOUT OMX_BUFFERHEADERTYPE** ppBuffer,
+        OMX_IN OMX_U32 nPortIndex,
+        OMX_IN OMX_PTR pAppPrivate,
+        OMX_IN OMX_U32 nSizeBytes);
 
-    /** refer to OMX_FreeBuffer in OMX_core.h or the OMX IL 
+    /** refer to OMX_FreeBuffer in OMX_core.h or the OMX IL
         specification for details on the FreeBuffer method.
         @ingroup buf
      */
     OMX_ERRORTYPE (*FreeBuffer)(
-            OMX_IN  OMX_HANDLETYPE hComponent,
-            OMX_IN  OMX_U32 nPortIndex,
-            OMX_IN  OMX_BUFFERHEADERTYPE* pBuffer);
+        OMX_IN  OMX_HANDLETYPE hComponent,
+        OMX_IN  OMX_U32 nPortIndex,
+        OMX_IN  OMX_BUFFERHEADERTYPE* pBuffer);
 
-    /** refer to OMX_EmptyThisBuffer in OMX_core.h or the OMX IL 
+    /** refer to OMX_EmptyThisBuffer in OMX_core.h or the OMX IL
         specification for details on the EmptyThisBuffer method.
         @ingroup buf
      */
     OMX_ERRORTYPE (*EmptyThisBuffer)(
-            OMX_IN  OMX_HANDLETYPE hComponent,
-            OMX_IN  OMX_BUFFERHEADERTYPE* pBuffer);
+        OMX_IN  OMX_HANDLETYPE hComponent,
+        OMX_IN  OMX_BUFFERHEADERTYPE* pBuffer);
 
-    /** refer to OMX_FillThisBuffer in OMX_core.h or the OMX IL 
+    /** refer to OMX_FillThisBuffer in OMX_core.h or the OMX IL
         specification for details on the FillThisBuffer method.
         @ingroup buf
      */
     OMX_ERRORTYPE (*FillThisBuffer)(
-            OMX_IN  OMX_HANDLETYPE hComponent,
-            OMX_IN  OMX_BUFFERHEADERTYPE* pBuffer);
+        OMX_IN  OMX_HANDLETYPE hComponent,
+        OMX_IN  OMX_BUFFERHEADERTYPE* pBuffer);
 
     /** The SetCallbacks method is used by the core to specify the callback
         structure from the application to the component.  This is a blocking
@@ -526,10 +516,10 @@
             Handle of the component to be accessed.  This is the component
             handle returned by the call to the GetHandle function.
         @param [in] pCallbacks
-            pointer to an OMX_CALLBACKTYPE structure used to provide the 
+            pointer to an OMX_CALLBACKTYPE structure used to provide the
             callback information to the component
         @param [in] pAppData
-            pointer to an application defined value.  It is anticipated that 
+            pointer to an application defined value.  It is anticipated that
             the application will pass a pointer to a data structure or a "this
             pointer" in this area to allow the callback (in the application)
             to determine the context of the call
@@ -538,9 +528,9 @@
             OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
      */
     OMX_ERRORTYPE (*SetCallbacks)(
-            OMX_IN  OMX_HANDLETYPE hComponent,
-            OMX_IN  OMX_CALLBACKTYPE* pCallbacks, 
-            OMX_IN  OMX_PTR pAppData);
+        OMX_IN  OMX_HANDLETYPE hComponent,
+        OMX_IN  OMX_CALLBACKTYPE* pCallbacks,
+        OMX_IN  OMX_PTR pAppData);
 
     /** ComponentDeInit method is used to deinitialize the component
         providing a means to free any resources allocated at component
@@ -554,20 +544,20 @@
             OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
      */
     OMX_ERRORTYPE (*ComponentDeInit)(
-            OMX_IN  OMX_HANDLETYPE hComponent);
+        OMX_IN  OMX_HANDLETYPE hComponent);
 
     /** @ingroup buf */
     OMX_ERRORTYPE (*UseEGLImage)(
-            OMX_IN OMX_HANDLETYPE hComponent,
-            OMX_INOUT OMX_BUFFERHEADERTYPE** ppBufferHdr,
-            OMX_IN OMX_U32 nPortIndex,
-            OMX_IN OMX_PTR pAppPrivate,
-            OMX_IN void* eglImage);
+        OMX_IN OMX_HANDLETYPE hComponent,
+        OMX_INOUT OMX_BUFFERHEADERTYPE** ppBufferHdr,
+        OMX_IN OMX_U32 nPortIndex,
+        OMX_IN OMX_PTR pAppPrivate,
+        OMX_IN void* eglImage);
 
     OMX_ERRORTYPE (*ComponentRoleEnum)(
         OMX_IN OMX_HANDLETYPE hComponent,
-		OMX_OUT OMX_U8 *cRole,
-		OMX_IN OMX_U32 nIndex);
+        OMX_OUT OMX_U8 *cRole,
+        OMX_IN OMX_U32 nIndex);
 
 } OMX_COMPONENTTYPE;
 
Index: gst-omx-1.22.0/omx/openmax/OMX_ComponentExt.h
===================================================================
--- gst-omx-1.22.0.orig/omx/openmax/OMX_ComponentExt.h	2023-03-02 08:48:43.000000000 +0000
+++ gst-omx-1.22.0/omx/openmax/OMX_ComponentExt.h	2023-03-02 08:58:22.000000000 +0000
@@ -1,61 +1,61 @@
-/*
- * Copyright (c) 2010 The Khronos Group Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject
- * to the following conditions:
- * The above copyright notice and this permission notice shall be included
- * in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
- * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
- * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-/** OMX_ComponentExt.h - OpenMax IL version 1.1.2
- * The OMX_ComponentExt header file contains extensions to the definitions used
- * by both the application and the component to access common items.
- */
-
-#ifndef OMX_ComponentExt_h
-#define OMX_ComponentExt_h
-
-#ifdef __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-
-/* Each OMX header must include all required header files to allow the
- * header to compile without errors.  The includes below are required
- * for this header file to compile successfully 
- */
-#include <OMX_Types.h>
-
-
-/** Set/query the commit mode */
-typedef struct OMX_CONFIG_COMMITMODETYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_BOOL bDeferred;
-} OMX_CONFIG_COMMITMODETYPE;
-
-/** Explicit commit */
-typedef struct OMX_CONFIG_COMMITTYPE {
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-} OMX_CONFIG_COMMITTYPE;
-
-
-#ifdef __cplusplus
-}
-#endif /* __cplusplus */
-
-#endif /* OMX_ComponentExt_h */
+/*
+ * Copyright (c) 2016 The Khronos Group Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions:
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+/** OMX_ComponentExt.h - OpenMax IL version 1.1.2
+ * The OMX_ComponentExt header file contains extensions to the definitions used
+ * by both the application and the component to access common items.
+ */
+
+#ifndef OMX_ComponentExt_h
+#define OMX_ComponentExt_h
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/* Each OMX header must include all required header files to allow the
+ * header to compile without errors.  The includes below are required
+ * for this header file to compile successfully 
+ */
+#include <OMX_Types.h>
+
+
+/** Set/query the commit mode */
+typedef struct OMX_CONFIG_COMMITMODETYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_BOOL bDeferred;
+} OMX_CONFIG_COMMITMODETYPE;
+
+/** Explicit commit */
+typedef struct OMX_CONFIG_COMMITTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+} OMX_CONFIG_COMMITTYPE;
+
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* OMX_ComponentExt_h */
Index: gst-omx-1.22.0/omx/openmax/OMX_ContentPipe.h
===================================================================
--- gst-omx-1.22.0.orig/omx/openmax/OMX_ContentPipe.h	2023-03-02 08:48:43.000000000 +0000
+++ gst-omx-1.22.0/omx/openmax/OMX_ContentPipe.h	2023-03-02 08:58:22.000000000 +0000
@@ -1,23 +1,23 @@
 /*
- * Copyright (c) 2008 The Khronos Group Inc. 
- * 
+ * Copyright (c) 2008 The Khronos Group Inc.
+ *
  * Permission is hereby granted, free of charge, to any person obtaining
  * a copy of this software and associated documentation files (the
  * "Software"), to deal in the Software without restriction, including
  * without limitation the rights to use, copy, modify, merge, publish,
  * distribute, sublicense, and/or sell copies of the Software, and to
  * permit persons to whom the Software is furnished to do so, subject
- * to the following conditions: 
+ * to the following conditions:
  * The above copyright notice and this permission notice shall be included
- * in all copies or substantial portions of the Software. 
- * 
+ * in all copies or substantial portions of the Software.
+ *
  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
  * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
  * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  *
  */
 
@@ -64,83 +64,81 @@
 
 /** Map types from OMX standard types only here so interface is as generic as possible. */
 typedef OMX_U32    CPresult;
-typedef char *     CPstring;  
+typedef char *     CPstring;
 typedef void *     CPhandle;
 typedef OMX_U32    CPuint;
-typedef OMX_S32    CPint;  
-typedef char       CPbyte;  
+typedef OMX_S32    CPint;
+typedef char       CPbyte;
 typedef OMX_BOOL   CPbool;
 
-/** enumeration of origin types used in the CP_PIPETYPE's Seek function 
+/** enumeration of origin types used in the CP_PIPETYPE's Seek function
  * @ingroup cp
  */
 typedef enum CP_ORIGINTYPE {
-    CP_OriginBegin,      
-    CP_OriginCur,      
-    CP_OriginEnd,      
-    CP_OriginKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    CP_OriginBegin,
+    CP_OriginCur,
+    CP_OriginEnd,
+    CP_OriginKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
     CP_OriginVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     CP_OriginMax = 0X7FFFFFFF
 } CP_ORIGINTYPE;
 
-/** enumeration of contact access types used in the CP_PIPETYPE's Open function 
+/** enumeration of contact access types used in the CP_PIPETYPE's Open function
  * @ingroup cp
  */
 typedef enum CP_ACCESSTYPE {
-    CP_AccessRead,      
-    CP_AccessWrite,  
-    CP_AccessReadWrite ,  
-    CP_AccessKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    CP_AccessRead,
+    CP_AccessWrite,
+    CP_AccessReadWrite ,
+    CP_AccessKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
     CP_AccessVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     CP_AccessMax = 0X7FFFFFFF
 } CP_ACCESSTYPE;
 
-/** enumeration of results returned by the CP_PIPETYPE's CheckAvailableBytes function 
+/** enumeration of results returned by the CP_PIPETYPE's CheckAvailableBytes function
  * @ingroup cp
  */
-typedef enum CP_CHECKBYTESRESULTTYPE
-{
-    CP_CheckBytesOk,                    /**< There are at least the request number 
+typedef enum CP_CHECKBYTESRESULTTYPE {
+    CP_CheckBytesOk,                    /**< There are at least the request number
                                               of bytes available */
-    CP_CheckBytesNotReady,              /**< The pipe is still retrieving bytes 
-                                              and presently lacks sufficient bytes. 
-                                              Client will be called when they are 
+    CP_CheckBytesNotReady,              /**< The pipe is still retrieving bytes
+                                              and presently lacks sufficient bytes.
+                                              Client will be called when they are
                                               sufficient bytes are available. */
-    CP_CheckBytesInsufficientBytes  ,     /**< The pipe has retrieved all bytes 
-                                              but those available are less than those 
+    CP_CheckBytesInsufficientBytes  ,     /**< The pipe has retrieved all bytes
+                                              but those available are less than those
                                               requested */
     CP_CheckBytesAtEndOfStream,         /**< The pipe has reached the end of stream
                                               and no more bytes are available. */
     CP_CheckBytesOutOfBuffers,          /**< All read/write buffers are currently in use. */
-    CP_CheckBytesKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    CP_CheckBytesKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
     CP_CheckBytesVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     CP_CheckBytesMax = 0X7FFFFFFF
 } CP_CHECKBYTESRESULTTYPE;
 
-/** enumeration of content pipe events sent to the client callback. 
+/** enumeration of content pipe events sent to the client callback.
  * @ingroup cp
  */
-typedef enum CP_EVENTTYPE{
-    CP_BytesAvailable,      	    /** bytes requested in a CheckAvailableBytes call are now available*/
-    CP_Overflow,  		           /** enumeration of content pipe events sent to the client callback*/
-    CP_PipeDisconnected  ,  		    /** enumeration of content pipe events sent to the client callback*/
-    CP_EventKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+typedef enum CP_EVENTTYPE {
+    CP_BytesAvailable,              /** bytes requested in a CheckAvailableBytes call are now available*/
+    CP_Overflow,                   /** enumeration of content pipe events sent to the client callback*/
+    CP_PipeDisconnected  ,              /** enumeration of content pipe events sent to the client callback*/
+    CP_EventKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
     CP_EventVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     CP_EventMax = 0X7FFFFFFF
 } CP_EVENTTYPE;
 
-/** content pipe definition 
+/** content pipe definition
  * @ingroup cp
  */
-typedef struct CP_PIPETYPE
-{
-    /** Open a content stream for reading or writing. */ 
+typedef struct CP_PIPETYPE {
+    /** Open a content stream for reading or writing. */
     CPresult (*Open)( CPhandle* hContent, CPstring szURI, CP_ACCESSTYPE eAccess );
 
-    /** Close a content stream. */ 
+    /** Close a content stream. */
     CPresult (*Close)( CPhandle hContent );
 
-    /** Create a content source and open it for writing. */ 
+    /** Create a content source and open it for writing. */
     CPresult (*Create)( CPhandle *hContent, CPstring szURI );
 
     /** Check the that specified number of bytes are available for reading or writing (depending on access type).*/
@@ -154,19 +152,19 @@
 
     /** Retrieve data of the specified size from the content stream (advance content pointer by size of data).
        Note: pipe client provides pointer. This function is appropriate for small high frequency reads. */
-    CPresult (*Read)( CPhandle hContent, CPbyte *pData, CPuint nSize); 
+    CPresult (*Read)( CPhandle hContent, CPbyte *pData, CPuint nSize);
 
-    /** Retrieve a buffer allocated by the pipe that contains the requested number of bytes. 
+    /** Retrieve a buffer allocated by the pipe that contains the requested number of bytes.
        Buffer contains the next block of bytes, as specified by nSize, of the content. nSize also
-       returns the size of the block actually read. Content pointer advances the by the returned size. 
-       Note: pipe provides pointer. This function is appropriate for large reads. The client must call 
-       ReleaseReadBuffer when done with buffer. 
+       returns the size of the block actually read. Content pointer advances the by the returned size.
+       Note: pipe provides pointer. This function is appropriate for large reads. The client must call
+       ReleaseReadBuffer when done with buffer.
 
        In some cases the requested block may not reside in contiguous memory within the
-       pipe implementation. For instance if the pipe leverages a circular buffer then the requested 
-       block may straddle the boundary of the circular buffer. By default a pipe implementation 
+       pipe implementation. For instance if the pipe leverages a circular buffer then the requested
+       block may straddle the boundary of the circular buffer. By default a pipe implementation
        performs a copy in this case to provide the block to the pipe client in one contiguous buffer.
-       If, however, the client sets bForbidCopy, then the pipe returns only those bytes preceding the memory 
+       If, however, the client sets bForbidCopy, then the pipe returns only those bytes preceding the memory
        boundary. Here the client may retrieve the data in segments over successive calls. */
     CPresult (*ReadBuffer)( CPhandle hContent, CPbyte **ppBuffer, CPuint *nSize, CPbool bForbidCopy);
 
@@ -175,14 +173,14 @@
 
     /** Write data of the specified size to the content (advance content pointer by size of data).
        Note: pipe client provides pointer. This function is appropriate for small high frequency writes. */
-    CPresult (*Write)( CPhandle hContent, CPbyte *data, CPuint nSize); 
+    CPresult (*Write)( CPhandle hContent, CPbyte *data, CPuint nSize);
 
-    /** Retrieve a buffer allocated by the pipe used to write data to the content. 
+    /** Retrieve a buffer allocated by the pipe used to write data to the content.
        Client will fill buffer with output data. Note: pipe provides pointer. This function is appropriate
        for large writes. The client must call WriteBuffer when done it has filled the buffer with data.*/
     CPresult (*GetWriteBuffer)( CPhandle hContent, CPbyte **ppBuffer, CPuint nSize);
 
-    /** Deliver a buffer obtained via GetWriteBuffer to the pipe. Pipe will write the 
+    /** Deliver a buffer obtained via GetWriteBuffer to the pipe. Pipe will write the
        the contents of the buffer to content and advance content pointer by the size of the buffer */
     CPresult (*WriteBuffer)( CPhandle hContent, CPbyte *pBuffer, CPuint nFilledSize);
 
Index: gst-omx-1.22.0/omx/openmax/OMX_Core.h
===================================================================
--- gst-omx-1.22.0.orig/omx/openmax/OMX_Core.h	2023-03-02 08:48:43.000000000 +0000
+++ gst-omx-1.22.0/omx/openmax/OMX_Core.h	2023-03-02 08:58:22.000000000 +0000
@@ -1,23 +1,23 @@
 /*
- * Copyright (c) 2008 The Khronos Group Inc. 
- * 
+ * Copyright (c) 2008 The Khronos Group Inc.
+ *
  * Permission is hereby granted, free of charge, to any person obtaining
  * a copy of this software and associated documentation files (the
  * "Software"), to deal in the Software without restriction, including
  * without limitation the rights to use, copy, modify, merge, publish,
  * distribute, sublicense, and/or sell copies of the Software, and to
  * permit persons to whom the Software is furnished to do so, subject
- * to the following conditions: 
+ * to the following conditions:
  * The above copyright notice and this permission notice shall be included
- * in all copies or substantial portions of the Software. 
- * 
+ * in all copies or substantial portions of the Software.
+ *
  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
  * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
  * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  *
  */
 
@@ -36,14 +36,14 @@
 
 /* Each OMX header shall include all required header files to allow the
  *  header to compile without errors.  The includes below are required
- *  for this header file to compile successfully 
+ *  for this header file to compile successfully
  */
 
 #include <OMX_Index.h>
 
 
 /** The OMX_COMMANDTYPE enumeration is used to specify the action in the
- *  OMX_SendCommand macro.  
+ *  OMX_SendCommand macro.
  *  @ingroup core
  */
 typedef enum OMX_COMMANDTYPE
@@ -53,7 +53,7 @@
     OMX_CommandPortDisable, /**< Disable a port on a component. */
     OMX_CommandPortEnable,  /**< Enable a port on a component. */
     OMX_CommandMarkBuffer,  /**< Mark a component/buffer for observation */
-    OMX_CommandKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_CommandKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
     OMX_CommandVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_CommandMax = 0X7FFFFFFF
 } OMX_COMMANDTYPE;
@@ -76,28 +76,27 @@
  *  specified configuration and will transition to the idle state if the
  *  allocation is successful.  If the component cannot successfully
  *  transition to the idle state for any reason, the state of the component
- *  shall be fully rolled back to the Loaded state (e.g. all allocated 
+ *  shall be fully rolled back to the Loaded state (e.g. all allocated
  *  resources shall be released).  When the component receives the command
  *  to go to the Executing state, it shall begin processing buffers by
  *  sending all input buffers it holds to the application.  While
  *  the component is in the Idle state, the application may also send the
  *  Pause command.  If the component receives the pause command while in the
- *  Idle state, the component shall send all input buffers it holds to the 
+ *  Idle state, the component shall send all input buffers it holds to the
  *  application, but shall not begin processing buffers.  This will allow the
  *  application to prefill buffers.
- * 
+ *
  *  @ingroup comp
  */
 
-typedef enum OMX_STATETYPE
-{
-    OMX_StateInvalid,      /**< component has detected that it's internal data 
+typedef enum OMX_STATETYPE {
+    OMX_StateInvalid,      /**< component has detected that it's internal data
                                 structures are corrupted to the point that
                                 it cannot determine it's state properly */
     OMX_StateLoaded,      /**< component has been loaded but has not completed
                                 initialization.  The OMX_SetParameter macro
-                                and the OMX_GetParameter macro are the only 
-                                valid macros allowed to be sent to the 
+                                and the OMX_GetParameter macro are the only
+                                valid macros allowed to be sent to the
                                 component in this state. */
     OMX_StateIdle,        /**< component initialization has been completed
                                 successfully and the component is ready to
@@ -105,17 +104,17 @@
     OMX_StateExecuting,   /**< component has accepted the start command and
                                 is processing data (if data is available) */
     OMX_StatePause,       /**< component has received pause command */
-    OMX_StateWaitForResources, /**< component is waiting for resources, either after 
+    OMX_StateWaitForResources, /**< component is waiting for resources, either after
                                 preemption or before it gets the resources requested.
                                 See specification for complete details. */
-    OMX_StateKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_StateKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
     OMX_StateVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_StateMax = 0X7FFFFFFF
 } OMX_STATETYPE;
 
-/** The OMX_ERRORTYPE enumeration defines the standard OMX Errors.  These 
- *  errors should cover most of the common failure cases.  However, 
- *  vendors are free to add additional error messages of their own as 
+/** The OMX_ERRORTYPE enumeration defines the standard OMX Errors.  These
+ *  errors should cover most of the common failure cases.  However,
+ *  vendors are free to add additional error messages of their own as
  *  long as they follow these rules:
  *  1.  Vendor error messages shall be in the range of 0x90000000 to
  *      0x9000FFFF.
@@ -123,147 +122,145 @@
  *      with the component.  No error messages are allowed that are
  *      not defined.
  */
-typedef enum OMX_ERRORTYPE
-{
-  OMX_ErrorNone = 0,
+typedef enum OMX_ERRORTYPE {
+    OMX_ErrorNone = 0,
 
-  /** There were insufficient resources to perform the requested operation */
-  OMX_ErrorInsufficientResources = (OMX_S32) 0x80001000,
+    /** There were insufficient resources to perform the requested operation */
+    OMX_ErrorInsufficientResources = (OMX_S32) 0x80001000,
 
-  /** There was an error, but the cause of the error could not be determined */
-  OMX_ErrorUndefined = (OMX_S32) 0x80001001,
+    /** There was an error, but the cause of the error could not be determined */
+    OMX_ErrorUndefined = (OMX_S32) 0x80001001,
 
-  /** The component name string was not valid */
-  OMX_ErrorInvalidComponentName = (OMX_S32) 0x80001002,
+    /** The component name string was not valid */
+    OMX_ErrorInvalidComponentName = (OMX_S32) 0x80001002,
 
-  /** No component with the specified name string was found */
-  OMX_ErrorComponentNotFound = (OMX_S32) 0x80001003,
+    /** No component with the specified name string was found */
+    OMX_ErrorComponentNotFound = (OMX_S32) 0x80001003,
 
-  /** The component specified did not have a "OMX_ComponentInit" or
-      "OMX_ComponentDeInit entry point */
-  OMX_ErrorInvalidComponent = (OMX_S32) 0x80001004,
+    /** The component specified did not have a "OMX_ComponentInit" or
+        "OMX_ComponentDeInit entry point */
+    OMX_ErrorInvalidComponent = (OMX_S32) 0x80001004,
 
-  /** One or more parameters were not valid */
-  OMX_ErrorBadParameter = (OMX_S32) 0x80001005,
+    /** One or more parameters were not valid */
+    OMX_ErrorBadParameter = (OMX_S32) 0x80001005,
 
-  /** The requested function is not implemented */
-  OMX_ErrorNotImplemented = (OMX_S32) 0x80001006,
+    /** The requested function is not implemented */
+    OMX_ErrorNotImplemented = (OMX_S32) 0x80001006,
 
-  /** The buffer was emptied before the next buffer was ready */
-  OMX_ErrorUnderflow = (OMX_S32) 0x80001007,
+    /** The buffer was emptied before the next buffer was ready */
+    OMX_ErrorUnderflow = (OMX_S32) 0x80001007,
 
-  /** The buffer was not available when it was needed */
-  OMX_ErrorOverflow = (OMX_S32) 0x80001008,
+    /** The buffer was not available when it was needed */
+    OMX_ErrorOverflow = (OMX_S32) 0x80001008,
 
-  /** The hardware failed to respond as expected */
-  OMX_ErrorHardware = (OMX_S32) 0x80001009,
+    /** The hardware failed to respond as expected */
+    OMX_ErrorHardware = (OMX_S32) 0x80001009,
 
-  /** The component is in the state OMX_StateInvalid */
-  OMX_ErrorInvalidState = (OMX_S32) 0x8000100A,
+    /** The component is in the state OMX_StateInvalid */
+    OMX_ErrorInvalidState = (OMX_S32) 0x8000100A,
 
-  /** Stream is found to be corrupt */
-  OMX_ErrorStreamCorrupt = (OMX_S32) 0x8000100B,
+    /** Stream is found to be corrupt */
+    OMX_ErrorStreamCorrupt = (OMX_S32) 0x8000100B,
 
-  /** Ports being connected are not compatible */
-  OMX_ErrorPortsNotCompatible = (OMX_S32) 0x8000100C,
+    /** Ports being connected are not compatible */
+    OMX_ErrorPortsNotCompatible = (OMX_S32) 0x8000100C,
 
-  /** Resources allocated to an idle component have been
-      lost resulting in the component returning to the loaded state */
-  OMX_ErrorResourcesLost = (OMX_S32) 0x8000100D,
+    /** Resources allocated to an idle component have been
+        lost resulting in the component returning to the loaded state */
+    OMX_ErrorResourcesLost = (OMX_S32) 0x8000100D,
 
-  /** No more indicies can be enumerated */
-  OMX_ErrorNoMore = (OMX_S32) 0x8000100E,
+    /** No more indicies can be enumerated */
+    OMX_ErrorNoMore = (OMX_S32) 0x8000100E,
 
-  /** The component detected a version mismatch */
-  OMX_ErrorVersionMismatch = (OMX_S32) 0x8000100F,
+    /** The component detected a version mismatch */
+    OMX_ErrorVersionMismatch = (OMX_S32) 0x8000100F,
 
-  /** The component is not ready to return data at this time */
-  OMX_ErrorNotReady = (OMX_S32) 0x80001010,
+    /** The component is not ready to return data at this time */
+    OMX_ErrorNotReady = (OMX_S32) 0x80001010,
 
-  /** There was a timeout that occurred */
-  OMX_ErrorTimeout = (OMX_S32) 0x80001011,
+    /** There was a timeout that occurred */
+    OMX_ErrorTimeout = (OMX_S32) 0x80001011,
 
-  /** This error occurs when trying to transition into the state you are already in */
-  OMX_ErrorSameState = (OMX_S32) 0x80001012,
+    /** This error occurs when trying to transition into the state you are already in */
+    OMX_ErrorSameState = (OMX_S32) 0x80001012,
 
-  /** Resources allocated to an executing or paused component have been 
-      preempted, causing the component to return to the idle state */
-  OMX_ErrorResourcesPreempted = (OMX_S32) 0x80001013, 
+    /** Resources allocated to an executing or paused component have been
+        preempted, causing the component to return to the idle state */
+    OMX_ErrorResourcesPreempted = (OMX_S32) 0x80001013,
 
-  /** A non-supplier port sends this error to the IL client (via the EventHandler callback) 
-      during the allocation of buffers (on a transition from the LOADED to the IDLE state or
-      on a port restart) when it deems that it has waited an unusually long time for the supplier 
-      to send it an allocated buffer via a UseBuffer call. */
-  OMX_ErrorPortUnresponsiveDuringAllocation = (OMX_S32) 0x80001014,
+    /** A non-supplier port sends this error to the IL client (via the EventHandler callback)
+        during the allocation of buffers (on a transition from the LOADED to the IDLE state or
+        on a port restart) when it deems that it has waited an unusually long time for the supplier
+        to send it an allocated buffer via a UseBuffer call. */
+    OMX_ErrorPortUnresponsiveDuringAllocation = (OMX_S32) 0x80001014,
 
-  /** A non-supplier port sends this error to the IL client (via the EventHandler callback) 
-      during the deallocation of buffers (on a transition from the IDLE to LOADED state or 
-      on a port stop) when it deems that it has waited an unusually long time for the supplier 
-      to request the deallocation of a buffer header via a FreeBuffer call. */
-  OMX_ErrorPortUnresponsiveDuringDeallocation = (OMX_S32) 0x80001015,
+    /** A non-supplier port sends this error to the IL client (via the EventHandler callback)
+        during the deallocation of buffers (on a transition from the IDLE to LOADED state or
+        on a port stop) when it deems that it has waited an unusually long time for the supplier
+        to request the deallocation of a buffer header via a FreeBuffer call. */
+    OMX_ErrorPortUnresponsiveDuringDeallocation = (OMX_S32) 0x80001015,
 
-  /** A supplier port sends this error to the IL client (via the EventHandler callback) 
-      during the stopping of a port (either on a transition from the IDLE to LOADED 
-      state or a port stop) when it deems that it has waited an unusually long time for 
-      the non-supplier to return a buffer via an EmptyThisBuffer or FillThisBuffer call. */
-  OMX_ErrorPortUnresponsiveDuringStop = (OMX_S32) 0x80001016,
+    /** A supplier port sends this error to the IL client (via the EventHandler callback)
+        during the stopping of a port (either on a transition from the IDLE to LOADED
+        state or a port stop) when it deems that it has waited an unusually long time for
+        the non-supplier to return a buffer via an EmptyThisBuffer or FillThisBuffer call. */
+    OMX_ErrorPortUnresponsiveDuringStop = (OMX_S32) 0x80001016,
 
-  /** Attempting a state transtion that is not allowed */
-  OMX_ErrorIncorrectStateTransition = (OMX_S32) 0x80001017,
+    /** Attempting a state transtion that is not allowed */
+    OMX_ErrorIncorrectStateTransition = (OMX_S32) 0x80001017,
 
-  /* Attempting a command that is not allowed during the present state. */
-  OMX_ErrorIncorrectStateOperation = (OMX_S32) 0x80001018, 
+    /* Attempting a command that is not allowed during the present state. */
+    OMX_ErrorIncorrectStateOperation = (OMX_S32) 0x80001018,
 
-  /** The values encapsulated in the parameter or config structure are not supported. */
-  OMX_ErrorUnsupportedSetting = (OMX_S32) 0x80001019,
+    /** The values encapsulated in the parameter or config structure are not supported. */
+    OMX_ErrorUnsupportedSetting = (OMX_S32) 0x80001019,
 
-  /** The parameter or config indicated by the given index is not supported. */
-  OMX_ErrorUnsupportedIndex = (OMX_S32) 0x8000101A,
+    /** The parameter or config indicated by the given index is not supported. */
+    OMX_ErrorUnsupportedIndex = (OMX_S32) 0x8000101A,
 
-  /** The port index supplied is incorrect. */
-  OMX_ErrorBadPortIndex = (OMX_S32) 0x8000101B,
+    /** The port index supplied is incorrect. */
+    OMX_ErrorBadPortIndex = (OMX_S32) 0x8000101B,
 
-  /** The port has lost one or more of its buffers and it thus unpopulated. */
-  OMX_ErrorPortUnpopulated = (OMX_S32) 0x8000101C,
+    /** The port has lost one or more of its buffers and it thus unpopulated. */
+    OMX_ErrorPortUnpopulated = (OMX_S32) 0x8000101C,
 
-  /** Component suspended due to temporary loss of resources */
-  OMX_ErrorComponentSuspended = (OMX_S32) 0x8000101D,
+    /** Component suspended due to temporary loss of resources */
+    OMX_ErrorComponentSuspended = (OMX_S32) 0x8000101D,
 
-  /** Component suspended due to an inability to acquire dynamic resources */
-  OMX_ErrorDynamicResourcesUnavailable = (OMX_S32) 0x8000101E,
+    /** Component suspended due to an inability to acquire dynamic resources */
+    OMX_ErrorDynamicResourcesUnavailable = (OMX_S32) 0x8000101E,
 
-  /** When the macroblock error reporting is enabled the component returns new error 
-  for every frame that has errors */
-  OMX_ErrorMbErrorsInFrame = (OMX_S32) 0x8000101F,
+    /** When the macroblock error reporting is enabled the component returns new error
+    for every frame that has errors */
+    OMX_ErrorMbErrorsInFrame = (OMX_S32) 0x8000101F,
 
-  /** A component reports this error when it cannot parse or determine the format of an input stream. */
-  OMX_ErrorFormatNotDetected = (OMX_S32) 0x80001020, 
+    /** A component reports this error when it cannot parse or determine the format of an input stream. */
+    OMX_ErrorFormatNotDetected = (OMX_S32) 0x80001020,
 
-  /** The content open operation failed. */
-  OMX_ErrorContentPipeOpenFailed = (OMX_S32) 0x80001021,
+    /** The content open operation failed. */
+    OMX_ErrorContentPipeOpenFailed = (OMX_S32) 0x80001021,
 
-  /** The content creation operation failed. */
-  OMX_ErrorContentPipeCreationFailed = (OMX_S32) 0x80001022,
+    /** The content creation operation failed. */
+    OMX_ErrorContentPipeCreationFailed = (OMX_S32) 0x80001022,
 
-  /** Separate table information is being used */
-  OMX_ErrorSeperateTablesUsed = (OMX_S32) 0x80001023,
+    /** Separate table information is being used */
+    OMX_ErrorSeperateTablesUsed = (OMX_S32) 0x80001023,
 
-  /** Tunneling is unsupported by the component*/
-  OMX_ErrorTunnelingUnsupported = (OMX_S32) 0x80001024,
+    /** Tunneling is unsupported by the component*/
+    OMX_ErrorTunnelingUnsupported = (OMX_S32) 0x80001024,
 
-  OMX_ErrorKhronosExtensions = (OMX_S32)0x8F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
-  OMX_ErrorVendorStartUnused = (OMX_S32)0x90000000, /**< Reserved region for introducing Vendor Extensions */
-  OMX_ErrorMax = 0x7FFFFFFF
+    OMX_ErrorKhronosExtensions = (OMX_S32)0x8F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_ErrorVendorStartUnused = (OMX_S32)0x90000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_ErrorMax = 0x7FFFFFFF
 } OMX_ERRORTYPE;
 
 /** @ingroup core */
 typedef OMX_ERRORTYPE (* OMX_COMPONENTINITTYPE)(OMX_IN  OMX_HANDLETYPE hComponent);
 
 /** @ingroup core */
-typedef struct OMX_COMPONENTREGISTERTYPE
-{
-  const char          * pName;       /* Component name, 128 byte limit (including '\0') applies */
-  OMX_COMPONENTINITTYPE pInitialize; /* Component instance initialization function */
+typedef struct OMX_COMPONENTREGISTERTYPE {
+    const char          * pName;       /* Component name, 128 byte limit (including '\0') applies */
+    OMX_COMPONENTINITTYPE pInitialize; /* Component instance initialization function */
 } OMX_COMPONENTREGISTERTYPE;
 
 /** @ingroup core */
@@ -271,10 +268,10 @@
 
 /** @ingroup rpm */
 typedef struct OMX_PRIORITYMGMTTYPE {
- OMX_U32 nSize;             /**< size of the structure in bytes */
- OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
- OMX_U32 nGroupPriority;            /**< Priority of the component group */
- OMX_U32 nGroupID;                  /**< ID of the component group */
+    OMX_U32 nSize;             /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
+    OMX_U32 nGroupPriority;            /**< Priority of the component group */
+    OMX_U32 nGroupID;                  /**< ID of the component group */
 } OMX_PRIORITYMGMTTYPE;
 
 /* Component name and Role names are limited to 128 characters including the terminating '\0'. */
@@ -287,69 +284,69 @@
     OMX_U8 cRole[OMX_MAX_STRINGNAME_SIZE];  /**< name of standard component which defines component role */
 } OMX_PARAM_COMPONENTROLETYPE;
 
-/** End of Stream Buffer Flag: 
+/** End of Stream Buffer Flag:
   *
-  * A component sets EOS when it has no more data to emit on a particular 
-  * output port. Thus an output port shall set EOS on the last buffer it 
-  * emits. A component's determination of when an output port should 
+  * A component sets EOS when it has no more data to emit on a particular
+  * output port. Thus an output port shall set EOS on the last buffer it
+  * emits. A component's determination of when an output port should
   * cease sending data is implemenation specific.
   * @ingroup buf
   */
 
-#define OMX_BUFFERFLAG_EOS 0x00000001 
+#define OMX_BUFFERFLAG_EOS 0x00000001
 
-/** Start Time Buffer Flag: 
+/** Start Time Buffer Flag:
  *
  * The source of a stream (e.g. a demux component) sets the STARTTIME
  * flag on the buffer that contains the starting timestamp for the
  * stream. The starting timestamp corresponds to the first data that
  * should be displayed at startup or after a seek.
  * The first timestamp of the stream is not necessarily the start time.
- * For instance, in the case of a seek to a particular video frame, 
- * the target frame may be an interframe. Thus the first buffer of 
+ * For instance, in the case of a seek to a particular video frame,
+ * the target frame may be an interframe. Thus the first buffer of
  * the stream will be the intra-frame preceding the target frame and
  * the starttime will occur with the target frame (with any other
  * required frames required to reconstruct the target intervening).
  *
- * The STARTTIME flag is directly associated with the buffer's 
- * timestamp ' thus its association to buffer data and its 
+ * The STARTTIME flag is directly associated with the buffer's
+ * timestamp ' thus its association to buffer data and its
  * propagation is identical to the timestamp's.
  *
- * When a Sync Component client receives a buffer with the 
- * STARTTIME flag it shall perform a SetConfig on its sync port 
+ * When a Sync Component client receives a buffer with the
+ * STARTTIME flag it shall perform a SetConfig on its sync port
  * using OMX_ConfigTimeClientStartTime and passing the buffer's
  * timestamp.
- * 
+ *
  * @ingroup buf
  */
 
 #define OMX_BUFFERFLAG_STARTTIME 0x00000002
 
- 
 
-/** Decode Only Buffer Flag: 
+
+/** Decode Only Buffer Flag:
  *
  * The source of a stream (e.g. a demux component) sets the DECODEONLY
  * flag on any buffer that should shall be decoded but should not be
- * displayed. This flag is used, for instance, when a source seeks to 
- * a target interframe that requires the decode of frames preceding the 
- * target to facilitate the target's reconstruction. In this case the 
- * source would emit the frames preceding the target downstream 
+ * displayed. This flag is used, for instance, when a source seeks to
+ * a target interframe that requires the decode of frames preceding the
+ * target to facilitate the target's reconstruction. In this case the
+ * source would emit the frames preceding the target downstream
  * but mark them as decode only.
  *
- * The DECODEONLY is associated with buffer data and propagated in a 
+ * The DECODEONLY is associated with buffer data and propagated in a
  * manner identical to the buffer timestamp.
  *
- * A component that renders data should ignore all buffers with 
+ * A component that renders data should ignore all buffers with
  * the DECODEONLY flag set.
- * 
+ *
  * @ingroup buf
  */
 
 #define OMX_BUFFERFLAG_DECODEONLY 0x00000004
 
 
-/* Data Corrupt Flag: This flag is set when the IL client believes the data in the associated buffer is corrupt 
+/* Data Corrupt Flag: This flag is set when the IL client believes the data in the associated buffer is corrupt
  * @ingroup buf
  */
 
@@ -357,29 +354,29 @@
 
 /* End of Frame: The buffer contains exactly one end of frame and no data
  *  occurs after the end of frame. This flag is an optional hint. The absence
- *  of this flag does not imply the absence of an end of frame within the buffer. 
+ *  of this flag does not imply the absence of an end of frame within the buffer.
  * @ingroup buf
 */
 #define OMX_BUFFERFLAG_ENDOFFRAME 0x00000010
 
-/* Sync Frame Flag: This flag is set when the buffer content contains a coded sync frame ' 
- *  a frame that has no dependency on any other frame information 
+/* Sync Frame Flag: This flag is set when the buffer content contains a coded sync frame '
+ *  a frame that has no dependency on any other frame information
  *  @ingroup buf
  */
 #define OMX_BUFFERFLAG_SYNCFRAME 0x00000020
 
 /* Extra data present flag: there is extra data appended to the data stream
- * residing in the buffer 
- * @ingroup buf  
+ * residing in the buffer
+ * @ingroup buf
  */
 #define OMX_BUFFERFLAG_EXTRADATA 0x00000040
 
-/** Codec Config Buffer Flag: 
+/** Codec Config Buffer Flag:
 * OMX_BUFFERFLAG_CODECCONFIG is an optional flag that is set by an
 * output port when all bytes in the buffer form part or all of a set of
 * codec specific configuration data.  Examples include SPS/PPS nal units
 * for OMX_VIDEO_CodingAVC or AudioSpecificConfig data for
-* OMX_AUDIO_CodingAAC.  Any component that for a given stream sets 
+* OMX_AUDIO_CodingAAC.  Any component that for a given stream sets
 * OMX_BUFFERFLAG_CODECCONFIG shall not mix codec configuration bytes
 * with frame data in the same buffer, and shall send all buffers
 * containing codec configuration bytes before any buffers containing
@@ -395,72 +392,70 @@
 
 
 /** @ingroup buf */
-typedef struct OMX_BUFFERHEADERTYPE
-{
+typedef struct OMX_BUFFERHEADERTYPE {
     OMX_U32 nSize;              /**< size of the structure in bytes */
     OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
-    OMX_U8* pBuffer;            /**< Pointer to actual block of memory 
+    OMX_U8* pBuffer;            /**< Pointer to actual block of memory
                                      that is acting as the buffer */
     OMX_U32 nAllocLen;          /**< size of the buffer allocated, in bytes */
-    OMX_U32 nFilledLen;         /**< number of bytes currently in the 
+    OMX_U32 nFilledLen;         /**< number of bytes currently in the
                                      buffer */
     OMX_U32 nOffset;            /**< start offset of valid data in bytes from
                                      the start of the buffer */
     OMX_PTR pAppPrivate;        /**< pointer to any data the application
                                      wants to associate with this buffer */
     OMX_PTR pPlatformPrivate;   /**< pointer to any data the platform
-                                     wants to associate with this buffer */ 
+                                     wants to associate with this buffer */
     OMX_PTR pInputPortPrivate;  /**< pointer to any data the input port
                                      wants to associate with this buffer */
     OMX_PTR pOutputPortPrivate; /**< pointer to any data the output port
                                      wants to associate with this buffer */
-    OMX_HANDLETYPE hMarkTargetComponent; /**< The component that will generate a 
+    OMX_HANDLETYPE hMarkTargetComponent; /**< The component that will generate a
                                               mark event upon processing this buffer. */
-    OMX_PTR pMarkData;          /**< Application specific data associated with 
-                                     the mark sent on a mark event to disambiguate 
+    OMX_PTR pMarkData;          /**< Application specific data associated with
+                                     the mark sent on a mark event to disambiguate
                                      this mark from others. */
     OMX_U32 nTickCount;         /**< Optional entry that the component and
                                      application can update with a tick count
                                      when they access the component.  This
                                      value should be in microseconds.  Since
                                      this is a value relative to an arbitrary
-                                     starting point, this value cannot be used 
+                                     starting point, this value cannot be used
                                      to determine absolute time.  This is an
                                      optional entry and not all components
                                      will update it.*/
- OMX_TICKS nTimeStamp;          /**< Timestamp corresponding to the sample 
-                                     starting at the first logical sample 
-                                     boundary in the buffer. Timestamps of 
+    OMX_TICKS nTimeStamp;          /**< Timestamp corresponding to the sample
+                                     starting at the first logical sample
+                                     boundary in the buffer. Timestamps of
                                      successive samples within the buffer may
-                                     be inferred by adding the duration of the 
+                                     be inferred by adding the duration of the
                                      of the preceding buffer to the timestamp
                                      of the preceding buffer.*/
-  OMX_U32     nFlags;           /**< buffer specific flags */
-  OMX_U32 nOutputPortIndex;     /**< The index of the output port (if any) using 
+    OMX_U32     nFlags;           /**< buffer specific flags */
+    OMX_U32 nOutputPortIndex;     /**< The index of the output port (if any) using
                                      this buffer */
-  OMX_U32 nInputPortIndex;      /**< The index of the input port (if any) using
+    OMX_U32 nInputPortIndex;      /**< The index of the input port (if any) using
                                      this buffer */
 } OMX_BUFFERHEADERTYPE;
 
-/** The OMX_EXTRADATATYPE enumeration is used to define the 
+/** The OMX_EXTRADATATYPE enumeration is used to define the
  * possible extra data payload types.
  * NB: this enum is binary backwards compatible with the previous
  * OMX_EXTRADATA_QUANT define.  This should be replaced with
  * OMX_ExtraDataQuantization.
  */
-typedef enum OMX_EXTRADATATYPE
-{
-   OMX_ExtraDataNone = 0,                       /**< Indicates that no more extra data sections follow */        
-   OMX_ExtraDataQuantization,                   /**< The data payload contains quantization data */
-   OMX_ExtraDataKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
-   OMX_ExtraDataVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-   OMX_ExtraDataMax = 0x7FFFFFFF
+typedef enum OMX_EXTRADATATYPE {
+    OMX_ExtraDataNone = 0,                       /**< Indicates that no more extra data sections follow */
+    OMX_ExtraDataQuantization,                   /**< The data payload contains quantization data */
+    OMX_ExtraDataKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_ExtraDataVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_ExtraDataMax = 0x7FFFFFFF
 } OMX_EXTRADATATYPE;
 
 
 typedef struct OMX_OTHER_EXTRADATATYPE  {
     OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;               
+    OMX_VERSIONTYPE nVersion;
     OMX_U32 nPortIndex;
     OMX_EXTRADATATYPE eType;       /* Extra Data type */
     OMX_U32 nDataSize;   /* Size of the supporting data to follow */
@@ -473,34 +468,32 @@
     OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
     OMX_U32 nPorts;             /**< The number of ports for this component */
     OMX_U32 nStartPortNumber;   /** first port number for this type of port */
-} OMX_PORT_PARAM_TYPE; 
+} OMX_PORT_PARAM_TYPE;
 
 /** @ingroup comp */
-typedef enum OMX_EVENTTYPE
-{
+typedef enum OMX_EVENTTYPE {
     OMX_EventCmdComplete,         /**< component has sucessfully completed a command */
     OMX_EventError,               /**< component has detected an error condition */
     OMX_EventMark,                /**< component has detected a buffer mark */
     OMX_EventPortSettingsChanged, /**< component is reported a port settings change */
-    OMX_EventBufferFlag,          /**< component has detected an EOS */ 
+    OMX_EventBufferFlag,          /**< component has detected an EOS */
     OMX_EventResourcesAcquired,   /**< component has been granted resources and is
                                        automatically starting the state change from
                                        OMX_StateWaitForResources to OMX_StateIdle. */
-   OMX_EventComponentResumed,     /**< Component resumed due to reacquisition of resources */
-   OMX_EventDynamicResourcesAvailable, /**< Component has acquired previously unavailable dynamic resources */
-   OMX_EventPortFormatDetected,      /**< Component has detected a supported format. */
-   OMX_EventKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
-   OMX_EventVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-   OMX_EventMax = 0x7FFFFFFF
+    OMX_EventComponentResumed,     /**< Component resumed due to reacquisition of resources */
+    OMX_EventDynamicResourcesAvailable, /**< Component has acquired previously unavailable dynamic resources */
+    OMX_EventPortFormatDetected,      /**< Component has detected a supported format. */
+    OMX_EventKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_EventVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_EventMax = 0x7FFFFFFF
 } OMX_EVENTTYPE;
 
-typedef struct OMX_CALLBACKTYPE
-{
+typedef struct OMX_CALLBACKTYPE {
     /** The EventHandler method is used to notify the application when an
         event of interest occurs.  Events are defined in the OMX_EVENTTYPE
         enumeration.  Please see that enumeration for details of what will
         be returned for each type of event. Callbacks should not return
-        an error to the component, so if an error occurs, the application 
+        an error to the component, so if an error occurs, the application
         shall handle it internally.  This is a blocking call.
 
         The application should return from this call within 5 msec to avoid
@@ -510,14 +503,14 @@
             handle of the component to access.  This is the component
             handle returned by the call to the GetHandle function.
         @param pAppData
-            pointer to an application defined value that was provided in the 
+            pointer to an application defined value that was provided in the
             pAppData parameter to the OMX_GetHandle method for the component.
-            This application defined value is provided so that the application 
+            This application defined value is provided so that the application
             can have a component specific context when receiving the callback.
         @param eEvent
             Event that the component wants to notify the application about.
         @param nData1
-            nData will be the OMX_ERRORTYPE for an error event and will be 
+            nData will be the OMX_ERRORTYPE for an error event and will be
             an OMX_COMMANDTYPE for a command complete event and OMX_INDEXTYPE for a OMX_PortSettingsChanged event.
          @param nData2
             nData2 will hold further information related to the event. Can be OMX_STATETYPE for
@@ -527,7 +520,7 @@
             Pointer to additional event-specific data (see spec for meaning).
       */
 
-   OMX_ERRORTYPE (*EventHandler)(
+    OMX_ERRORTYPE (*EventHandler)(
         OMX_IN OMX_HANDLETYPE hComponent,
         OMX_IN OMX_PTR pAppData,
         OMX_IN OMX_EVENTTYPE eEvent,
@@ -536,21 +529,21 @@
         OMX_IN OMX_PTR pEventData);
 
     /** The EmptyBufferDone method is used to return emptied buffers from an
-        input port back to the application for reuse.  This is a blocking call 
+        input port back to the application for reuse.  This is a blocking call
         so the application should not attempt to refill the buffers during this
         call, but should queue them and refill them in another thread.  There
         is no error return, so the application shall handle any errors generated
-        internally.  
-        
+        internally.
+
         The application should return from this call within 5 msec.
-        
+
         @param hComponent
             handle of the component to access.  This is the component
             handle returned by the call to the GetHandle function.
         @param pAppData
-            pointer to an application defined value that was provided in the 
+            pointer to an application defined value that was provided in the
             pAppData parameter to the OMX_GetHandle method for the component.
-            This application defined value is provided so that the application 
+            This application defined value is provided so that the application
             can have a component specific context when receiving the callback.
         @param pBuffer
             pointer to an OMX_BUFFERHEADERTYPE structure allocated with UseBuffer
@@ -563,23 +556,23 @@
         OMX_IN OMX_BUFFERHEADERTYPE* pBuffer);
 
     /** The FillBufferDone method is used to return filled buffers from an
-        output port back to the application for emptying and then reuse.  
-        This is a blocking call so the application should not attempt to 
-        empty the buffers during this call, but should queue the buffers 
-        and empty them in another thread.  There is no error return, so 
-        the application shall handle any errors generated internally.  The 
+        output port back to the application for emptying and then reuse.
+        This is a blocking call so the application should not attempt to
+        empty the buffers during this call, but should queue the buffers
+        and empty them in another thread.  There is no error return, so
+        the application shall handle any errors generated internally.  The
         application shall also update the buffer header to indicate the
-        number of bytes placed into the buffer.  
+        number of bytes placed into the buffer.
 
         The application should return from this call within 5 msec.
-        
+
         @param hComponent
             handle of the component to access.  This is the component
             handle returned by the call to the GetHandle function.
         @param pAppData
-            pointer to an application defined value that was provided in the 
+            pointer to an application defined value that was provided in the
             pAppData parameter to the OMX_GetHandle method for the component.
-            This application defined value is provided so that the application 
+            This application defined value is provided so that the application
             can have a component specific context when receiving the callback.
         @param pBuffer
             pointer to an OMX_BUFFERHEADERTYPE structure allocated with UseBuffer
@@ -597,19 +590,18 @@
     preference when tunneling between two ports.
     @ingroup tun buf
 */
-typedef enum OMX_BUFFERSUPPLIERTYPE
-{
+typedef enum OMX_BUFFERSUPPLIERTYPE {
     OMX_BufferSupplyUnspecified = 0x0, /**< port supplying the buffers is unspecified,
                                               or don't care */
     OMX_BufferSupplyInput,             /**< input port supplies the buffers */
     OMX_BufferSupplyOutput,            /**< output port supplies the buffers */
-    OMX_BufferSupplyKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_BufferSupplyKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
     OMX_BufferSupplyVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_BufferSupplyMax = 0x7FFFFFFF
 } OMX_BUFFERSUPPLIERTYPE;
 
 
-/** buffer supplier parameter 
+/** buffer supplier parameter
  * @ingroup tun
  */
 typedef struct OMX_PARAM_BUFFERSUPPLIERTYPE {
@@ -620,61 +612,60 @@
 } OMX_PARAM_BUFFERSUPPLIERTYPE;
 
 
-/**< indicates that buffers received by an input port of a tunnel 
-     may not modify the data in the buffers 
+/**< indicates that buffers received by an input port of a tunnel
+     may not modify the data in the buffers
      @ingroup tun
  */
-#define OMX_PORTTUNNELFLAG_READONLY 0x00000001 
+#define OMX_PORTTUNNELFLAG_READONLY 0x00000001
 
 
 /** The OMX_TUNNELSETUPTYPE structure is used to pass data from an output
     port to an input port as part the two ComponentTunnelRequest calls
-    resulting from a OMX_SetupTunnel call from the IL Client. 
+    resulting from a OMX_SetupTunnel call from the IL Client.
     @ingroup tun
- */   
-typedef struct OMX_TUNNELSETUPTYPE
-{
+ */
+typedef struct OMX_TUNNELSETUPTYPE {
     OMX_U32 nTunnelFlags;             /**< bit flags for tunneling */
     OMX_BUFFERSUPPLIERTYPE eSupplier; /**< supplier preference */
-} OMX_TUNNELSETUPTYPE; 
+} OMX_TUNNELSETUPTYPE;
 
 /* OMX Component headers is included to enable the core to use
-   macros for functions into the component for OMX release 1.0.  
+   macros for functions into the component for OMX release 1.0.
    Developers should not access any structures or data from within
    the component header directly */
 /* TO BE REMOVED - #include <OMX_Component.h> */
 
-/** GetComponentVersion will return information about the component.  
+/** GetComponentVersion will return information about the component.
     This is a blocking call.  This macro will go directly from the
     application to the component (via a core macro).  The
     component will return from this call within 5 msec.
     @param [in] hComponent
         handle of component to execute the command
     @param [out] pComponentName
-        pointer to an empty string of length 128 bytes.  The component 
-        will write its name into this string.  The name will be 
-        terminated by a single zero byte.  The name of a component will 
-        be 127 bytes or less to leave room for the trailing zero byte.  
+        pointer to an empty string of length 128 bytes.  The component
+        will write its name into this string.  The name will be
+        terminated by a single zero byte.  The name of a component will
+        be 127 bytes or less to leave room for the trailing zero byte.
         An example of a valid component name is "OMX.ABC.ChannelMixer\0".
     @param [out] pComponentVersion
-        pointer to an OMX Version structure that the component will fill 
-        in.  The component will fill in a value that indicates the 
-        component version.  NOTE: the component version is NOT the same 
-        as the OMX Specification version (found in all structures).  The 
-        component version is defined by the vendor of the component and 
+        pointer to an OMX Version structure that the component will fill
+        in.  The component will fill in a value that indicates the
+        component version.  NOTE: the component version is NOT the same
+        as the OMX Specification version (found in all structures).  The
+        component version is defined by the vendor of the component and
         its value is entirely up to the component vendor.
     @param [out] pSpecVersion
-        pointer to an OMX Version structure that the component will fill 
-        in.  The SpecVersion is the version of the specification that the 
-        component was built against.  Please note that this value may or 
-        may not match the structure's version.  For example, if the 
-        component was built against the 2.0 specification, but the 
-        application (which creates the structure is built against the 
+        pointer to an OMX Version structure that the component will fill
+        in.  The SpecVersion is the version of the specification that the
+        component was built against.  Please note that this value may or
+        may not match the structure's version.  For example, if the
+        component was built against the 2.0 specification, but the
+        application (which creates the structure is built against the
         1.0 specification the versions would be different.
     @param [out] pComponentUUID
-        pointer to the UUID of the component which will be filled in by 
-        the component.  The UUID is a unique identifier that is set at 
-        RUN time for the component and is unique to each instantion of 
+        pointer to the UUID of the component which will be filled in by
+        the component.  The UUID is a unique identifier that is set at
+        RUN time for the component and is unique to each instantion of
         the component.
     @return OMX_ERRORTYPE
         If the command successfully executes, the return code will be
@@ -697,46 +688,46 @@
 
 /** Send a command to the component.  This call is a non-blocking call.
     The component should check the parameters and then queue the command
-    to the component thread to be executed.  The component thread shall 
-    send the EventHandler() callback at the conclusion of the command. 
+    to the component thread to be executed.  The component thread shall
+    send the EventHandler() callback at the conclusion of the command.
     This macro will go directly from the application to the component (via
     a core macro).  The component will return from this call within 5 msec.
-    
+
     When the command is "OMX_CommandStateSet" the component will queue a
     state transition to the new state idenfied in nParam.
-    
+
     When the command is "OMX_CommandFlush", to flush a port's buffer queues,
-    the command will force the component to return all buffers NOT CURRENTLY 
-    BEING PROCESSED to the application, in the order in which the buffers 
+    the command will force the component to return all buffers NOT CURRENTLY
+    BEING PROCESSED to the application, in the order in which the buffers
     were received.
-    
-    When the command is "OMX_CommandPortDisable" or 
+
+    When the command is "OMX_CommandPortDisable" or
     "OMX_CommandPortEnable", the component's port (given by the value of
-    nParam) will be stopped or restarted. 
-    
+    nParam) will be stopped or restarted.
+
     When the command "OMX_CommandMarkBuffer" is used to mark a buffer, the
     pCmdData will point to a OMX_MARKTYPE structure containing the component
     handle of the component to examine the buffer chain for the mark.  nParam1
     contains the index of the port on which the buffer mark is applied.
 
-    Specification text for more details. 
-    
+    Specification text for more details.
+
     @param [in] hComponent
         handle of component to execute the command
     @param [in] Cmd
         Command for the component to execute
     @param [in] nParam
-        Parameter for the command to be executed.  When Cmd has the value 
-        OMX_CommandStateSet, value is a member of OMX_STATETYPE.  When Cmd has 
-        the value OMX_CommandFlush, value of nParam indicates which port(s) 
-        to flush. -1 is used to flush all ports a single port index will 
+        Parameter for the command to be executed.  When Cmd has the value
+        OMX_CommandStateSet, value is a member of OMX_STATETYPE.  When Cmd has
+        the value OMX_CommandFlush, value of nParam indicates which port(s)
+        to flush. -1 is used to flush all ports a single port index will
         only flush that port.  When Cmd has the value "OMX_CommandPortDisable"
-        or "OMX_CommandPortEnable", the component's port is given by 
+        or "OMX_CommandPortEnable", the component's port is given by
         the value of nParam.  When Cmd has the value "OMX_CommandMarkBuffer"
         the components pot is given by the value of nParam.
     @param [in] pCmdData
         Parameter pointing to the OMX_MARKTYPE structure when Cmd has the value
-        "OMX_CommandMarkBuffer".     
+        "OMX_CommandMarkBuffer".
     @return OMX_ERRORTYPE
         If the command successfully executes, the return code will be
         OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
@@ -754,21 +745,21 @@
          pCmdData)                          /* Macro End */
 
 
-/** The OMX_GetParameter macro will get one of the current parameter 
-    settings from the component.  This macro cannot only be invoked when 
+/** The OMX_GetParameter macro will get one of the current parameter
+    settings from the component.  This macro cannot only be invoked when
     the component is in the OMX_StateInvalid state.  The nParamIndex
     parameter is used to indicate which structure is being requested from
-    the component.  The application shall allocate the correct structure 
-    and shall fill in the structure size and version information before 
+    the component.  The application shall allocate the correct structure
+    and shall fill in the structure size and version information before
     invoking this macro.  When the parameter applies to a port, the
     caller shall fill in the appropriate nPortIndex value indicating the
-    port on which the parameter applies. If the component has not had 
-    any settings changed, then the component should return a set of 
-    valid DEFAULT  parameters for the component.  This is a blocking 
-    call.  
-    
+    port on which the parameter applies. If the component has not had
+    any settings changed, then the component should return a set of
+    valid DEFAULT  parameters for the component.  This is a blocking
+    call.
+
     The component should return from this call within 20 msec.
-    
+
     @param [in] hComponent
         Handle of the component to be accessed.  This is the component
         handle returned by the call to the OMX_GetHandle function.
@@ -776,7 +767,7 @@
         Index of the structure to be filled.  This value is from the
         OMX_INDEXTYPE enumeration.
     @param [in,out] pComponentParameterStructure
-        Pointer to application allocated structure to be filled by the 
+        Pointer to application allocated structure to be filled by the
         component.
     @return OMX_ERRORTYPE
         If the command successfully executes, the return code will be
@@ -797,17 +788,17 @@
     structure to a component.  Each structure shall be sent one at a time,
     in a separate invocation of the macro.  This macro can only be
     invoked when the component is in the OMX_StateLoaded state, or the
-    port is disabled (when the parameter applies to a port). The 
+    port is disabled (when the parameter applies to a port). The
     nParamIndex parameter is used to indicate which structure is being
-    passed to the component.  The application shall allocate the 
-    correct structure and shall fill in the structure size and version 
+    passed to the component.  The application shall allocate the
+    correct structure and shall fill in the structure size and version
     information (as well as the actual data) before invoking this macro.
     The application is free to dispose of this structure after the call
-    as the component is required to copy any data it shall retain.  This 
-    is a blocking call.  
-    
+    as the component is required to copy any data it shall retain.  This
+    is a blocking call.
+
     The component should return from this call within 20 msec.
-    
+
     @param [in] hComponent
         Handle of the component to be accessed.  This is the component
         handle returned by the call to the OMX_GetHandle function.
@@ -832,18 +823,18 @@
         pComponentParameterStructure)    /* Macro End */
 
 
-/** The OMX_GetConfig macro will get one of the configuration structures 
-    from a component.  This macro can be invoked anytime after the 
-    component has been loaded.  The nParamIndex call parameter is used to 
-    indicate which structure is being requested from the component.  The 
-    application shall allocate the correct structure and shall fill in the 
-    structure size and version information before invoking this macro.  
-    If the component has not had this configuration parameter sent before, 
-    then the component should return a set of valid DEFAULT values for the 
-    component.  This is a blocking call.  
-    
+/** The OMX_GetConfig macro will get one of the configuration structures
+    from a component.  This macro can be invoked anytime after the
+    component has been loaded.  The nParamIndex call parameter is used to
+    indicate which structure is being requested from the component.  The
+    application shall allocate the correct structure and shall fill in the
+    structure size and version information before invoking this macro.
+    If the component has not had this configuration parameter sent before,
+    then the component should return a set of valid DEFAULT values for the
+    component.  This is a blocking call.
+
     The component should return from this call within 5 msec.
-    
+
     @param [in] hComponent
         Handle of the component to be accessed.  This is the component
         handle returned by the call to the OMX_GetHandle function.
@@ -851,13 +842,13 @@
         Index of the structure to be filled.  This value is from the
         OMX_INDEXTYPE enumeration.
     @param [in,out] pComponentConfigStructure
-        pointer to application allocated structure to be filled by the 
+        pointer to application allocated structure to be filled by the
         component.
     @return OMX_ERRORTYPE
         If the command successfully executes, the return code will be
         OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
     @ingroup comp
-*/        
+*/
 #define OMX_GetConfig(                                      \
         hComponent,                                         \
         nConfigIndex,                                       \
@@ -868,18 +859,18 @@
         pComponentConfigStructure)       /* Macro End */
 
 
-/** The OMX_SetConfig macro will send one of the configuration 
+/** The OMX_SetConfig macro will send one of the configuration
     structures to a component.  Each structure shall be sent one at a time,
-    each in a separate invocation of the macro.  This macro can be invoked 
-    anytime after the component has been loaded.  The application shall 
-    allocate the correct structure and shall fill in the structure size 
-    and version information (as well as the actual data) before invoking 
-    this macro.  The application is free to dispose of this structure after 
-    the call as the component is required to copy any data it shall retain.  
-    This is a blocking call.  
-    
+    each in a separate invocation of the macro.  This macro can be invoked
+    anytime after the component has been loaded.  The application shall
+    allocate the correct structure and shall fill in the structure size
+    and version information (as well as the actual data) before invoking
+    this macro.  The application is free to dispose of this structure after
+    the call as the component is required to copy any data it shall retain.
+    This is a blocking call.
+
     The component should return from this call within 5 msec.
-    
+
     @param [in] hComponent
         Handle of the component to be accessed.  This is the component
         handle returned by the call to the OMX_GetHandle function.
@@ -904,22 +895,22 @@
         pComponentConfigStructure)       /* Macro End */
 
 
-/** The OMX_GetExtensionIndex macro will invoke a component to translate 
-    a vendor specific configuration or parameter string into an OMX 
-    structure index.  There is no requirement for the vendor to support 
-    this command for the indexes already found in the OMX_INDEXTYPE 
-    enumeration (this is done to save space in small components).  The 
+/** The OMX_GetExtensionIndex macro will invoke a component to translate
+    a vendor specific configuration or parameter string into an OMX
+    structure index.  There is no requirement for the vendor to support
+    this command for the indexes already found in the OMX_INDEXTYPE
+    enumeration (this is done to save space in small components).  The
     component shall support all vendor supplied extension indexes not found
-    in the master OMX_INDEXTYPE enumeration.  This is a blocking call.  
-    
+    in the master OMX_INDEXTYPE enumeration.  This is a blocking call.
+
     The component should return from this call within 5 msec.
-    
+
     @param [in] hComponent
         Handle of the component to be accessed.  This is the component
         handle returned by the call to the GetHandle function.
     @param [in] cParameterName
         OMX_STRING that shall be less than 128 characters long including
-        the trailing null byte.  This is the string that will get 
+        the trailing null byte.  This is the string that will get
         translated by the component into a configuration index.
     @param [out] pIndexType
         a pointer to a OMX_INDEXTYPE to receive the index value.
@@ -938,18 +929,18 @@
         pIndexType)                     /* Macro End */
 
 
-/** The OMX_GetState macro will invoke the component to get the current 
+/** The OMX_GetState macro will invoke the component to get the current
     state of the component and place the state value into the location
-    pointed to by pState.  
-    
+    pointed to by pState.
+
     The component should return from this call within 5 msec.
-    
+
     @param [in] hComponent
         Handle of the component to be accessed.  This is the component
         handle returned by the call to the OMX_GetHandle function.
     @param [out] pState
         pointer to the location to receive the state.  The value returned
-        is one of the OMX_STATETYPE members 
+        is one of the OMX_STATETYPE members
     @return OMX_ERRORTYPE
         If the command successfully executes, the return code will be
         OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
@@ -964,17 +955,17 @@
 
 
 /** The OMX_UseBuffer macro will request that the component use
-    a buffer (and allocate its own buffer header) already allocated 
-    by another component, or by the IL Client. This is a blocking 
+    a buffer (and allocate its own buffer header) already allocated
+    by another component, or by the IL Client. This is a blocking
     call.
-    
+
     The component should return from this call within 20 msec.
-    
+
     @param [in] hComponent
         Handle of the component to be accessed.  This is the component
         handle returned by the call to the OMX_GetHandle function.
     @param [out] ppBuffer
-        pointer to an OMX_BUFFERHEADERTYPE structure used to receive the 
+        pointer to an OMX_BUFFERHEADERTYPE structure used to receive the
         pointer to the buffer header
     @return OMX_ERRORTYPE
         If the command successfully executes, the return code will be
@@ -998,25 +989,25 @@
            pBuffer)
 
 
-/** The OMX_AllocateBuffer macro will request that the component allocate 
-    a new buffer and buffer header.  The component will allocate the 
-    buffer and the buffer header and return a pointer to the buffer 
+/** The OMX_AllocateBuffer macro will request that the component allocate
+    a new buffer and buffer header.  The component will allocate the
+    buffer and the buffer header and return a pointer to the buffer
     header.  This is a blocking call.
-    
+
     The component should return from this call within 5 msec.
-    
+
     @param [in] hComponent
         Handle of the component to be accessed.  This is the component
         handle returned by the call to the OMX_GetHandle function.
     @param [out] ppBuffer
-        pointer to an OMX_BUFFERHEADERTYPE structure used to receive 
+        pointer to an OMX_BUFFERHEADERTYPE structure used to receive
         the pointer to the buffer header
     @param [in] nPortIndex
         nPortIndex is used to select the port on the component the buffer will
         be used with.  The port can be found by using the nPortIndex
         value as an index into the Port Definition array of the component.
     @param [in] pAppPrivate
-        pAppPrivate is used to initialize the pAppPrivate member of the 
+        pAppPrivate is used to initialize the pAppPrivate member of the
         buffer header structure.
     @param [in] nSizeBytes
         size of the buffer to allocate.  Used when bAllocateNew is true.
@@ -1024,7 +1015,7 @@
         If the command successfully executes, the return code will be
         OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
     @ingroup comp buf
- */    
+ */
 #define OMX_AllocateBuffer(                                 \
         hComponent,                                         \
         ppBuffer,                                           \
@@ -1040,13 +1031,13 @@
 
 
 /** The OMX_FreeBuffer macro will release a buffer header from the component
-    which was allocated using either OMX_AllocateBuffer or OMX_UseBuffer. If  
-    the component allocated the buffer (see the OMX_UseBuffer macro) then 
-    the component shall free the buffer and buffer header. This is a 
-    blocking call. 
-    
+    which was allocated using either OMX_AllocateBuffer or OMX_UseBuffer. If
+    the component allocated the buffer (see the OMX_UseBuffer macro) then
+    the component shall free the buffer and buffer header. This is a
+    blocking call.
+
     The component should return from this call within 20 msec.
-    
+
     @param [in] hComponent
         Handle of the component to be accessed.  This is the component
         handle returned by the call to the OMX_GetHandle function.
@@ -1071,17 +1062,17 @@
         pBuffer)                        /* Macro End */
 
 
-/** The OMX_EmptyThisBuffer macro will send a buffer full of data to an 
+/** The OMX_EmptyThisBuffer macro will send a buffer full of data to an
     input port of a component.  The buffer will be emptied by the component
     and returned to the application via the EmptyBufferDone call back.
     This is a non-blocking call in that the component will record the buffer
-    and return immediately and then empty the buffer, later, at the proper 
-    time.  As expected, this macro may be invoked only while the component 
+    and return immediately and then empty the buffer, later, at the proper
+    time.  As expected, this macro may be invoked only while the component
     is in the OMX_StateExecuting.  If nPortIndex does not specify an input
-    port, the component shall return an error.  
-    
+    port, the component shall return an error.
+
     The component should return from this call within 5 msec.
-    
+
     @param [in] hComponent
         Handle of the component to be accessed.  This is the component
         handle returned by the call to the OMX_GetHandle function.
@@ -1101,17 +1092,17 @@
         pBuffer)                        /* Macro End */
 
 
-/** The OMX_FillThisBuffer macro will send an empty buffer to an 
+/** The OMX_FillThisBuffer macro will send an empty buffer to an
     output port of a component.  The buffer will be filled by the component
     and returned to the application via the FillBufferDone call back.
     This is a non-blocking call in that the component will record the buffer
-    and return immediately and then fill the buffer, later, at the proper 
-    time.  As expected, this macro may be invoked only while the component 
+    and return immediately and then fill the buffer, later, at the proper
+    time.  As expected, this macro may be invoked only while the component
     is in the OMX_ExecutingState.  If nPortIndex does not specify an output
-    port, the component shall return an error.  
-    
+    port, the component shall return an error.
+
     The component should return from this call within 5 msec.
-    
+
     @param [in] hComponent
         Handle of the component to be accessed.  This is the component
         handle returned by the call to the OMX_GetHandle function.
@@ -1135,14 +1126,14 @@
 /** The OMX_UseEGLImage macro will request that the component use
     a EGLImage provided by EGL (and allocate its own buffer header)
     This is a blocking call.
-    
+
     The component should return from this call within 20 msec.
-    
+
     @param [in] hComponent
         Handle of the component to be accessed.  This is the component
         handle returned by the call to the OMX_GetHandle function.
     @param [out] ppBuffer
-        pointer to an OMX_BUFFERHEADERTYPE structure used to receive the 
+        pointer to an OMX_BUFFERHEADERTYPE structure used to receive the
         pointer to the buffer header.  Note that the memory location used
         for this buffer is NOT visible to the IL Client.
     @param [in] nPortIndex
@@ -1150,13 +1141,13 @@
         be used with.  The port can be found by using the nPortIndex
         value as an index into the Port Definition array of the component.
     @param [in] pAppPrivate
-        pAppPrivate is used to initialize the pAppPrivate member of the 
+        pAppPrivate is used to initialize the pAppPrivate member of the
         buffer header structure.
     @param [in] eglImage
         eglImage contains the handle of the EGLImage to use as a buffer on the
-        specified port.  The component is expected to validate properties of 
+        specified port.  The component is expected to validate properties of
         the EGLImage against the configuration of the port to ensure the component
-        can use the EGLImage as a buffer.          
+        can use the EGLImage as a buffer.
     @return OMX_ERRORTYPE
         If the command successfully executes, the return code will be
         OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
@@ -1177,8 +1168,8 @@
 
 /** The OMX_Init method is used to initialize the OMX core.  It shall be the
     first call made into OMX and it should only be executed one time without
-    an interviening OMX_Deinit call.  
-    
+    an interviening OMX_Deinit call.
+
     The core should return from this call within 20 msec.
 
     @return OMX_ERRORTYPE
@@ -1189,13 +1180,13 @@
 OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_Init(void);
 
 
-/** The OMX_Deinit method is used to deinitialize the OMX core.  It shall be 
-    the last call made into OMX. In the event that the core determines that 
-    thare are components loaded when this call is made, the core may return 
+/** The OMX_Deinit method is used to deinitialize the OMX core.  It shall be
+    the last call made into OMX. In the event that the core determines that
+    thare are components loaded when this call is made, the core may return
     with an error rather than try to unload the components.
-        
+
     The core should return from this call within 20 msec.
-    
+
     @return OMX_ERRORTYPE
         If the command successfully executes, the return code will be
         OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
@@ -1212,23 +1203,23 @@
     installation of new components, it is only requried to detect newly
     installed components when the first call to enumerate component names
     is made (i.e. when nIndex is 0x0).
-    
+
     The core should return from this call in 20 msec.
-    
+
     @param [out] cComponentName
         pointer to a null terminated string with the component name.  The
         names of the components are strings less than 127 bytes in length
-        plus the trailing null for a maximum size of 128 bytes.  An example 
-        of a valid component name is "OMX.TI.AUDIO.DSP.MIXER\0".  Names are 
-        assigned by the vendor, but shall start with "OMX." and then have 
+        plus the trailing null for a maximum size of 128 bytes.  An example
+        of a valid component name is "OMX.TI.AUDIO.DSP.MIXER\0".  Names are
+        assigned by the vendor, but shall start with "OMX." and then have
         the Vendor designation next.
     @param [in] nNameLength
-        number of characters in the cComponentName string.  With all 
-        component name strings restricted to less than 128 characters 
+        number of characters in the cComponentName string.  With all
+        component name strings restricted to less than 128 characters
         (including the trailing null) it is recomended that the caller
         provide a input string for the cComponentName of 128 characters.
     @param [in] nIndex
-        number containing the enumeration index for the component. 
+        number containing the enumeration index for the component.
         Multiple calls to OMX_ComponentNameEnum with increasing values
         of nIndex will enumerate through the component names in the
         system until OMX_ErrorNoMore is returned.  The value of nIndex
@@ -1236,7 +1227,7 @@
         in the system.
     @return OMX_ERRORTYPE
         If the command successfully executes, the return code will be
-        OMX_ErrorNone.  When the value of nIndex exceeds the number of 
+        OMX_ErrorNone.  When the value of nIndex exceeds the number of
         components in the system minus 1, OMX_ErrorNoMore will be
         returned. Otherwise the appropriate OMX error will be returned.
     @ingroup core
@@ -1249,18 +1240,18 @@
 
 /** The OMX_GetHandle method will locate the component specified by the
     component name given, load that component into memory and then invoke
-    the component's methods to create an instance of the component.  
-    
+    the component's methods to create an instance of the component.
+
     The core should return from this call within 20 msec.
-    
+
     @param [out] pHandle
         pointer to an OMX_HANDLETYPE pointer to be filled in by this method.
     @param [in] cComponentName
         pointer to a null terminated string with the component name.  The
         names of the components are strings less than 127 bytes in length
-        plus the trailing null for a maximum size of 128 bytes.  An example 
-        of a valid component name is "OMX.TI.AUDIO.DSP.MIXER\0".  Names are 
-        assigned by the vendor, but shall start with "OMX." and then have 
+        plus the trailing null for a maximum size of 128 bytes.  An example
+        of a valid component name is "OMX.TI.AUDIO.DSP.MIXER\0".  Names are
+        assigned by the vendor, but shall start with "OMX." and then have
         the Vendor designation next.
     @param [in] pAppData
         pointer to an application defined value that will be returned
@@ -1268,24 +1259,24 @@
         of the callback.
     @param [in] pCallBacks
         pointer to a OMX_CALLBACKTYPE structure that will be passed to the
-        component to initialize it with.  
+        component to initialize it with.
     @return OMX_ERRORTYPE
         If the command successfully executes, the return code will be
         OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
     @ingroup core
  */
 OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_GetHandle(
-    OMX_OUT OMX_HANDLETYPE* pHandle, 
+    OMX_OUT OMX_HANDLETYPE* pHandle,
     OMX_IN  OMX_STRING cComponentName,
     OMX_IN  OMX_PTR pAppData,
     OMX_IN  OMX_CALLBACKTYPE* pCallBacks);
 
 
-/** The OMX_FreeHandle method will free a handle allocated by the OMX_GetHandle 
+/** The OMX_FreeHandle method will free a handle allocated by the OMX_GetHandle
     method.  If the component reference count goes to zero, the component will
-    be unloaded from memory.  
-    
-    The core should return from this call within 20 msec when the component is 
+    be unloaded from memory.
+
+    The core should return from this call within 20 msec when the component is
     in the OMX_StateLoaded state.
 
     @param [in] hComponent
@@ -1304,34 +1295,34 @@
 /** The OMX_SetupTunnel method will handle the necessary calls to the components
     to setup the specified tunnel the two components.  NOTE: This is
     an actual method (not a #define macro).  This method will make calls into
-    the component ComponentTunnelRequest method to do the actual tunnel 
-    connection.  
+    the component ComponentTunnelRequest method to do the actual tunnel
+    connection.
 
-    The ComponentTunnelRequest method on both components will be called. 
-    This method shall not be called unless the component is in the 
+    The ComponentTunnelRequest method on both components will be called.
+    This method shall not be called unless the component is in the
     OMX_StateLoaded state except when the ports used for the tunnel are
     disabled. In this case, the component may be in the OMX_StateExecuting,
-    OMX_StatePause, or OMX_StateIdle states. 
+    OMX_StatePause, or OMX_StateIdle states.
 
     The core should return from this call within 20 msec.
-    
+
     @param [in] hOutput
         Handle of the component to be accessed.  Also this is the handle
         of the component whose port, specified in the nPortOutput parameter
         will be used the source for the tunnel. This is the component handle
-        returned by the call to the OMX_GetHandle function.  There is a 
+        returned by the call to the OMX_GetHandle function.  There is a
         requirement that hOutput be the source for the data when
         tunelling (i.e. nPortOutput is an output port).  If 0x0, the component
         specified in hInput will have it's port specified in nPortInput
         setup for communication with the application / IL client.
     @param [in] nPortOutput
         nPortOutput is used to select the source port on component to be
-        used in the tunnel. 
+        used in the tunnel.
     @param [in] hInput
         This is the component to setup the tunnel with. This is the handle
         of the component whose port, specified in the nPortInput parameter
         will be used the destination for the tunnel. This is the component handle
-        returned by the call to the OMX_GetHandle function.  There is a 
+        returned by the call to the OMX_GetHandle function.  There is a
         requirement that hInput be the destination for the data when
         tunelling (i.e. nPortInut is an input port).   If 0x0, the component
         specified in hOutput will have it's port specified in nPortPOutput
@@ -1342,9 +1333,9 @@
     @return OMX_ERRORTYPE
         If the command successfully executes, the return code will be
         OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
-        When OMX_ErrorNotImplemented is returned, one or both components is 
+        When OMX_ErrorNotImplemented is returned, one or both components is
         a non-interop component and does not support tunneling.
-        
+
         On failure, the ports of both components are setup for communication
         with the application / IL Client.
     @ingroup core tun
@@ -1354,50 +1345,50 @@
     OMX_IN  OMX_U32 nPortOutput,
     OMX_IN  OMX_HANDLETYPE hInput,
     OMX_IN  OMX_U32 nPortInput);
-    
+
 /** @ingroup cp */
 OMX_API OMX_ERRORTYPE   OMX_GetContentPipe(
     OMX_OUT OMX_HANDLETYPE *hPipe,
     OMX_IN OMX_STRING szURI);
 
 /** The OMX_GetComponentsOfRole method will return the number of components that support the given
-    role and (if the compNames field is non-NULL) the names of those components. The call will fail if 
+    role and (if the compNames field is non-NULL) the names of those components. The call will fail if
     an insufficiently sized array of names is supplied. To ensure the array is sufficiently sized the
     client should:
         * first call this function with the compNames field NULL to determine the number of component names
-        * second call this function with the compNames field pointing to an array of names allocated 
+        * second call this function with the compNames field pointing to an array of names allocated
           according to the number returned by the first call.
 
     The core should return from this call within 5 msec.
-    
+
     @param [in] role
-        This is generic standard component name consisting only of component class 
+        This is generic standard component name consisting only of component class
         name and the type within that class (e.g. 'audio_decoder.aac').
     @param [inout] pNumComps
-        This is used both as input and output. 
- 
+        This is used both as input and output.
+
         If compNames is NULL, the input is ignored and the output specifies how many components support
         the given role.
-     
-        If compNames is not NULL, on input it bounds the size of the input structure and 
+
+        If compNames is not NULL, on input it bounds the size of the input structure and
         on output, it specifies the number of components string names listed within the compNames parameter.
     @param [inout] compNames
-        If NULL this field is ignored. If non-NULL this points to an array of 128-byte strings which accepts 
-        a list of the names of all physical components that implement the specified standard component name. 
+        If NULL this field is ignored. If non-NULL this points to an array of 128-byte strings which accepts
+        a list of the names of all physical components that implement the specified standard component name.
         Each name is NULL terminated. numComps indicates the number of names.
     @ingroup core
  */
-OMX_API OMX_ERRORTYPE OMX_GetComponentsOfRole ( 
-	OMX_IN      OMX_STRING role,
+OMX_API OMX_ERRORTYPE OMX_GetComponentsOfRole (
+    OMX_IN      OMX_STRING role,
     OMX_INOUT   OMX_U32 *pNumComps,
     OMX_INOUT   OMX_U8  **compNames);
 
 /** The OMX_GetRolesOfComponent method will return the number of roles supported by the given
-    component and (if the roles field is non-NULL) the names of those roles. The call will fail if 
+    component and (if the roles field is non-NULL) the names of those roles. The call will fail if
     an insufficiently sized array of names is supplied. To ensure the array is sufficiently sized the
     client should:
         * first call this function with the roles field NULL to determine the number of role names
-        * second call this function with the roles field pointing to an array of names allocated 
+        * second call this function with the roles field pointing to an array of names allocated
           according to the number returned by the first call.
 
     The core should return from this call within 5 msec.
@@ -1405,20 +1396,20 @@
     @param [in] compName
         This is the name of the component being queried about.
     @param [inout] pNumRoles
-        This is used both as input and output. 
- 
+        This is used both as input and output.
+
         If roles is NULL, the input is ignored and the output specifies how many roles the component supports.
-     
-        If compNames is not NULL, on input it bounds the size of the input structure and 
+
+        If compNames is not NULL, on input it bounds the size of the input structure and
         on output, it specifies the number of roles string names listed within the roles parameter.
     @param [out] roles
-        If NULL this field is ignored. If non-NULL this points to an array of 128-byte strings 
-        which accepts a list of the names of all standard components roles implemented on the 
+        If NULL this field is ignored. If non-NULL this points to an array of 128-byte strings
+        which accepts a list of the names of all standard components roles implemented on the
         specified component name. numComps indicates the number of names.
     @ingroup core
  */
-OMX_API OMX_ERRORTYPE OMX_GetRolesOfComponent ( 
-	OMX_IN      OMX_STRING compName, 
+OMX_API OMX_ERRORTYPE OMX_GetRolesOfComponent (
+    OMX_IN      OMX_STRING compName,
     OMX_INOUT   OMX_U32 *pNumRoles,
     OMX_OUT     OMX_U8 **roles);
 
Index: gst-omx-1.22.0/omx/openmax/OMX_CoreExt.h
===================================================================
--- gst-omx-1.22.0.orig/omx/openmax/OMX_CoreExt.h	2023-03-02 08:48:43.000000000 +0000
+++ gst-omx-1.22.0/omx/openmax/OMX_CoreExt.h	2023-03-02 08:58:22.000000000 +0000
@@ -1,73 +1,73 @@
-/*
- * Copyright (c) 2010 The Khronos Group Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject
- * to the following conditions:
- * The above copyright notice and this permission notice shall be included
- * in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
- * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
- * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-/** OMX_CoreExt.h - OpenMax IL version 1.1.2
- * The OMX_CoreExt header file contains extensions to the definitions used
- * by both the application and the component to access common items.
- */
-
-#ifndef OMX_CoreExt_h
-#define OMX_CoreExt_h
-
-#ifdef __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-
-/* Each OMX header shall include all required header files to allow the
- * header to compile without errors.  The includes below are required
- * for this header file to compile successfully
- */
-#include <OMX_Core.h>
-
-/** Extensions to the standard IL errors. */ 
-typedef enum OMX_ERROREXTTYPE 
-{
-    OMX_ErrorInvalidMode = (OMX_S32) (OMX_ErrorKhronosExtensions + 0x00000001),
-    OMX_ErrorExtMax = 0x7FFFFFFF
-} OMX_ERROREXTTYPE;
-
-
-/** Event type extensions. */
-typedef enum OMX_EVENTEXTTYPE
-{
-    OMX_EventIndexSettingChanged = OMX_EventKhronosExtensions, /**< component signals the IL client of a change
-                                                                    in a param, config, or extension */
-    OMX_EventExtMax = 0x7FFFFFFF
-} OMX_EVENTEXTTYPE;
-
-
-/** Enable or disable a callback event. */
-typedef struct OMX_CONFIG_CALLBACKREQUESTTYPE {
-    OMX_U32 nSize;              /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
-    OMX_U32 nPortIndex;         /**< port that this structure applies to */
-    OMX_INDEXTYPE nIndex;       /**< the index the callback is requested for */
-    OMX_BOOL bEnable;           /**< enable (OMX_TRUE) or disable (OMX_FALSE) the callback */
-} OMX_CONFIG_CALLBACKREQUESTTYPE;
-
-#ifdef __cplusplus
-}
-#endif /* __cplusplus */
-
-#endif /* OMX_CoreExt_h */
-/* File EOF */
+/*
+ * Copyright (c) 2016 The Khronos Group Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions:
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+/** OMX_CoreExt.h - OpenMax IL version 1.1.2
+ * The OMX_CoreExt header file contains extensions to the definitions used
+ * by both the application and the component to access common items.
+ */
+
+#ifndef OMX_CoreExt_h
+#define OMX_CoreExt_h
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/* Each OMX header shall include all required header files to allow the
+ * header to compile without errors.  The includes below are required
+ * for this header file to compile successfully
+ */
+#include <OMX_Core.h>
+
+/** Extensions to the standard IL errors. */ 
+typedef enum OMX_ERROREXTTYPE 
+{
+    OMX_ErrorInvalidMode = (OMX_S32) (OMX_ErrorKhronosExtensions + 0x00000001),
+    OMX_ErrorExtMax = 0x7FFFFFFF
+} OMX_ERROREXTTYPE;
+
+
+/** Event type extensions. */
+typedef enum OMX_EVENTEXTTYPE
+{
+    OMX_EventIndexSettingChanged = OMX_EventKhronosExtensions, /**< component signals the IL client of a change
+                                                                    in a param, config, or extension */
+    OMX_EventExtMax = 0x7FFFFFFF
+} OMX_EVENTEXTTYPE;
+
+
+/** Enable or disable a callback event. */
+typedef struct OMX_CONFIG_CALLBACKREQUESTTYPE {
+    OMX_U32 nSize;              /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
+    OMX_U32 nPortIndex;         /**< port that this structure applies to */
+    OMX_INDEXTYPE nIndex;       /**< the index the callback is requested for */
+    OMX_BOOL bEnable;           /**< enable (OMX_TRUE) or disable (OMX_FALSE) the callback */
+} OMX_CONFIG_CALLBACKREQUESTTYPE;
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* OMX_CoreExt_h */
+/* File EOF */
Index: gst-omx-1.22.0/omx/openmax/OMX_IVCommon.h
===================================================================
--- gst-omx-1.22.0.orig/omx/openmax/OMX_IVCommon.h	2023-03-02 08:58:22.000000000 +0000
+++ gst-omx-1.22.0/omx/openmax/OMX_IVCommon.h	2023-03-02 08:58:22.000000000 +0000
@@ -1,27 +1,27 @@
 /**
- * Copyright (c) 2008 The Khronos Group Inc. 
- * 
+ * Copyright (c) 2008 The Khronos Group Inc.
+ *
  * Permission is hereby granted, free of charge, to any person obtaining
  * a copy of this software and associated documentation files (the
  * "Software"), to deal in the Software without restriction, including
  * without limitation the rights to use, copy, modify, merge, publish,
  * distribute, sublicense, and/or sell copies of the Software, and to
  * permit persons to whom the Software is furnished to do so, subject
- * to the following conditions: 
+ * to the following conditions:
  * The above copyright notice and this permission notice shall be included
- * in all copies or substantial portions of the Software. 
- * 
+ * in all copies or substantial portions of the Software.
+ *
  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
  * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
  * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  *
  */
 
-/** 
+/**
  * @file OMX_IVCommon.h - OpenMax IL version 1.1.2
  *  The structures needed by Video and Image components to exchange
  *  parameters and configuration data with the components.
@@ -36,7 +36,7 @@
 /**
  * Each OMX header must include all required header files to allow the header
  * to compile without errors.  The includes below are required for this header
- * file to compile successfully 
+ * file to compile successfully
  */
 
 #include <OMX_Core.h>
@@ -47,8 +47,8 @@
  */
 
 
-/** 
- * Enumeration defining possible uncompressed image/video formats. 
+/**
+ * Enumeration defining possible uncompressed image/video formats.
  *
  * ENUMS:
  *  Unused                 : Placeholder value when format is N/A
@@ -96,7 +96,7 @@
     OMX_COLOR_Format16bitBGR565,
     OMX_COLOR_Format18bitRGB666,
     OMX_COLOR_Format18bitARGB1665,
-    OMX_COLOR_Format19bitARGB1666, 
+    OMX_COLOR_Format19bitARGB1666,
     OMX_COLOR_Format24bitRGB888,
     OMX_COLOR_Format24bitBGR888,
     OMX_COLOR_Format24bitARGB1887,
@@ -119,54 +119,126 @@
     OMX_COLOR_FormatRawBayer8bit,
     OMX_COLOR_FormatRawBayer10bit,
     OMX_COLOR_FormatRawBayer8bitcompressed,
-    OMX_COLOR_FormatL2, 
-    OMX_COLOR_FormatL4, 
-    OMX_COLOR_FormatL8, 
-    OMX_COLOR_FormatL16, 
-    OMX_COLOR_FormatL24, 
+    OMX_COLOR_FormatL2,
+    OMX_COLOR_FormatL4,
+    OMX_COLOR_FormatL8,
+    OMX_COLOR_FormatL16,
+    OMX_COLOR_FormatL24,
     OMX_COLOR_FormatL32,
     OMX_COLOR_FormatYUV420PackedSemiPlanar,
     OMX_COLOR_FormatYUV422PackedSemiPlanar,
     OMX_COLOR_Format18BitBGR666,
     OMX_COLOR_Format24BitARGB6666,
     OMX_COLOR_Format24BitABGR6666,
-    OMX_COLOR_FormatYVU420SemiPlanar,   /*  NV21  */
-    OMX_COLOR_FormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_COLOR_FormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
     OMX_COLOR_FormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+
+    /* Starfive extensions */
+    /* I420 */
+    OMX_COLOR_FormatYUV420Planar_P10_16BIT_MSB,
+    OMX_COLOR_FormatYUV420Planar_P10_16BIT_LSB,
+    OMX_COLOR_FormatYUV420Planar_P12_16BIT_MSB,
+    OMX_COLOR_FormatYUV420Planar_P12_16BIT_LSB,
+    /* NV12 */
+    OMX_COLOR_FormatYUV420SemiPlanar_P10_16BIT_MSB,
+    OMX_COLOR_FormatYUV420SemiPlanar_P10_16BIT_LSB,
+    OMX_COLOR_FormatYUV420SemiPlanar_P12_16BIT_MSB,
+    OMX_COLOR_FormatYUV420SemiPlanar_P12_16BIT_LSB,
+    /* NV21 */
+    OMX_COLOR_FormatYVU420SemiPlanar,
+    OMX_COLOR_FormatYVU420SemiPlanar_P10_16BIT_MSB,
+    OMX_COLOR_FormatYVU420SemiPlanar_P10_16BIT_LSB,
+    OMX_COLOR_FormatYVU420SemiPlanar_P12_16BIT_MSB,
+    OMX_COLOR_FormatYVU420SemiPlanar_P12_16BIT_LSB,
+    /* I422 */
+    OMX_COLOR_FormatYUV422Planar_P10_16BIT_MSB,
+    OMX_COLOR_FormatYUV422Planar_P10_16BIT_LSB,
+    OMX_COLOR_FormatYUV422Planar_P12_16BIT_MSB,
+    OMX_COLOR_FormatYUV422Planar_P12_16BIT_LSB,
+    /* NV16 */
+    OMX_COLOR_FormatYUV422SemiPlanar_P10_16BIT_MSB,
+    OMX_COLOR_FormatYUV422SemiPlanar_P10_16BIT_LSB,
+    OMX_COLOR_FormatYUV422SemiPlanar_P12_16BIT_MSB,
+    OMX_COLOR_FormatYUV422SemiPlanar_P12_16BIT_LSB,
+    /* NV61 */
+    OMX_COLOR_FormatYVU422SemiPlanar,
+    OMX_COLOR_FormatYVU422SemiPlanar_P10_16BIT_MSB,
+    OMX_COLOR_FormatYVU422SemiPlanar_P10_16BIT_LSB,
+    OMX_COLOR_FormatYVU422SemiPlanar_P12_16BIT_MSB,
+    OMX_COLOR_FormatYVU422SemiPlanar_P12_16BIT_LSB,
+    /* YUYV */
+    OMX_COLOR_FormatYCbYCr_P10_16BIT_MSB,
+    OMX_COLOR_FormatYCbYCr_P10_16BIT_LSB,
+    OMX_COLOR_FormatYCbYCr_P12_16BIT_MSB,
+    OMX_COLOR_FormatYCbYCr_P12_16BIT_LSB,
+    /* YVYU */
+    OMX_COLOR_FormatYCrYCb_P10_16BIT_MSB,
+    OMX_COLOR_FormatYCrYCb_P10_16BIT_LSB,
+    OMX_COLOR_FormatYCrYCb_P12_16BIT_MSB,
+    OMX_COLOR_FormatYCrYCb_P12_16BIT_LSB,
+    /* UYVY */
+    OMX_COLOR_FormatCbYCrY_P10_16BIT_MSB,
+    OMX_COLOR_FormatCbYCrY_P10_16BIT_LSB,
+    OMX_COLOR_FormatCbYCrY_P12_16BIT_MSB,
+    OMX_COLOR_FormatCbYCrY_P12_16BIT_LSB,
+    /* VYUY */
+    OMX_COLOR_FormatCrYCbY_P10_16BIT_MSB,
+    OMX_COLOR_FormatCrYCbY_P10_16BIT_LSB,
+    OMX_COLOR_FormatCrYCbY_P12_16BIT_MSB,
+    OMX_COLOR_FormatCrYCbY_P12_16BIT_LSB,
+    /* I444 */
+    OMX_COLOR_FormatYUV444Planar,
+    OMX_COLOR_FormatYUV444Planar_P10_16BIT_MSB,
+    OMX_COLOR_FormatYUV444Planar_P10_16BIT_LSB,
+    OMX_COLOR_FormatYUV444Planar_P12_16BIT_MSB,
+    OMX_COLOR_FormatYUV444Planar_P12_16BIT_LSB,
+    /* YUV444PACKED */
+    OMX_COLOR_FormatYUV444Interleaved_P10_16BIT_MSB,
+    OMX_COLOR_FormatYUV444Interleaved_P10_16BIT_LSB,
+    OMX_COLOR_FormatYUV444Interleaved_P12_16BIT_MSB,
+    OMX_COLOR_FormatYUV444Interleaved_P12_16BIT_LSB,
+    /* YUV400 */
+    OMX_COLOR_FormatYUV400,
+    OMX_COLOR_FormatYUV400_P10_16BIT_MSB,
+    OMX_COLOR_FormatYUV400_P10_16BIT_LSB,
+    OMX_COLOR_FormatYUV400_P12_16BIT_MSB,
+    OMX_COLOR_FormatYUV400_P12_16BIT_LSB,
+    /* Starfive extensions end */
+
     OMX_COLOR_FormatMax = 0x7FFFFFFF
 } OMX_COLOR_FORMATTYPE;
 
 
-/** 
+/**
  * Defines the matrix for conversion from RGB to YUV or vice versa.
- * iColorMatrix should be initialized with the fixed point values 
+ * iColorMatrix should be initialized with the fixed point values
  * used in converting between formats.
  */
 typedef struct OMX_CONFIG_COLORCONVERSIONTYPE {
     OMX_U32 nSize;              /**< Size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;   /**< OMX specification version info */ 
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version info */
     OMX_U32 nPortIndex;         /**< Port that this struct applies to */
     OMX_S32 xColorMatrix[3][3]; /**< Stored in signed Q16 format */
     OMX_S32 xColorOffset[4];    /**< Stored in signed Q16 format */
-}OMX_CONFIG_COLORCONVERSIONTYPE;
+} OMX_CONFIG_COLORCONVERSIONTYPE;
 
 
-/** 
- * Structure defining percent to scale each frame dimension.  For example:  
+/**
+ * Structure defining percent to scale each frame dimension.  For example:
  * To make the width 50% larger, use fWidth = 1.5 and to make the width
  * 1/2 the original size, use fWidth = 0.5
  */
 typedef struct OMX_CONFIG_SCALEFACTORTYPE {
     OMX_U32 nSize;            /**< Size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion; /**< OMX specification version info */ 
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version info */
     OMX_U32 nPortIndex;       /**< Port that this struct applies to */
     OMX_S32 xWidth;           /**< Fixed point value stored as Q16 */
     OMX_S32 xHeight;          /**< Fixed point value stored as Q16 */
-}OMX_CONFIG_SCALEFACTORTYPE;
+} OMX_CONFIG_SCALEFACTORTYPE;
 
 
-/** 
- * Enumeration of possible image filter types 
+/**
+ * Enumeration of possible image filter types
  */
 typedef enum OMX_IMAGEFILTERTYPE {
     OMX_ImageFilterNone,
@@ -177,23 +249,23 @@
     OMX_ImageFilterOilPaint,
     OMX_ImageFilterHatch,
     OMX_ImageFilterGpen,
-    OMX_ImageFilterAntialias, 
-    OMX_ImageFilterDeRing,       
+    OMX_ImageFilterAntialias,
+    OMX_ImageFilterDeRing,
     OMX_ImageFilterSolarize,
-    OMX_ImageFilterKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_ImageFilterKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
     OMX_ImageFilterVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_ImageFilterMax = 0x7FFFFFFF
 } OMX_IMAGEFILTERTYPE;
 
 
-/** 
- * Image filter configuration 
+/**
+ * Image filter configuration
  *
  * STRUCT MEMBERS:
- *  nSize        : Size of the structure in bytes       
+ *  nSize        : Size of the structure in bytes
  *  nVersion     : OMX specification version information
- *  nPortIndex   : Port that this structure applies to 
- *  eImageFilter : Image filter type enumeration      
+ *  nPortIndex   : Port that this structure applies to
+ *  eImageFilter : Image filter type enumeration
  */
 typedef struct OMX_CONFIG_IMAGEFILTERTYPE {
     OMX_U32 nSize;
@@ -203,22 +275,22 @@
 } OMX_CONFIG_IMAGEFILTERTYPE;
 
 
-/** 
- * Customized U and V for color enhancement 
+/**
+ * Customized U and V for color enhancement
  *
  * STRUCT MEMBERS:
  *  nSize             : Size of the structure in bytes
- *  nVersion          : OMX specification version information 
+ *  nVersion          : OMX specification version information
  *  nPortIndex        : Port that this structure applies to
  *  bColorEnhancement : Enable/disable color enhancement
- *  nCustomizedU      : Practical values: 16-240, range: 0-255, value set for 
+ *  nCustomizedU      : Practical values: 16-240, range: 0-255, value set for
  *                      U component
- *  nCustomizedV      : Practical values: 16-240, range: 0-255, value set for 
+ *  nCustomizedV      : Practical values: 16-240, range: 0-255, value set for
  *                      V component
  */
 typedef struct OMX_CONFIG_COLORENHANCEMENTTYPE {
     OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion; 
+    OMX_VERSIONTYPE nVersion;
     OMX_U32 nPortIndex;
     OMX_BOOL bColorEnhancement;
     OMX_U8 nCustomizedU;
@@ -226,12 +298,12 @@
 } OMX_CONFIG_COLORENHANCEMENTTYPE;
 
 
-/** 
- * Define color key and color key mask 
+/**
+ * Define color key and color key mask
  *
  * STRUCT MEMBERS:
  *  nSize      : Size of the structure in bytes
- *  nVersion   : OMX specification version information 
+ *  nVersion   : OMX specification version information
  *  nPortIndex : Port that this structure applies to
  *  nARGBColor : 32bit Alpha, Red, Green, Blue Color
  *  nARGBMask  : 32bit Mask for Alpha, Red, Green, Blue channels
@@ -245,12 +317,12 @@
 } OMX_CONFIG_COLORKEYTYPE;
 
 
-/** 
- * List of color blend types for pre/post processing 
+/**
+ * List of color blend types for pre/post processing
  *
  * ENUMS:
  *  None          : No color blending present
- *  AlphaConstant : Function is (alpha_constant * src) + 
+ *  AlphaConstant : Function is (alpha_constant * src) +
  *                  (1 - alpha_constant) * dst)
  *  AlphaPerPixel : Function is (alpha * src) + (1 - alpha) * dst)
  *  Alternate     : Function is alternating pixels from src and dst
@@ -266,21 +338,21 @@
     OMX_ColorBlendAnd,
     OMX_ColorBlendOr,
     OMX_ColorBlendInvert,
-    OMX_ColorBlendKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_ColorBlendKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
     OMX_ColorBlendVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_ColorBlendMax = 0x7FFFFFFF
 } OMX_COLORBLENDTYPE;
 
 
-/** 
- * Color blend configuration 
+/**
+ * Color blend configuration
  *
  * STRUCT MEMBERS:
- *  nSize             : Size of the structure in bytes                        
- *  nVersion          : OMX specification version information                
- *  nPortIndex        : Port that this structure applies to                   
+ *  nSize             : Size of the structure in bytes
+ *  nVersion          : OMX specification version information
+ *  nPortIndex        : Port that this structure applies to
  *  nRGBAlphaConstant : Constant global alpha values when global alpha is used
- *  eColorBlend       : Color blend type enumeration                         
+ *  eColorBlend       : Color blend type enumeration
  */
 typedef struct OMX_CONFIG_COLORBLENDTYPE {
     OMX_U32 nSize;
@@ -291,15 +363,15 @@
 } OMX_CONFIG_COLORBLENDTYPE;
 
 
-/** 
+/**
  * Hold frame dimension
  *
  * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes      
+ *  nSize      : Size of the structure in bytes
  *  nVersion   : OMX specification version information
- *  nPortIndex : Port that this structure applies to     
- *  nWidth     : Frame width in pixels                 
- *  nHeight    : Frame height in pixels                
+ *  nPortIndex : Port that this structure applies to
+ *  nWidth     : Frame width in pixels
+ *  nHeight    : Frame height in pixels
  */
 typedef struct OMX_FRAMESIZETYPE {
     OMX_U32 nSize;
@@ -311,69 +383,69 @@
 
 
 /**
- * Rotation configuration 
+ * Rotation configuration
  *
  * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes             
+ *  nSize      : Size of the structure in bytes
  *  nVersion   : OMX specification version information
  *  nPortIndex : Port that this structure applies to
- *  nRotation  : +/- integer rotation value               
+ *  nRotation  : +/- integer rotation value
  */
 typedef struct OMX_CONFIG_ROTATIONTYPE {
     OMX_U32 nSize;
     OMX_VERSIONTYPE nVersion;
     OMX_U32 nPortIndex;
-    OMX_S32 nRotation; 
+    OMX_S32 nRotation;
 } OMX_CONFIG_ROTATIONTYPE;
 
 
-/** 
- * Possible mirroring directions for pre/post processing 
+/**
+ * Possible mirroring directions for pre/post processing
  *
  * ENUMS:
- *  None       : No mirroring                         
- *  Vertical   : Vertical mirroring, flip on X axis   
- *  Horizontal : Horizontal mirroring, flip on Y axis  
+ *  None       : No mirroring
+ *  Vertical   : Vertical mirroring, flip on X axis
+ *  Horizontal : Horizontal mirroring, flip on Y axis
  *  Both       : Both vertical and horizontal mirroring
  */
 typedef enum OMX_MIRRORTYPE {
     OMX_MirrorNone = 0,
     OMX_MirrorVertical,
     OMX_MirrorHorizontal,
-    OMX_MirrorBoth, 
-    OMX_MirrorKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_MirrorBoth,
+    OMX_MirrorKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
     OMX_MirrorVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_MirrorMax = 0x7FFFFFFF   
+    OMX_MirrorMax = 0x7FFFFFFF
 } OMX_MIRRORTYPE;
 
 
-/** 
- * Mirroring configuration 
+/**
+ * Mirroring configuration
  *
  * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes      
+ *  nSize      : Size of the structure in bytes
  *  nVersion   : OMX specification version information
- *  nPortIndex : Port that this structure applies to  
- *  eMirror    : Mirror type enumeration              
+ *  nPortIndex : Port that this structure applies to
+ *  eMirror    : Mirror type enumeration
  */
 typedef struct OMX_CONFIG_MIRRORTYPE {
     OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion; 
+    OMX_VERSIONTYPE nVersion;
     OMX_U32 nPortIndex;
     OMX_MIRRORTYPE  eMirror;
 } OMX_CONFIG_MIRRORTYPE;
 
 
-/** 
- * Position information only 
+/**
+ * Position information only
  *
  * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes               
+ *  nSize      : Size of the structure in bytes
  *  nVersion   : OMX specification version information
  *  nPortIndex : Port that this structure applies to
- *  nX         : X coordinate for the point                     
- *  nY         : Y coordinate for the point 
- */                      
+ *  nX         : X coordinate for the point
+ *  nY         : Y coordinate for the point
+ */
 typedef struct OMX_CONFIG_POINTTYPE {
     OMX_U32 nSize;
     OMX_VERSIONTYPE nVersion;
@@ -383,37 +455,37 @@
 } OMX_CONFIG_POINTTYPE;
 
 
-/** 
- * Frame size plus position 
+/**
+ * Frame size plus position
  *
  * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes                    
- *  nVersion   : OMX specification version information      
- *  nPortIndex : Port that this structure applies to    
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to
  *  nLeft      : X Coordinate of the top left corner of the rectangle
  *  nTop       : Y Coordinate of the top left corner of the rectangle
- *  nWidth     : Width of the rectangle                              
- *  nHeight    : Height of the rectangle                             
+ *  nWidth     : Width of the rectangle
+ *  nHeight    : Height of the rectangle
  */
 typedef struct OMX_CONFIG_RECTTYPE {
     OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;  
-    OMX_U32 nPortIndex; 
-    OMX_S32 nLeft; 
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_S32 nLeft;
     OMX_S32 nTop;
     OMX_U32 nWidth;
     OMX_U32 nHeight;
 } OMX_CONFIG_RECTTYPE;
 
 
-/** 
- * Deblocking state; it is required to be set up before starting the codec 
+/**
+ * Deblocking state; it is required to be set up before starting the codec
  *
  * STRUCT MEMBERS:
- *  nSize       : Size of the structure in bytes      
- *  nVersion    : OMX specification version information 
+ *  nSize       : Size of the structure in bytes
+ *  nVersion    : OMX specification version information
  *  nPortIndex  : Port that this structure applies to
- *  bDeblocking : Enable/disable deblocking mode    
+ *  bDeblocking : Enable/disable deblocking mode
  */
 typedef struct OMX_PARAM_DEBLOCKINGTYPE {
     OMX_U32 nSize;
@@ -423,13 +495,13 @@
 } OMX_PARAM_DEBLOCKINGTYPE;
 
 
-/** 
- * Stabilization state 
+/**
+ * Stabilization state
  *
  * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes          
- *  nVersion   : OMX specification version information    
- *  nPortIndex : Port that this structure applies to   
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to
  *  bStab      : Enable/disable frame stabilization state
  */
 typedef struct OMX_CONFIG_FRAMESTABTYPE {
@@ -440,8 +512,8 @@
 } OMX_CONFIG_FRAMESTABTYPE;
 
 
-/** 
- * White Balance control type 
+/**
+ * White Balance control type
  *
  * STRUCT MEMBERS:
  *  SunLight : Referenced in JSR-234
@@ -458,20 +530,20 @@
     OMX_WhiteBalControlIncandescent,
     OMX_WhiteBalControlFlash,
     OMX_WhiteBalControlHorizon,
-    OMX_WhiteBalControlKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_WhiteBalControlKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
     OMX_WhiteBalControlVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_WhiteBalControlMax = 0x7FFFFFFF
 } OMX_WHITEBALCONTROLTYPE;
 
 
-/** 
- * White Balance control configuration 
+/**
+ * White Balance control configuration
  *
  * STRUCT MEMBERS:
- *  nSize            : Size of the structure in bytes       
+ *  nSize            : Size of the structure in bytes
  *  nVersion         : OMX specification version information
- *  nPortIndex       : Port that this structure applies to                 
- *  eWhiteBalControl : White balance enumeration            
+ *  nPortIndex       : Port that this structure applies to
+ *  eWhiteBalControl : White balance enumeration
  */
 typedef struct OMX_CONFIG_WHITEBALCONTROLTYPE {
     OMX_U32 nSize;
@@ -481,8 +553,8 @@
 } OMX_CONFIG_WHITEBALCONTROLTYPE;
 
 
-/** 
- * Exposure control type 
+/**
+ * Exposure control type
  */
 typedef enum OMX_EXPOSURECONTROLTYPE {
     OMX_ExposureControlOff = 0,
@@ -495,20 +567,20 @@
     OMX_ExposureControlBeach,
     OMX_ExposureControlLargeAperture,
     OMX_ExposureControlSmallApperture,
-    OMX_ExposureControlKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_ExposureControlKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
     OMX_ExposureControlVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_ExposureControlMax = 0x7FFFFFFF
 } OMX_EXPOSURECONTROLTYPE;
 
 
-/** 
- * White Balance control configuration 
+/**
+ * White Balance control configuration
  *
  * STRUCT MEMBERS:
- *  nSize            : Size of the structure in bytes      
+ *  nSize            : Size of the structure in bytes
  *  nVersion         : OMX specification version information
- *  nPortIndex       : Port that this structure applies to                
- *  eExposureControl : Exposure control enumeration         
+ *  nPortIndex       : Port that this structure applies to
+ *  eExposureControl : Exposure control enumeration
  */
 typedef struct OMX_CONFIG_EXPOSURECONTROLTYPE {
     OMX_U32 nSize;
@@ -518,16 +590,16 @@
 } OMX_CONFIG_EXPOSURECONTROLTYPE;
 
 
-/** 
- * Defines sensor supported mode. 
+/**
+ * Defines sensor supported mode.
  *
  * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes           
+ *  nSize      : Size of the structure in bytes
  *  nVersion   : OMX specification version information
- *  nPortIndex : Port that this structure applies to 
- *  nFrameRate : Single shot mode is indicated by a 0     
+ *  nPortIndex : Port that this structure applies to
+ *  nFrameRate : Single shot mode is indicated by a 0
  *  bOneShot   : Enable for single shot, disable for streaming
- *  sFrameSize : Framesize                                          
+ *  sFrameSize : Framesize
  */
 typedef struct OMX_PARAM_SENSORMODETYPE {
     OMX_U32 nSize;
@@ -539,13 +611,13 @@
 } OMX_PARAM_SENSORMODETYPE;
 
 
-/** 
- * Defines contrast level 
+/**
+ * Defines contrast level
  *
  * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes                              
- *  nVersion   : OMX specification version information                
- *  nPortIndex : Port that this structure applies to                 
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to
  *  nContrast  : Values allowed for contrast -100 to 100, zero means no change
  */
 typedef struct OMX_CONFIG_CONTRASTTYPE {
@@ -556,14 +628,14 @@
 } OMX_CONFIG_CONTRASTTYPE;
 
 
-/** 
- * Defines brightness level 
+/**
+ * Defines brightness level
  *
  * STRUCT MEMBERS:
- *  nSize       : Size of the structure in bytes          
- *  nVersion    : OMX specification version information 
- *  nPortIndex  : Port that this structure applies to 
- *  nBrightness : 0-100%        
+ *  nSize       : Size of the structure in bytes
+ *  nVersion    : OMX specification version information
+ *  nPortIndex  : Port that this structure applies to
+ *  nBrightness : 0-100%
  */
 typedef struct OMX_CONFIG_BRIGHTNESSTYPE {
     OMX_U32 nSize;
@@ -573,16 +645,16 @@
 } OMX_CONFIG_BRIGHTNESSTYPE;
 
 
-/** 
- * Defines backlight level configuration for a video sink, e.g. LCD panel 
+/**
+ * Defines backlight level configuration for a video sink, e.g. LCD panel
  *
  * STRUCT MEMBERS:
  *  nSize      : Size of the structure in bytes
- *  nVersion   : OMX specification version information 
+ *  nVersion   : OMX specification version information
  *  nPortIndex : Port that this structure applies to
  *  nBacklight : Values allowed for backlight 0-100%
- *  nTimeout   : Number of milliseconds before backlight automatically turns 
- *               off.  A value of 0x0 disables backight timeout 
+ *  nTimeout   : Number of milliseconds before backlight automatically turns
+ *               off.  A value of 0x0 disables backight timeout
  */
 typedef struct OMX_CONFIG_BACKLIGHTTYPE {
     OMX_U32 nSize;
@@ -593,12 +665,12 @@
 } OMX_CONFIG_BACKLIGHTTYPE;
 
 
-/** 
- * Defines setting for Gamma 
+/**
+ * Defines setting for Gamma
  *
  * STRUCT MEMBERS:
  *  nSize      : Size of the structure in bytes
- *  nVersion   : OMX specification version information 
+ *  nVersion   : OMX specification version information
  *  nPortIndex : Port that this structure applies to
  *  nGamma     : Values allowed for gamma -100 to 100, zero means no change
  */
@@ -610,14 +682,14 @@
 } OMX_CONFIG_GAMMATYPE;
 
 
-/** 
- * Define for setting saturation 
- * 
+/**
+ * Define for setting saturation
+ *
  * STRUCT MEMBERS:
  *  nSize       : Size of the structure in bytes
  *  nVersion    : OMX specification version information
  *  nPortIndex  : Port that this structure applies to
- *  nSaturation : Values allowed for saturation -100 to 100, zero means 
+ *  nSaturation : Values allowed for saturation -100 to 100, zero means
  *                no change
  */
 typedef struct OMX_CONFIG_SATURATIONTYPE {
@@ -628,14 +700,14 @@
 } OMX_CONFIG_SATURATIONTYPE;
 
 
-/** 
- * Define for setting Lightness 
+/**
+ * Define for setting Lightness
  *
  * STRUCT MEMBERS:
  *  nSize      : Size of the structure in bytes
  *  nVersion   : OMX specification version information
  *  nPortIndex : Port that this structure applies to
- *  nLightness : Values allowed for lightness -100 to 100, zero means no 
+ *  nLightness : Values allowed for lightness -100 to 100, zero means no
  *               change
  */
 typedef struct OMX_CONFIG_LIGHTNESSTYPE {
@@ -646,17 +718,17 @@
 } OMX_CONFIG_LIGHTNESSTYPE;
 
 
-/** 
- * Plane blend configuration 
+/**
+ * Plane blend configuration
  *
  * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes 
+ *  nSize      : Size of the structure in bytes
  *  nVersion   : OMX specification version information
  *  nPortIndex : Index of input port associated with the plane.
- *  nDepth     : Depth of the plane in relation to the screen. Higher 
- *               numbered depths are "behind" lower number depths.  
+ *  nDepth     : Depth of the plane in relation to the screen. Higher
+ *               numbered depths are "behind" lower number depths.
  *               This number defaults to the Port Index number.
- *  nAlpha     : Transparency blending component for the entire plane.  
+ *  nAlpha     : Transparency blending component for the entire plane.
  *               See blending modes for more detail.
  */
 typedef struct OMX_CONFIG_PLANEBLENDTYPE {
@@ -668,17 +740,17 @@
 } OMX_CONFIG_PLANEBLENDTYPE;
 
 
-/** 
+/**
  * Define interlace type
  *
  * STRUCT MEMBERS:
- *  nSize                 : Size of the structure in bytes 
- *  nVersion              : OMX specification version information 
+ *  nSize                 : Size of the structure in bytes
+ *  nVersion              : OMX specification version information
  *  nPortIndex            : Port that this structure applies to
- *  bEnable               : Enable control variable for this functionality 
+ *  bEnable               : Enable control variable for this functionality
  *                          (see below)
- *  nInterleavePortIndex  : Index of input or output port associated with  
- *                          the interleaved plane. 
+ *  nInterleavePortIndex  : Index of input or output port associated with
+ *                          the interleaved plane.
  *  pPlanarPortIndexes[4] : Index of input or output planar ports.
  */
 typedef struct OMX_PARAM_INTERLEAVETYPE {
@@ -690,8 +762,8 @@
 } OMX_PARAM_INTERLEAVETYPE;
 
 
-/** 
- * Defines the picture effect used for an input picture 
+/**
+ * Defines the picture effect used for an input picture
  */
 typedef enum OMX_TRANSITIONEFFECTTYPE {
     OMX_EffectNone,
@@ -701,18 +773,18 @@
     OMX_EffectDissolve,
     OMX_EffectWipe,
     OMX_EffectUnspecifiedMixOfTwoScenes,
-    OMX_EffectKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_EffectKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
     OMX_EffectVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_EffectMax = 0x7FFFFFFF
 } OMX_TRANSITIONEFFECTTYPE;
 
 
-/** 
- * Structure used to configure current transition effect 
+/**
+ * Structure used to configure current transition effect
  *
  * STRUCT MEMBERS:
  * nSize      : Size of the structure in bytes
- * nVersion   : OMX specification version information 
+ * nVersion   : OMX specification version information
  * nPortIndex : Port that this structure applies to
  * eEffect    : Effect to enable
  */
@@ -724,43 +796,43 @@
 } OMX_CONFIG_TRANSITIONEFFECTTYPE;
 
 
-/** 
- * Defines possible data unit types for encoded video data. The data unit 
+/**
+ * Defines possible data unit types for encoded video data. The data unit
  * types are used both for encoded video input for playback as well as
- * encoded video output from recording. 
+ * encoded video output from recording.
  */
 typedef enum OMX_DATAUNITTYPE {
     OMX_DataUnitCodedPicture,
     OMX_DataUnitVideoSegment,
     OMX_DataUnitSeveralSegments,
     OMX_DataUnitArbitraryStreamSection,
-    OMX_DataUnitKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_DataUnitKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
     OMX_DataUnitVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_DataUnitMax = 0x7FFFFFFF
 } OMX_DATAUNITTYPE;
 
 
-/** 
- * Defines possible encapsulation types for coded video data unit. The 
- * encapsulation information is used both for encoded video input for 
- * playback as well as encoded video output from recording. 
+/**
+ * Defines possible encapsulation types for coded video data unit. The
+ * encapsulation information is used both for encoded video input for
+ * playback as well as encoded video output from recording.
  */
 typedef enum OMX_DATAUNITENCAPSULATIONTYPE {
     OMX_DataEncapsulationElementaryStream,
     OMX_DataEncapsulationGenericPayload,
     OMX_DataEncapsulationRtpPayload,
-    OMX_DataEncapsulationKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_DataEncapsulationKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
     OMX_DataEncapsulationVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_DataEncapsulationMax = 0x7FFFFFFF
 } OMX_DATAUNITENCAPSULATIONTYPE;
 
 
-/** 
- * Structure used to configure the type of being decoded/encoded 
+/**
+ * Structure used to configure the type of being decoded/encoded
  */
 typedef struct OMX_PARAM_DATAUNITTYPE {
     OMX_U32 nSize;            /**< Size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */ 
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
     OMX_U32 nPortIndex;       /**< Port that this structure applies to */
     OMX_DATAUNITTYPE eUnitType;
     OMX_DATAUNITENCAPSULATIONTYPE eEncapsulationType;
@@ -768,25 +840,25 @@
 
 
 /**
- * Defines dither types 
+ * Defines dither types
  */
 typedef enum OMX_DITHERTYPE {
     OMX_DitherNone,
     OMX_DitherOrdered,
     OMX_DitherErrorDiffusion,
     OMX_DitherOther,
-    OMX_DitherKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_DitherKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
     OMX_DitherVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_DitherMax = 0x7FFFFFFF
 } OMX_DITHERTYPE;
 
 
-/** 
- * Structure used to configure current type of dithering 
+/**
+ * Structure used to configure current type of dithering
  */
 typedef struct OMX_CONFIG_DITHERTYPE {
     OMX_U32 nSize;            /**< Size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */ 
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
     OMX_U32 nPortIndex;       /**< Port that this structure applies to */
     OMX_DITHERTYPE eDither;   /**< Type of dithering to use */
 } OMX_CONFIG_DITHERTYPE;
@@ -795,28 +867,28 @@
     OMX_U32 nSize;
     OMX_VERSIONTYPE nVersion;
     OMX_U32 nPortIndex;     /**< Port that this structure applies to */
-    OMX_BOOL bContinuous;   /**< If true then ignore frame rate and emit capture 
+    OMX_BOOL bContinuous;   /**< If true then ignore frame rate and emit capture
                              *   data as fast as possible (otherwise obey port's frame rate). */
-    OMX_BOOL bFrameLimited; /**< If true then terminate capture after the port emits the 
-                             *   specified number of frames (otherwise the port does not 
-                             *   terminate the capture until instructed to do so by the client). 
-                             *   Even if set, the client may manually terminate the capture prior 
+    OMX_BOOL bFrameLimited; /**< If true then terminate capture after the port emits the
+                             *   specified number of frames (otherwise the port does not
+                             *   terminate the capture until instructed to do so by the client).
+                             *   Even if set, the client may manually terminate the capture prior
                              *   to reaching the limit. */
     OMX_U32 nFrameLimit;      /**< Limit on number of frames emitted during a capture (only
                                *   valid if bFrameLimited is set). */
 } OMX_CONFIG_CAPTUREMODETYPE;
 
 typedef enum OMX_METERINGTYPE {
- 
+
     OMX_MeteringModeAverage,     /**< Center-weighted average metering. */
-    OMX_MeteringModeSpot,  	      /**< Spot (partial) metering. */
+    OMX_MeteringModeSpot,         /**< Spot (partial) metering. */
     OMX_MeteringModeMatrix,      /**< Matrix or evaluative metering. */
- 
-    OMX_MeteringKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+
+    OMX_MeteringKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
     OMX_MeteringVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_EVModeMax = 0x7fffffff
 } OMX_METERINGTYPE;
- 
+
 typedef struct OMX_CONFIG_EXPOSUREVALUETYPE {
     OMX_U32 nSize;
     OMX_VERSIONTYPE nVersion;
@@ -824,15 +896,15 @@
     OMX_METERINGTYPE eMetering;
     OMX_S32 xEVCompensation;      /**< Fixed point value stored as Q16 */
     OMX_U32 nApertureFNumber;     /**< e.g. nApertureFNumber = 2 implies "f/2" - Q16 format */
-    OMX_BOOL bAutoAperture;		/**< Whether aperture number is defined automatically */
-    OMX_U32 nShutterSpeedMsec;    /**< Shutterspeed in milliseconds */ 
-    OMX_BOOL bAutoShutterSpeed;	/**< Whether shutter speed is defined automatically */ 
+    OMX_BOOL bAutoAperture;     /**< Whether aperture number is defined automatically */
+    OMX_U32 nShutterSpeedMsec;    /**< Shutterspeed in milliseconds */
+    OMX_BOOL bAutoShutterSpeed; /**< Whether shutter speed is defined automatically */
     OMX_U32 nSensitivity;         /**< e.g. nSensitivity = 100 implies "ISO 100" */
-    OMX_BOOL bAutoSensitivity;	/**< Whether sensitivity is defined automatically */
+    OMX_BOOL bAutoSensitivity;  /**< Whether sensitivity is defined automatically */
 } OMX_CONFIG_EXPOSUREVALUETYPE;
 
-/** 
- * Focus region configuration 
+/**
+ * Focus region configuration
  *
  * STRUCT MEMBERS:
  *  nSize           : Size of the structure in bytes
@@ -863,8 +935,8 @@
     OMX_BOOL bBottomRight;
 } OMX_CONFIG_FOCUSREGIONTYPE;
 
-/** 
- * Focus Status type 
+/**
+ * Focus Status type
  */
 typedef enum OMX_FOCUSSTATUSTYPE {
     OMX_FocusStatusOff = 0,
@@ -872,13 +944,13 @@
     OMX_FocusStatusReached,
     OMX_FocusStatusUnableToReach,
     OMX_FocusStatusLost,
-    OMX_FocusStatusKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_FocusStatusKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
     OMX_FocusStatusVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_FocusStatusMax = 0x7FFFFFFF
 } OMX_FOCUSSTATUSTYPE;
 
-/** 
- * Focus status configuration 
+/**
+ * Focus status configuration
  *
  * STRUCT MEMBERS:
  *  nSize               : Size of the structure in bytes
Index: gst-omx-1.22.0/omx/openmax/OMX_Image.h
===================================================================
--- gst-omx-1.22.0.orig/omx/openmax/OMX_Image.h	2023-03-02 08:48:43.000000000 +0000
+++ gst-omx-1.22.0/omx/openmax/OMX_Image.h	2023-03-02 08:58:22.000000000 +0000
@@ -1,28 +1,28 @@
 /**
- * Copyright (c) 2008 The Khronos Group Inc. 
- * 
+ * Copyright (c) 2008 The Khronos Group Inc.
+ *
  * Permission is hereby granted, free of charge, to any person obtaining
  * a copy of this software and associated documentation files (the
  * "Software"), to deal in the Software without restriction, including
  * without limitation the rights to use, copy, modify, merge, publish,
  * distribute, sublicense, and/or sell copies of the Software, and to
  * permit persons to whom the Software is furnished to do so, subject
- * to the following conditions: 
+ * to the following conditions:
  * The above copyright notice and this permission notice shall be included
- * in all copies or substantial portions of the Software. 
- * 
+ * in all copies or substantial portions of the Software.
+ *
  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
  * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
  * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
-/** 
+/**
  * @file OMX_Image.h - OpenMax IL version 1.1.2
- * The structures needed by Image components to exchange parameters and 
+ * The structures needed by Image components to exchange parameters and
  * configuration data with the components.
  */
 #ifndef OMX_Image_h
@@ -34,9 +34,9 @@
 
 
 /**
- * Each OMX header must include all required header files to allow the 
- * header to compile without errors.  The includes below are required  
- * for this header file to compile successfully 
+ * Each OMX header must include all required header files to allow the
+ * header to compile without errors.  The includes below are required
+ * for this header file to compile successfully
  */
 
 #include <OMX_IVCommon.h>
@@ -47,8 +47,8 @@
  * @{
  */
 
-/** 
- * Enumeration used to define the possible image compression coding. 
+/**
+ * Enumeration used to define the possible image compression coding.
  */
 typedef enum OMX_IMAGE_CODINGTYPE {
     OMX_IMAGE_CodingUnused,      /**< Value when format is N/A */
@@ -61,59 +61,59 @@
     OMX_IMAGE_CodingPNG,         /**< PNG image format */
     OMX_IMAGE_CodingLZW,         /**< LZW image format */
     OMX_IMAGE_CodingBMP,         /**< Windows Bitmap format */
-    OMX_IMAGE_CodingKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_IMAGE_CodingKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
     OMX_IMAGE_CodingVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_IMAGE_CodingMax = 0x7FFFFFFF
 } OMX_IMAGE_CODINGTYPE;
 
 
 /**
- * Data structure used to define an image path. The number of image paths 
- * for input and output will vary by type of the image component.  
- * 
+ * Data structure used to define an image path. The number of image paths
+ * for input and output will vary by type of the image component.
+ *
  *  Input (aka Source) : Zero Inputs, one Output,
  *  Splitter           : One Input, 2 or more Outputs,
  *  Processing Element : One Input, one output,
  *  Mixer              : 2 or more inputs, one output,
  *  Output (aka Sink)  : One Input, zero outputs.
- * 
- * The PortDefinition structure is used to define all of the parameters 
- * necessary for the compliant component to setup an input or an output  
- * image path.  If additional vendor specific data is required, it should  
- * be transmitted to the component using the CustomCommand function.   
- * Compliant components will prepopulate this structure with optimal  
+ *
+ * The PortDefinition structure is used to define all of the parameters
+ * necessary for the compliant component to setup an input or an output
+ * image path.  If additional vendor specific data is required, it should
+ * be transmitted to the component using the CustomCommand function.
+ * Compliant components will prepopulate this structure with optimal
  * values during the OMX_GetParameter() command.
  *
  * STRUCT MEMBERS:
  *  cMIMEType             : MIME type of data for the port
- *  pNativeRender         : Platform specific reference for a display if a 
+ *  pNativeRender         : Platform specific reference for a display if a
  *                          sync, otherwise this field is 0
- *  nFrameWidth           : Width of frame to be used on port if 
- *                          uncompressed format is used.  Use 0 for 
+ *  nFrameWidth           : Width of frame to be used on port if
+ *                          uncompressed format is used.  Use 0 for
  *                          unknown, don't care or variable
- *  nFrameHeight          : Height of frame to be used on port if 
- *                          uncompressed format is used. Use 0 for 
+ *  nFrameHeight          : Height of frame to be used on port if
+ *                          uncompressed format is used. Use 0 for
  *                          unknown, don't care or variable
- *  nStride               : Number of bytes per span of an image (i.e. 
+ *  nStride               : Number of bytes per span of an image (i.e.
  *                          indicates the number of bytes to get from
- *                          span N to span N+1, where negative stride 
+ *                          span N to span N+1, where negative stride
  *                          indicates the image is bottom up
  *  nSliceHeight          : Height used when encoding in slices
- *  bFlagErrorConcealment : Turns on error concealment if it is supported by 
+ *  bFlagErrorConcealment : Turns on error concealment if it is supported by
  *                          the OMX component
- *  eCompressionFormat    : Compression format used in this instance of  
- *                          the component. When OMX_IMAGE_CodingUnused is 
+ *  eCompressionFormat    : Compression format used in this instance of
+ *                          the component. When OMX_IMAGE_CodingUnused is
  *                          specified, eColorFormat is valid
  *  eColorFormat          : Decompressed format used by this component
- *  pNativeWindow         : Platform specific reference for a window object if a 
- *                          display sink , otherwise this field is 0x0. 
+ *  pNativeWindow         : Platform specific reference for a window object if a
+ *                          display sink , otherwise this field is 0x0.
  */
 typedef struct OMX_IMAGE_PORTDEFINITIONTYPE {
     OMX_STRING cMIMEType;
     OMX_NATIVE_DEVICETYPE pNativeRender;
-    OMX_U32 nFrameWidth; 
+    OMX_U32 nFrameWidth;
     OMX_U32 nFrameHeight;
-    OMX_S32 nStride;     
+    OMX_S32 nStride;
     OMX_U32 nSliceHeight;
     OMX_BOOL bFlagErrorConcealment;
     OMX_IMAGE_CODINGTYPE eCompressionFormat;
@@ -122,18 +122,18 @@
 } OMX_IMAGE_PORTDEFINITIONTYPE;
 
 
-/**  
- * Port format parameter.  This structure is used to enumerate the various 
+/**
+ * Port format parameter.  This structure is used to enumerate the various
  * data input/output format supported by the port.
- * 
+ *
  * STRUCT MEMBERS:
  *  nSize              : Size of the structure in bytes
  *  nVersion           : OMX specification version information
  *  nPortIndex         : Indicates which port to set
- *  nIndex             : Indicates the enumeration index for the format from 
+ *  nIndex             : Indicates the enumeration index for the format from
  *                       0x0 to N-1
- *  eCompressionFormat : Compression format used in this instance of the 
- *                       component. When OMX_IMAGE_CodingUnused is specified, 
+ *  eCompressionFormat : Compression format used in this instance of the
+ *                       component. When OMX_IMAGE_CodingUnused is specified,
  *                       eColorFormat is valid
  *  eColorFormat       : Decompressed format used by this component
  */
@@ -147,8 +147,8 @@
 } OMX_IMAGE_PARAM_PORTFORMATTYPE;
 
 
-/** 
- * Flash control type 
+/**
+ * Flash control type
  *
  * ENUMS
  *  Torch : Flash forced constantly on
@@ -160,14 +160,14 @@
     OMX_IMAGE_FlashControlRedEyeReduction,
     OMX_IMAGE_FlashControlFillin,
     OMX_IMAGE_FlashControlTorch,
-    OMX_IMAGE_FlashControlKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_IMAGE_FlashControlKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
     OMX_IMAGE_FlashControlVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_IMAGE_FlashControlMax = 0x7FFFFFFF
 } OMX_IMAGE_FLASHCONTROLTYPE;
 
 
-/** 
- * Flash control configuration 
+/**
+ * Flash control configuration
  *
  * STRUCT MEMBERS:
  *  nSize         : Size of the structure in bytes
@@ -183,29 +183,29 @@
 } OMX_IMAGE_PARAM_FLASHCONTROLTYPE;
 
 
-/** 
- * Focus control type 
+/**
+ * Focus control type
  */
 typedef enum OMX_IMAGE_FOCUSCONTROLTYPE {
     OMX_IMAGE_FocusControlOn = 0,
     OMX_IMAGE_FocusControlOff,
     OMX_IMAGE_FocusControlAuto,
     OMX_IMAGE_FocusControlAutoLock,
-    OMX_IMAGE_FocusControlKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_IMAGE_FocusControlKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
     OMX_IMAGE_FocusControlVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_IMAGE_FocusControlMax = 0x7FFFFFFF
 } OMX_IMAGE_FOCUSCONTROLTYPE;
 
- 
-/** 
- * Focus control configuration 
+
+/**
+ * Focus control configuration
  *
  * STRUCT MEMBERS:
  *  nSize           : Size of the structure in bytes
  *  nVersion        : OMX specification version information
  *  nPortIndex      : Port that this structure applies to
  *  eFocusControl   : Focus control
- *  nFocusSteps     : Focus can take on values from 0 mm to infinity. 
+ *  nFocusSteps     : Focus can take on values from 0 mm to infinity.
  *                    Interest is only in number of steps over this range.
  *  nFocusStepIndex : Current focus step index
  */
@@ -219,30 +219,30 @@
 } OMX_IMAGE_CONFIG_FOCUSCONTROLTYPE;
 
 
-/** 
+/**
  * Q Factor for JPEG compression, which controls the tradeoff between image
  * quality and size.  Q Factor provides a more simple means of controlling
  * JPEG compression quality, without directly programming Quantization
- * tables for chroma and luma 
+ * tables for chroma and luma
  *
  * STRUCT MEMBERS:
- *  nSize      : Size of the structure in bytes         
- *  nVersion   : OMX specification version information 
- *  nPortIndex : Port that this structure applies to 
- *  nQFactor   : JPEG Q factor value in the range of 1-100. A factor of 1 
- *               produces the smallest, worst quality images, and a factor 
- *               of 100 produces the largest, best quality images.  A 
- *               typical default is 75 for small good quality images               
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to
+ *  nQFactor   : JPEG Q factor value in the range of 1-100. A factor of 1
+ *               produces the smallest, worst quality images, and a factor
+ *               of 100 produces the largest, best quality images.  A
+ *               typical default is 75 for small good quality images
  */
 typedef struct OMX_IMAGE_PARAM_QFACTORTYPE {
-    OMX_U32 nSize;            
-    OMX_VERSIONTYPE nVersion; 
-    OMX_U32 nPortIndex;       
-    OMX_U32 nQFactor;                                        
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nQFactor;
 } OMX_IMAGE_PARAM_QFACTORTYPE;
 
-/** 
- * Quantization table type 
+/**
+ * Quantization table type
  */
 
 typedef enum OMX_IMAGE_QUANTIZATIONTABLETYPE {
@@ -250,27 +250,27 @@
     OMX_IMAGE_QuantizationTableChroma,
     OMX_IMAGE_QuantizationTableChromaCb,
     OMX_IMAGE_QuantizationTableChromaCr,
-    OMX_IMAGE_QuantizationTableKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_IMAGE_QuantizationTableKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
     OMX_IMAGE_QuantizationTableVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_IMAGE_QuantizationTableMax = 0x7FFFFFFF
 } OMX_IMAGE_QUANTIZATIONTABLETYPE;
 
-/** 
+/**
  * JPEG quantization tables are used to determine DCT compression for
- * YUV data, as an alternative to specifying Q factor, providing exact 
- * control of compression 
+ * YUV data, as an alternative to specifying Q factor, providing exact
+ * control of compression
  *
  * STRUCT MEMBERS:
  *  nSize                   : Size of the structure in bytes
- *  nVersion                : OMX specification version information 
+ *  nVersion                : OMX specification version information
  *  nPortIndex              : Port that this structure applies to
  *  eQuantizationTable      : Quantization table type
- *  nQuantizationMatrix[64] : JPEG quantization table of coefficients stored 
- *                            in increasing columns then by rows of data (i.e. 
- *                            row 1, ... row 8). Quantization values are in 
+ *  nQuantizationMatrix[64] : JPEG quantization table of coefficients stored
+ *                            in increasing columns then by rows of data (i.e.
+ *                            row 1, ... row 8). Quantization values are in
  *                            the range 0-255 and stored in linear order
- *                            (i.e. the component will zig-zag the 
- *                            quantization table data if required internally) 
+ *                            (i.e. the component will zig-zag the
+ *                            quantization table data if required internally)
  */
 typedef struct OMX_IMAGE_PARAM_QUANTIZATIONTABLETYPE {
     OMX_U32 nSize;
@@ -281,9 +281,9 @@
 } OMX_IMAGE_PARAM_QUANTIZATIONTABLETYPE;
 
 
-/** 
- * Huffman table type, the same Huffman table is applied for chroma and 
- * luma component 
+/**
+ * Huffman table type, the same Huffman table is applied for chroma and
+ * luma component
  */
 typedef enum OMX_IMAGE_HUFFMANTABLETYPE {
     OMX_IMAGE_HuffmanTableAC = 0,
@@ -292,23 +292,23 @@
     OMX_IMAGE_HuffmanTableACChroma,
     OMX_IMAGE_HuffmanTableDCLuma,
     OMX_IMAGE_HuffmanTableDCChroma,
-    OMX_IMAGE_HuffmanTableKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_IMAGE_HuffmanTableKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
     OMX_IMAGE_HuffmanTableVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_IMAGE_HuffmanTableMax = 0x7FFFFFFF
 } OMX_IMAGE_HUFFMANTABLETYPE;
 
-/** 
- * JPEG Huffman table 
+/**
+ * JPEG Huffman table
  *
  * STRUCT MEMBERS:
  *  nSize                            : Size of the structure in bytes
  *  nVersion                         : OMX specification version information
  *  nPortIndex                       : Port that this structure applies to
  *  eHuffmanTable                    : Huffman table type
- *  nNumberOfHuffmanCodeOfLength[16] : 0-16, number of Huffman codes of each 
+ *  nNumberOfHuffmanCodeOfLength[16] : 0-16, number of Huffman codes of each
  *                                     possible length
- *  nHuffmanTable[256]               : 0-255, the size used for AC and DC 
- *                                     HuffmanTable are 16 and 162 
+ *  nHuffmanTable[256]               : 0-255, the size used for AC and DC
+ *                                     HuffmanTable are 16 and 162
  */
 typedef struct OMX_IMAGE_PARAM_HUFFMANTTABLETYPE {
     OMX_U32 nSize;
@@ -317,7 +317,7 @@
     OMX_IMAGE_HUFFMANTABLETYPE eHuffmanTable;
     OMX_U8 nNumberOfHuffmanCodeOfLength[16];
     OMX_U8 nHuffmanTable[256];
-}OMX_IMAGE_PARAM_HUFFMANTTABLETYPE;
+} OMX_IMAGE_PARAM_HUFFMANTTABLETYPE;
 
 /** @} */
 #ifdef __cplusplus
Index: gst-omx-1.22.0/omx/openmax/OMX_ImageExt.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gst-omx-1.22.0/omx/openmax/OMX_ImageExt.h	2023-03-02 08:58:22.000000000 +0000
@@ -0,0 +1,55 @@
+/*
+ * Copyright (c) 2016 The Khronos Group Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions:
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+/** OMX_ImageExt.h - OpenMax IL version 1.1.2
+ * The OMX_ImageExt header file contains extensions to the
+ * definitions used by both the application and the component to
+ * access image items.
+ */
+
+#ifndef OMX_ImageExt_h
+#define OMX_ImageExt_h
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/* Each OMX header shall include all required header files to allow the
+ * header to compile without errors.  The includes below are required
+ * for this header file to compile successfully
+ */
+#include <OMX_Core.h>
+
+/** Enum for standard image codingtype extensions */
+typedef enum OMX_IMAGE_CODINGEXTTYPE {
+    OMX_IMAGE_CodingExtUnused = OMX_IMAGE_CodingKhronosExtensions,
+    OMX_IMAGE_CodingWEBP,         /**< WebP image format */
+} OMX_IMAGE_CODINGEXTTYPE;
+
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* OMX_ImageExt_h */
+/* File EOF */
Index: gst-omx-1.22.0/omx/openmax/OMX_Index.h
===================================================================
--- gst-omx-1.22.0.orig/omx/openmax/OMX_Index.h	2023-03-02 08:48:43.000000000 +0000
+++ gst-omx-1.22.0/omx/openmax/OMX_Index.h	2023-03-02 08:58:22.000000000 +0000
@@ -1,23 +1,23 @@
 /*
- * Copyright (c) 2008 The Khronos Group Inc. 
- * 
+ * Copyright (c) 2008 The Khronos Group Inc.
+ *
  * Permission is hereby granted, free of charge, to any person obtaining
  * a copy of this software and associated documentation files (the
  * "Software"), to deal in the Software without restriction, including
  * without limitation the rights to use, copy, modify, merge, publish,
  * distribute, sublicense, and/or sell copies of the Software, and to
  * permit persons to whom the Software is furnished to do so, subject
- * to the following conditions: 
+ * to the following conditions:
  * The above copyright notice and this permission notice shall be included
- * in all copies or substantial portions of the Software. 
- * 
+ * in all copies or substantial portions of the Software.
+ *
  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
  * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
  * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  *
  */
 
@@ -37,22 +37,22 @@
 
 /* Each OMX header must include all required header files to allow the
  *  header to compile without errors.  The includes below are required
- *  for this header file to compile successfully 
+ *  for this header file to compile successfully
  */
 #include <OMX_Types.h>
 
 
 /** The OMX_INDEXTYPE enumeration is used to select a structure when either
- *  getting or setting parameters and/or configuration data.  Each entry in 
- *  this enumeration maps to an OMX specified structure.  When the 
+ *  getting or setting parameters and/or configuration data.  Each entry in
+ *  this enumeration maps to an OMX specified structure.  When the
  *  OMX_GetParameter, OMX_SetParameter, OMX_GetConfig or OMX_SetConfig methods
  *  are used, the second parameter will always be an entry from this enumeration
  *  and the third entry will be the structure shown in the comments for the entry.
- *  For example, if the application is initializing a cropping function, the 
- *  OMX_SetConfig command would have OMX_IndexConfigCommonInputCrop as the second parameter 
- *  and would send a pointer to an initialized OMX_RECTTYPE structure as the 
+ *  For example, if the application is initializing a cropping function, the
+ *  OMX_SetConfig command would have OMX_IndexConfigCommonInputCrop as the second parameter
+ *  and would send a pointer to an initialized OMX_RECTTYPE structure as the
  *  third parameter.
- *  
+ *
  *  The enumeration entries named with the OMX_Config prefix are sent using
  *  the OMX_SetConfig command and the enumeration entries named with the
  *  OMX_PARAM_ prefix are sent using the OMX_SetParameter command.
@@ -69,11 +69,11 @@
     OMX_IndexParamActiveStream,             /**< reference: OMX_PARAM_U32TYPE */
     OMX_IndexParamSuspensionPolicy,         /**< reference: OMX_PARAM_SUSPENSIONPOLICYTYPE */
     OMX_IndexParamComponentSuspended,       /**< reference: OMX_PARAM_SUSPENSIONTYPE */
-    OMX_IndexConfigCapturing,               /**< reference: OMX_CONFIG_BOOLEANTYPE */ 
-    OMX_IndexConfigCaptureMode,             /**< reference: OMX_CONFIG_CAPTUREMODETYPE */ 
-    OMX_IndexAutoPauseAfterCapture,         /**< reference: OMX_CONFIG_BOOLEANTYPE */ 
+    OMX_IndexConfigCapturing,               /**< reference: OMX_CONFIG_BOOLEANTYPE */
+    OMX_IndexConfigCaptureMode,             /**< reference: OMX_CONFIG_CAPTUREMODETYPE */
+    OMX_IndexAutoPauseAfterCapture,         /**< reference: OMX_CONFIG_BOOLEANTYPE */
     OMX_IndexParamContentURI,               /**< reference: OMX_PARAM_CONTENTURITYPE */
-    OMX_IndexParamCustomContentPipe,        /**< reference: OMX_PARAM_CONTENTPIPETYPE */ 
+    OMX_IndexParamCustomContentPipe,        /**< reference: OMX_PARAM_CONTENTPIPETYPE */
     OMX_IndexParamDisableResourceConcealment, /**< reference: OMX_RESOURCECONCEALMENTTYPE */
     OMX_IndexConfigMetadataItemCount,       /**< reference: OMX_CONFIG_METADATAITEMCOUNTTYPE */
     OMX_IndexConfigContainerNodeCount,      /**< reference: OMX_CONFIG_CONTAINERNODECOUNTTYPE */
@@ -86,7 +86,7 @@
 
     OMX_IndexPortStartUnused = 0x02000000,
     OMX_IndexParamPortDefinition,           /**< reference: OMX_PARAM_PORTDEFINITIONTYPE */
-    OMX_IndexParamCompBufferSupplier,       /**< reference: OMX_PARAM_BUFFERSUPPLIERTYPE */ 
+    OMX_IndexParamCompBufferSupplier,       /**< reference: OMX_PARAM_BUFFERSUPPLIERTYPE */
     OMX_IndexReservedStartUnused = 0x03000000,
 
     /* Audio parameters and configurations */
@@ -238,10 +238,12 @@
     OMX_IndexConfigTimeSeekMode,            /**< reference: OMX_TIME_CONFIG_SEEKMODETYPE */
 
 
-    OMX_IndexKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_IndexKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
     /* Vendor specific area */
+    OMX_IndexRockchipExtensions = 0x70000000, /**< Reserved region for introducing Rockchip Standard Extensions */
+    OMX_IndexParamVideoHDRRockchipExtensions,  /**< reference: OMX_EXTENSION_VIDEO_PARAM_HDR */
     OMX_IndexVendorStartUnused = 0x7F000000,
-    /* Vendor specific structures should be in the range of 0x7F000000 
+    /* Vendor specific structures should be in the range of 0x7F000000
        to 0x7FFFFFFE.  This range is not broken out by vendor, so
        private indexes are not guaranteed unique and therefore should
        only be sent to the appropriate component. */
Index: gst-omx-1.22.0/omx/openmax/OMX_IndexExt.h
===================================================================
--- gst-omx-1.22.0.orig/omx/openmax/OMX_IndexExt.h	2023-03-02 08:48:43.000000000 +0000
+++ gst-omx-1.22.0/omx/openmax/OMX_IndexExt.h	2023-03-02 08:58:22.000000000 +0000
@@ -1,87 +1,105 @@
-/*
- * Copyright (c) 2010 The Khronos Group Inc. 
- * 
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject
- * to the following conditions: 
- * The above copyright notice and this permission notice shall be included
- * in all copies or substantial portions of the Software. 
- * 
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
- * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
- * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
- *
- */
-
-/** @file OMX_IndexExt.h - OpenMax IL version 1.1.2
- * The OMX_IndexExt header file contains extensions to the definitions 
- * for both applications and components .
- */
-
-#ifndef OMX_IndexExt_h
-#define OMX_IndexExt_h
-
-#ifdef __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-
-/* Each OMX header shall include all required header files to allow the
- * header to compile without errors.  The includes below are required
- * for this header file to compile successfully
- */
-#include <OMX_Index.h>
-
-
-/** Khronos standard extension indices.
-
-This enum lists the current Khronos extension indices to OpenMAX IL.
-*/
-typedef enum OMX_INDEXEXTTYPE {
-
-    /* Component parameters and configurations */
-    OMX_IndexExtComponentStartUnused = OMX_IndexKhronosExtensions + 0x00100000,
-    OMX_IndexConfigCallbackRequest,                 /**< reference: OMX_CONFIG_CALLBACKREQUESTTYPE */
-    OMX_IndexConfigCommitMode,                      /**< reference: OMX_CONFIG_COMMITMODETYPE */
-    OMX_IndexConfigCommit,                          /**< reference: OMX_CONFIG_COMMITTYPE */
-
-    /* Port parameters and configurations */
-    OMX_IndexExtPortStartUnused = OMX_IndexKhronosExtensions + 0x00200000,
-
-    /* Audio parameters and configurations */
-    OMX_IndexExtAudioStartUnused = OMX_IndexKhronosExtensions + 0x00400000,
-
-    /* Image parameters and configurations */
-    OMX_IndexExtImageStartUnused = OMX_IndexKhronosExtensions + 0x00500000,
-
-    /* Video parameters and configurations */
-    OMX_IndexExtVideoStartUnused = OMX_IndexKhronosExtensions + 0x00600000,
-    OMX_IndexParamNalStreamFormatSupported,         /**< reference: OMX_NALSTREAMFORMATTYPE */
-    OMX_IndexParamNalStreamFormat,                  /**< reference: OMX_NALSTREAMFORMATTYPE */
-    OMX_IndexParamNalStreamFormatSelect,            /**< reference: OMX_NALSTREAMFORMATTYPE */
-
-    /* Image & Video common configurations */
-    OMX_IndexExtCommonStartUnused = OMX_IndexKhronosExtensions + 0x00700000,
-
-    /* Other configurations */
-    OMX_IndexExtOtherStartUnused = OMX_IndexKhronosExtensions + 0x00800000,
-
-    /* Time configurations */
-    OMX_IndexExtTimeStartUnused = OMX_IndexKhronosExtensions + 0x00900000,
-
-    OMX_IndexExtMax = 0x7FFFFFFF
-} OMX_INDEXEXTTYPE;
-
-#ifdef __cplusplus
-}
-#endif /* __cplusplus */
-
-#endif /* OMX_IndexExt_h */
-/* File EOF */
+/*
+ * Copyright (c) 2010 The Khronos Group Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions:
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+/** @file OMX_IndexExt.h - OpenMax IL version 1.1.2
+ * The OMX_IndexExt header file contains extensions to the definitions
+ * for both applications and components .
+ */
+
+#ifndef OMX_IndexExt_h
+#define OMX_IndexExt_h
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/* Each OMX header shall include all required header files to allow the
+ * header to compile without errors.  The includes below are required
+ * for this header file to compile successfully
+ */
+#include <OMX_Index.h>
+
+
+/** Khronos standard extension indices.
+
+This enum lists the current Khronos extension indices to OpenMAX IL.
+*/
+typedef enum OMX_INDEXEXTTYPE {
+
+    /* Component parameters and configurations */
+    OMX_IndexExtComponentStartUnused = OMX_IndexKhronosExtensions + 0x00100000,
+    OMX_IndexConfigCallbackRequest,                 /**< reference: OMX_CONFIG_CALLBACKREQUESTTYPE */
+    OMX_IndexConfigCommitMode,                      /**< reference: OMX_CONFIG_COMMITMODETYPE */
+    OMX_IndexConfigCommit,                          /**< reference: OMX_CONFIG_COMMITTYPE */
+
+    /* Port parameters and configurations */
+    OMX_IndexExtPortStartUnused = OMX_IndexKhronosExtensions + 0x00200000,
+
+    /* Audio parameters and configurations */
+    OMX_IndexExtAudioStartUnused = OMX_IndexKhronosExtensions + 0x00400000,
+    OMX_IndexParamAudioAndroidAc3,                  /**< reference: OMX_AUDIO_PARAM_ANDROID_AC3TYPE */
+    OMX_IndexParamAudioAndroidOpus,                 /**< reference: OMX_AUDIO_PARAM_ANDROID_OPUSTYPE */
+    OMX_IndexParamAudioAndroidAacPresentation,      /**< reference: OMX_AUDIO_PARAM_ANDROID_AACPRESENTATIONTYPE */
+    OMX_IndexParamAudioAndroidEac3,                 /**< reference: OMX_AUDIO_PARAM_ANDROID_EAC3TYPE */
+    OMX_IndexParamAudioProfileQuerySupported,       /**< reference: OMX_AUDIO_PARAM_ANDROID_PROFILETYPE */
+
+    /* Image parameters and configurations */
+    OMX_IndexExtImageStartUnused = OMX_IndexKhronosExtensions + 0x00500000,
+
+    /* Video parameters and configurations */
+    OMX_IndexExtVideoStartUnused = OMX_IndexKhronosExtensions + 0x00600000,
+    OMX_IndexParamNalStreamFormatSupported,         /**< reference: OMX_NALSTREAMFORMATTYPE */
+    OMX_IndexParamNalStreamFormat,                  /**< reference: OMX_NALSTREAMFORMATTYPE */
+    OMX_IndexParamNalStreamFormatSelect,            /**< reference: OMX_NALSTREAMFORMATTYPE */
+    OMX_IndexParamVideoVp8,                         /**< reference: OMX_VIDEO_PARAM_VP8TYPE */
+    OMX_IndexConfigVideoVp8ReferenceFrame,          /**< reference: OMX_VIDEO_VP8REFERENCEFRAMETYPE */
+    OMX_IndexConfigVideoVp8ReferenceFrameType,      /**< reference: OMX_VIDEO_VP8REFERENCEFRAMEINFOTYPE */
+    OMX_IndexParamVideoAndroidVp8Encoder,           /**< reference: OMX_VIDEO_PARAM_ANDROID_VP8ENCODERTYPE */
+    OMX_IndexParamVideoHevc,                        /**< reference: OMX_VIDEO_PARAM_HEVCTYPE */
+    OMX_IndexParamSliceSegments,                    /**< reference: OMX_VIDEO_SLICESEGMENTSTYPE */
+    OMX_IndexConfigAndroidIntraRefresh,             /**< reference: OMX_VIDEO_CONFIG_ANDROID_INTRAREFRESHTYPE */
+    OMX_IndexParamAndroidVideoTemporalLayering,     /**< reference: OMX_VIDEO_PARAM_ANDROID_TEMPORALLAYERINGTYPE */
+    OMX_IndexConfigAndroidVideoTemporalLayering,    /**< reference: OMX_VIDEO_CONFIG_ANDROID_TEMPORALLAYERINGTYPE */
+
+    /* Image & Video common configurations */
+    OMX_IndexExtCommonStartUnused = OMX_IndexKhronosExtensions + 0x00700000,
+
+    /* Other configurations */
+    OMX_IndexExtOtherStartUnused = OMX_IndexKhronosExtensions + 0x00800000,
+    OMX_IndexConfigAutoFramerateConversion,         /**< reference: OMX_CONFIG_BOOLEANTYPE */
+    OMX_IndexConfigPriority,                        /**< reference: OMX_PARAM_U32TYPE */
+    OMX_IndexConfigOperatingRate,                   /**< reference: OMX_PARAM_U32TYPE in Q16 format for video and in Hz for audio */
+    OMX_IndexParamConsumerUsageBits,                /**< reference: OMX_PARAM_U32TYPE */
+
+    /* Time configurations */
+    OMX_IndexExtTimeStartUnused = OMX_IndexKhronosExtensions + 0x00900000,
+
+    OMX_IndexExtMax = 0x7FFFFFFF
+} OMX_INDEXEXTTYPE;
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* OMX_IndexExt_h */
+/* File EOF */
Index: gst-omx-1.22.0/omx/openmax/OMX_Other.h
===================================================================
--- gst-omx-1.22.0.orig/omx/openmax/OMX_Other.h	2023-03-02 08:48:43.000000000 +0000
+++ gst-omx-1.22.0/omx/openmax/OMX_Other.h	2023-03-02 08:58:22.000000000 +0000
@@ -1,23 +1,23 @@
 /*
- * Copyright (c) 2008 The Khronos Group Inc. 
- * 
+ * Copyright (c) 2008 The Khronos Group Inc.
+ *
  * Permission is hereby granted, free of charge, to any person obtaining
  * a copy of this software and associated documentation files (the
  * "Software"), to deal in the Software without restriction, including
  * without limitation the rights to use, copy, modify, merge, publish,
  * distribute, sublicense, and/or sell copies of the Software, and to
  * permit persons to whom the Software is furnished to do so, subject
- * to the following conditions: 
+ * to the following conditions:
  * The above copyright notice and this permission notice shall be included
- * in all copies or substantial portions of the Software. 
- * 
+ * in all copies or substantial portions of the Software.
+ *
  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
  * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
  * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  *
  */
 
@@ -36,46 +36,46 @@
 
 /* Each OMX header must include all required header files to allow the
  *  header to compile without errors.  The includes below are required
- *  for this header file to compile successfully 
+ *  for this header file to compile successfully
  */
 
 #include <OMX_Core.h>
 
 
-/** 
+/**
  * Enumeration of possible data types which match to multiple domains or no
  * domain at all.  For types which are vendor specific, a value above
  * OMX_OTHER_VENDORTSTART should be used.
  */
 typedef enum OMX_OTHER_FORMATTYPE {
-    OMX_OTHER_FormatTime = 0, /**< Transmission of various timestamps, elapsed time, 
+    OMX_OTHER_FormatTime = 0, /**< Transmission of various timestamps, elapsed time,
                                    time deltas, etc */
-    OMX_OTHER_FormatPower,    /**< Perhaps used for enabling/disabling power 
+                           OMX_OTHER_FormatPower,    /**< Perhaps used for enabling/disabling power
                                    management, setting clocks? */
-    OMX_OTHER_FormatStats,    /**< Could be things such as frame rate, frames 
+                           OMX_OTHER_FormatStats,    /**< Could be things such as frame rate, frames
                                    dropped, etc */
-    OMX_OTHER_FormatBinary,   /**< Arbitrary binary data */
-    OMX_OTHER_FormatVendorReserved = 1000, /**< Starting value for vendor specific 
+                           OMX_OTHER_FormatBinary,   /**< Arbitrary binary data */
+                           OMX_OTHER_FormatVendorReserved = 1000, /**< Starting value for vendor specific
                                                 formats */
 
-    OMX_OTHER_FormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
-    OMX_OTHER_FormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_OTHER_FormatMax = 0x7FFFFFFF
+                                                            OMX_OTHER_FormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+                                                            OMX_OTHER_FormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+                                                            OMX_OTHER_FormatMax = 0x7FFFFFFF
 } OMX_OTHER_FORMATTYPE;
 
-/** 
+/**
  * Enumeration of seek modes.
  */
 typedef enum OMX_TIME_SEEKMODETYPE {
     OMX_TIME_SeekModeFast = 0, /**< Prefer seeking to an approximation
-                                * of the requested seek position over   
+                                * of the requested seek position over
                                 * the actual seek position if it
                                 * results in a faster seek. */
-    OMX_TIME_SeekModeAccurate, /**< Prefer seeking to the actual seek 
+    OMX_TIME_SeekModeAccurate, /**< Prefer seeking to the actual seek
                                 * position over an approximation
                                 * of the requested seek position even
                                 * if it results in a slower seek. */
-    OMX_TIME_SeekModeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_TIME_SeekModeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
     OMX_TIME_SeekModeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_TIME_SeekModeMax = 0x7FFFFFFF
 } OMX_TIME_SEEKMODETYPE;
@@ -87,66 +87,95 @@
     OMX_TIME_SEEKMODETYPE eType;    /**< The seek mode */
 } OMX_TIME_CONFIG_SEEKMODETYPE;
 
-/** Structure representing a time stamp used with the following configs 
+/**
+ * colorspace 
+ */
+typedef enum OMX_ROCKCHIP_EXT_COLORSPACE {
+    OMX_RK_EXT_ColorspaceBT709 = 1,
+    OMX_RK_EXT_ColorspaceBT2020,
+    OMX_RK_EXT_ColorspaceMax = 0x7FFFFFFF
+} OMX_RK_EXT_COLORSPACE;
+
+/**
+ * dynamic range
+ */
+typedef enum OMX_ROCKCHIP_EXT_DYNCRANGE {
+    OMX_RK_EXT_DyncrangeSDR = 0,
+    OMX_RK_EXT_DyncrangeHDR10,
+    OMX_RK_EXT_DyncrangeHDRHLG,
+    OMX_RK_EXT_DyncrangeHDRDOLBY,
+    OMX_RK_EXT_DyncrangeMax = 0x7FFFFFFF
+} OMX_RK_EXT_DYNCRANGE;
+
+
+/* Structure Rockchip extension HDR param of the component */
+ typedef struct OMX_EXTENSION_VIDEO_PARAM_HDR {
+    OMX_U32 nSize;                  /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;       /**< OMX specification version information */
+    OMX_RK_EXT_COLORSPACE eColorSpace;    /**< Color space */
+    OMX_RK_EXT_DYNCRANGE eDyncRange;    /**< dynamic range */
+} OMX_EXTENSION_VIDEO_PARAM_HDR;
+
+/** Structure representing a time stamp used with the following configs
  * on the Clock Component (CC):
- * 
- * OMX_IndexConfigTimeCurrentWallTime: query of the CCs current wall  
+ *
+ * OMX_IndexConfigTimeCurrentWallTime: query of the CCs current wall
  *     time
  * OMX_IndexConfigTimeCurrentMediaTime: query of the CCs current media
  *     time
- * OMX_IndexConfigTimeCurrentAudioReference and  
- * OMX_IndexConfigTimeCurrentVideoReference: audio/video reference 
+ * OMX_IndexConfigTimeCurrentAudioReference and
+ * OMX_IndexConfigTimeCurrentVideoReference: audio/video reference
  *     clock sending SC its reference time
- * OMX_IndexConfigTimeClientStartTime: a Clock Component client sends 
- *     this structure to the Clock Component via a SetConfig on its 
+ * OMX_IndexConfigTimeClientStartTime: a Clock Component client sends
+ *     this structure to the Clock Component via a SetConfig on its
  *     client port when it receives a buffer with
  *     OMX_BUFFERFLAG_STARTTIME set. It must use the timestamp
- *     specified by that buffer for nStartTimestamp. 
+ *     specified by that buffer for nStartTimestamp.
  *
  * Its also used with the following config on components in general:
  *
- * OMX_IndexConfigTimePosition: IL client querying component position 
+ * OMX_IndexConfigTimePosition: IL client querying component position
  * (GetConfig) or commanding a component to seek to the given location
  * (SetConfig)
- */	
+ */
 typedef struct OMX_TIME_CONFIG_TIMESTAMPTYPE {
     OMX_U32 nSize;               /**< size of the structure in bytes */
     OMX_VERSIONTYPE nVersion;    /**< OMX specification version
                                   *   information */
     OMX_U32 nPortIndex;     /**< port that this structure applies to */
-    OMX_TICKS nTimestamp;  	     /**< timestamp .*/ 
-} OMX_TIME_CONFIG_TIMESTAMPTYPE;  
+    OMX_TICKS nTimestamp;        /**< timestamp .*/
+} OMX_TIME_CONFIG_TIMESTAMPTYPE;
 
 /** Enumeration of possible reference clocks to the media time. */
 typedef enum OMX_TIME_UPDATETYPE {
-      OMX_TIME_UpdateRequestFulfillment,    /**< Update is the fulfillment of a media time request. */
-      OMX_TIME_UpdateScaleChanged,	        /**< Update was generated because the scale chagned. */
-      OMX_TIME_UpdateClockStateChanged,     /**< Update was generated because the clock state changed. */
-      OMX_TIME_UpdateKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
-      OMX_TIME_UpdateVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-      OMX_TIME_UpdateMax = 0x7FFFFFFF
+    OMX_TIME_UpdateRequestFulfillment,    /**< Update is the fulfillment of a media time request. */
+    OMX_TIME_UpdateScaleChanged,          /**< Update was generated because the scale chagned. */
+    OMX_TIME_UpdateClockStateChanged,     /**< Update was generated because the clock state changed. */
+    OMX_TIME_UpdateKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_TIME_UpdateVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_TIME_UpdateMax = 0x7FFFFFFF
 } OMX_TIME_UPDATETYPE;
 
 /** Enumeration of possible reference clocks to the media time. */
 typedef enum OMX_TIME_REFCLOCKTYPE {
-      OMX_TIME_RefClockNone,    /**< Use no references. */
-      OMX_TIME_RefClockAudio,	/**< Use references sent through OMX_IndexConfigTimeCurrentAudioReference */
-      OMX_TIME_RefClockVideo,   /**< Use references sent through OMX_IndexConfigTimeCurrentVideoReference */
-      OMX_TIME_RefClockKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
-      OMX_TIME_RefClockVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-      OMX_TIME_RefClockMax = 0x7FFFFFFF
+    OMX_TIME_RefClockNone,    /**< Use no references. */
+    OMX_TIME_RefClockAudio,   /**< Use references sent through OMX_IndexConfigTimeCurrentAudioReference */
+    OMX_TIME_RefClockVideo,   /**< Use references sent through OMX_IndexConfigTimeCurrentVideoReference */
+    OMX_TIME_RefClockKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_TIME_RefClockVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_TIME_RefClockMax = 0x7FFFFFFF
 } OMX_TIME_REFCLOCKTYPE;
 
 /** Enumeration of clock states. */
 typedef enum OMX_TIME_CLOCKSTATE {
-      OMX_TIME_ClockStateRunning,             /**< Clock running. */
-      OMX_TIME_ClockStateWaitingForStartTime, /**< Clock waiting until the 
+    OMX_TIME_ClockStateRunning,             /**< Clock running. */
+    OMX_TIME_ClockStateWaitingForStartTime, /**< Clock waiting until the
                                                *   prescribed clients emit their
                                                *   start time. */
-      OMX_TIME_ClockStateStopped,             /**< Clock stopped. */
-      OMX_TIME_ClockStateKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
-      OMX_TIME_ClockStateVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-      OMX_TIME_ClockStateMax = 0x7FFFFFFF
+    OMX_TIME_ClockStateStopped,             /**< Clock stopped. */
+    OMX_TIME_ClockStateKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    OMX_TIME_ClockStateVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_TIME_ClockStateMax = 0x7FFFFFFF
 } OMX_TIME_CLOCKSTATE;
 
 /** Structure representing a media time request to the clock component.
@@ -154,18 +183,18 @@
  *  A client component sends this structure to the Clock Component via a SetConfig
  *  on its client port to specify a media timestamp the Clock Component
  *  should emit.  The Clock Component should fulfill the request by sending a
- *  OMX_TIME_MEDIATIMETYPE when its media clock matches the requested 
+ *  OMX_TIME_MEDIATIMETYPE when its media clock matches the requested
  *  timestamp.
  *
  *  The client may require a media time request be fulfilled slightly
- *  earlier than the media time specified. In this case the client specifies 
- *  an offset which is equal to the difference between wall time corresponding 
- *  to the requested media time and the wall time when it will be 
- *  fulfilled. 
+ *  earlier than the media time specified. In this case the client specifies
+ *  an offset which is equal to the difference between wall time corresponding
+ *  to the requested media time and the wall time when it will be
+ *  fulfilled.
  *
  *  A client component may uses these requests and the OMX_TIME_MEDIATIMETYPE to
  *  time events according to timestamps. If a client must perform an operation O at
- *  a time T (e.g. deliver a video frame at its corresponding timestamp), it makes a 
+ *  a time T (e.g. deliver a video frame at its corresponding timestamp), it makes a
  *  media time request at T (perhaps specifying an offset to ensure the request fulfillment
  *  is a little early). When the clock component passes the resulting OMX_TIME_MEDIATIMETYPE
  *  structure back to the client component, the client may perform operation O (perhaps having
@@ -176,52 +205,52 @@
     OMX_U32 nSize;              /**< size of the structure in bytes */
     OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
     OMX_U32 nPortIndex;         /**< port that this structure applies to */
-    OMX_PTR pClientPrivate;     /**< Client private data to disabiguate this media time 
-                                 *   from others (e.g. the number of the frame to deliver). 
-                                 *   Duplicated in the media time structure that fulfills 
-                                 *   this request. A value of zero is reserved for time scale 
+    OMX_PTR pClientPrivate;     /**< Client private data to disabiguate this media time
+                                 *   from others (e.g. the number of the frame to deliver).
+                                 *   Duplicated in the media time structure that fulfills
+                                 *   this request. A value of zero is reserved for time scale
                                  *   updates. */
-    OMX_TICKS nMediaTimestamp;  /**< Media timestamp requested.*/ 
+    OMX_TICKS nMediaTimestamp;  /**< Media timestamp requested.*/
     OMX_TICKS nOffset;          /**< Amount of wall clock time by which this
                                  *   request should be fulfilled early */
 } OMX_TIME_CONFIG_MEDIATIMEREQUESTTYPE;
 
-/**< Structure sent from the clock component client either when fulfilling 
- *   a media time request or when the time scale has changed. 
+/**< Structure sent from the clock component client either when fulfilling
+ *   a media time request or when the time scale has changed.
  *
- *   In the former case the Clock Component fills this structure and times its emission 
- *   to a client component (via the client port) according to the corresponding media 
+ *   In the former case the Clock Component fills this structure and times its emission
+ *   to a client component (via the client port) according to the corresponding media
  *   time request sent by the client. The Clock Component should time the emission to occur
- *   when the requested timestamp matches the Clock Component's media time but also the 
- *   prescribed offset early. 
+ *   when the requested timestamp matches the Clock Component's media time but also the
+ *   prescribed offset early.
  *
  *   Upon scale changes the clock component clears the nClientPrivate data, sends the current
- *   media time and sets the nScale to the new scale via the client port. It emits a 
- *   OMX_TIME_MEDIATIMETYPE to all clients independent of any requests. This allows clients to 
- *   alter processing to accomodate scaling. For instance a video component might skip inter-frames 
- *   in the case of extreme fastforward. Likewise an audio component might add or remove samples 
- *   from an audio frame to scale audio data. 
+ *   media time and sets the nScale to the new scale via the client port. It emits a
+ *   OMX_TIME_MEDIATIMETYPE to all clients independent of any requests. This allows clients to
+ *   alter processing to accomodate scaling. For instance a video component might skip inter-frames
+ *   in the case of extreme fastforward. Likewise an audio component might add or remove samples
+ *   from an audio frame to scale audio data.
  *
  *   It is expected that some clock components may not be able to fulfill requests
- *   at exactly the prescribed time. This is acceptable so long as the request is 
- *   fulfilled at least as early as described and not later. This structure provides 
+ *   at exactly the prescribed time. This is acceptable so long as the request is
+ *   fulfilled at least as early as described and not later. This structure provides
  *   fields the client may use to wait for the remaining time.
  *
- *   The client may use either the nOffset or nWallTimeAtMedia fields to determine the 
+ *   The client may use either the nOffset or nWallTimeAtMedia fields to determine the
  *   wall time until the nMediaTimestamp actually occurs. In the latter case the
  *   client can get a more accurate value for offset by getting the current wall
- *   from the cloc component and subtracting it from nWallTimeAtMedia. 
+ *   from the cloc component and subtracting it from nWallTimeAtMedia.
  */
 
 typedef struct OMX_TIME_MEDIATIMETYPE {
     OMX_U32 nSize;                  /**< size of the structure in bytes */
     OMX_VERSIONTYPE nVersion;       /**< OMX specification version information */
-    OMX_U32 nClientPrivate;         /**< Client private data to disabiguate this media time 
-                                     *   from others. Copied from the media time request. 
+    OMX_U32 nClientPrivate;         /**< Client private data to disabiguate this media time
+                                     *   from others. Copied from the media time request.
                                      *   A value of zero is reserved for time scale updates. */
     OMX_TIME_UPDATETYPE eUpdateType; /**< Reason for the update */
-    OMX_TICKS nMediaTimestamp;      /**< Media time requested. If no media time was 
-                                     *   requested then this is the current media time. */ 
+    OMX_TICKS nMediaTimestamp;      /**< Media time requested. If no media time was
+                                     *   requested then this is the current media time. */
     OMX_TICKS nOffset;              /**< Amount of wall clock time by which this
                                      *   request was actually fulfilled early */
 
@@ -232,21 +261,21 @@
                                      *   current. */
     OMX_S32 xScale;                 /**< Current media time scale in Q16 format. */
     OMX_TIME_CLOCKSTATE eState;     /* Seeking Change. Added 7/12.*/
-                                    /**< State of the media time. */
-} OMX_TIME_MEDIATIMETYPE;  
+    /**< State of the media time. */
+} OMX_TIME_MEDIATIMETYPE;
 
-/** Structure representing the current media time scale factor. Applicable only to clock 
+/** Structure representing the current media time scale factor. Applicable only to clock
  *  component, other components see scale changes via OMX_TIME_MEDIATIMETYPE buffers sent via
- *  the clock component client ports. Upon recieving this config the clock component changes 
- *  the rate by which the media time increases or decreases effectively implementing trick modes. 
- */ 
+ *  the clock component client ports. Upon recieving this config the clock component changes
+ *  the rate by which the media time increases or decreases effectively implementing trick modes.
+ */
 typedef struct OMX_TIME_CONFIG_SCALETYPE {
     OMX_U32 nSize;                  /**< size of the structure in bytes */
     OMX_VERSIONTYPE nVersion;       /**< OMX specification version information */
     OMX_S32 xScale;                 /**< This is a value in Q16 format which is used for
                                      * scaling the media time */
 } OMX_TIME_CONFIG_SCALETYPE;
- 
+
 /** Bits used to identify a clock port. Used in OMX_TIME_CONFIG_CLOCKSTATETYPEs nWaitMask field */
 #define OMX_CLOCKPORT0 0x00000001
 #define OMX_CLOCKPORT1 0x00000002
@@ -257,38 +286,38 @@
 #define OMX_CLOCKPORT6 0x00000040
 #define OMX_CLOCKPORT7 0x00000080
 
-/** Structure representing the current mode of the media clock. 
- *  IL Client uses this config to change or query the mode of the 
+/** Structure representing the current mode of the media clock.
+ *  IL Client uses this config to change or query the mode of the
  *  media clock of the clock component. Applicable only to clock
- *  component. 
- *  
+ *  component.
+ *
  *  On a SetConfig if eState is OMX_TIME_ClockStateRunning media time
  *  starts immediately at the prescribed start time. If
  *  OMX_TIME_ClockStateWaitingForStartTime the Clock Component ignores
- *  the given nStartTime and waits for all clients specified in the 
- *  nWaitMask to send starttimes (via 
- *  OMX_IndexConfigTimeClientStartTime). The Clock Component then starts 
- *  the media clock using the earliest start time supplied. */    
+ *  the given nStartTime and waits for all clients specified in the
+ *  nWaitMask to send starttimes (via
+ *  OMX_IndexConfigTimeClientStartTime). The Clock Component then starts
+ *  the media clock using the earliest start time supplied. */
 typedef struct OMX_TIME_CONFIG_CLOCKSTATETYPE {
     OMX_U32 nSize;              /**< size of the structure in bytes */
-    OMX_VERSIONTYPE nVersion;   /**< OMX specification version 
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version
                                  *   information */
     OMX_TIME_CLOCKSTATE eState; /**< State of the media time. */
     OMX_TICKS nStartTime;       /**< Start time of the media time. */
-    OMX_TICKS nOffset;          /**< Time to offset the media time by 
+    OMX_TICKS nOffset;          /**< Time to offset the media time by
                                  * (e.g. preroll). Media time will be
-                                 * reported to be nOffset ticks earlier.     
+                                 * reported to be nOffset ticks earlier.
                                  */
     OMX_U32 nWaitMask;          /**< Mask of OMX_CLOCKPORT values. */
 } OMX_TIME_CONFIG_CLOCKSTATETYPE;
 
 /** Structure representing the reference clock currently being used to
- *  compute media time. IL client uses this config to change or query the 
+ *  compute media time. IL client uses this config to change or query the
  *  clock component's active reference clock */
 typedef struct OMX_TIME_CONFIG_ACTIVEREFCLOCKTYPE {
     OMX_U32 nSize;                  /**< size of the structure in bytes */
     OMX_VERSIONTYPE nVersion;       /**< OMX specification version information */
-    OMX_TIME_REFCLOCKTYPE eClock;   /**< Reference clock used to compute media time */                        
+    OMX_TIME_REFCLOCKTYPE eClock;   /**< Reference clock used to compute media time */
 } OMX_TIME_CONFIG_ACTIVEREFCLOCKTYPE;
 
 /** Descriptor for setting specifics of power type.
@@ -310,8 +339,8 @@
 
 
 /**
- * The PortDefinition structure is used to define all of the parameters 
- * necessary for the compliant component to setup an input or an output other 
+ * The PortDefinition structure is used to define all of the parameters
+ * necessary for the compliant component to setup an input or an output other
  * path.
  */
 typedef struct OMX_OTHER_PORTDEFINITIONTYPE {
@@ -327,7 +356,7 @@
     OMX_U32 nPortIndex; /**< Indicates which port to set */
     OMX_U32 nIndex; /**< Indicates the enumeration index for the format from 0x0 to N-1 */
     OMX_OTHER_FORMATTYPE eFormat; /**< Type of data expected for this channel */
-} OMX_OTHER_PARAM_PORTFORMATTYPE; 
+} OMX_OTHER_PARAM_PORTFORMATTYPE;
 
 #ifdef __cplusplus
 }
Index: gst-omx-1.22.0/omx/openmax/OMX_Types.h
===================================================================
--- gst-omx-1.22.0.orig/omx/openmax/OMX_Types.h	2023-03-02 08:48:43.000000000 +0000
+++ gst-omx-1.22.0/omx/openmax/OMX_Types.h	2023-03-02 08:58:22.000000000 +0000
@@ -1,36 +1,38 @@
 /*
- * Copyright (c) 2008 The Khronos Group Inc. 
- * 
+ * Copyright (c) 2016 The Khronos Group Inc.
+ *
  * Permission is hereby granted, free of charge, to any person obtaining
  * a copy of this software and associated documentation files (the
  * "Software"), to deal in the Software without restriction, including
  * without limitation the rights to use, copy, modify, merge, publish,
  * distribute, sublicense, and/or sell copies of the Software, and to
  * permit persons to whom the Software is furnished to do so, subject
- * to the following conditions: 
+ * to the following conditions:
  * The above copyright notice and this permission notice shall be included
- * in all copies or substantial portions of the Software. 
- * 
+ * in all copies or substantial portions of the Software.
+ *
  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
  * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
  * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  *
  */
 
 /** OMX_Types.h - OpenMax IL version 1.1.2
- *  The OMX_Types header file contains the primitive type definitions used by 
+ *  The OMX_Types header file contains the primitive type definitions used by
  *  the core, the application and the component.  This file may need to be
- *  modified to be used on systems that do not have "char" set to 8 bits, 
+ *  modified to be used on systems that do not have "char" set to 8 bits,
  *  "short" set to 16 bits and "long" set to 32 bits.
  */
 
 #ifndef OMX_Types_h
 #define OMX_Types_h
 
+#include <stdint.h>
+
 #ifdef __cplusplus
 extern "C" {
 #endif /* __cplusplus */
@@ -38,12 +40,12 @@
 /** The OMX_API and OMX_APIENTRY are platform specific definitions used
  *  to declare OMX function prototypes.  They are modified to meet the
  *  requirements for a particular platform */
-#ifdef __SYMBIAN32__   
+#ifdef __SYMBIAN32__
 #   ifdef __OMX_EXPORTS
 #       define OMX_API __declspec(dllexport)
 #   else
 #       ifdef _WIN32
-#           define OMX_API __declspec(dllexport) 
+#           define OMX_API __declspec(dllexport)
 #       else
 #           define OMX_API __declspec(dllimport)
 #       endif
@@ -65,18 +67,18 @@
 #endif
 
 #ifndef OMX_APIENTRY
-#define OMX_APIENTRY 
-#endif 
+#define OMX_APIENTRY
+#endif
 
-/** OMX_IN is used to identify inputs to an OMX function.  This designation 
-    will also be used in the case of a pointer that points to a parameter 
+/** OMX_IN is used to identify inputs to an OMX function.  This designation
+    will also be used in the case of a pointer that points to a parameter
     that is used as an output. */
 #ifndef OMX_IN
 #define OMX_IN
 #endif
 
-/** OMX_OUT is used to identify outputs from an OMX function.  This 
-    designation will also be used in the case of a pointer that points 
+/** OMX_OUT is used to identify outputs from an OMX function.  This
+    designation will also be used in the case of a pointer that points
     to a parameter that is used as an input. */
 #ifndef OMX_OUT
 #define OMX_OUT
@@ -84,8 +86,8 @@
 
 
 /** OMX_INOUT is used to identify parameters that may be either inputs or
-    outputs from an OMX function at the same time.  This designation will 
-    also be used in the case of a pointer that  points to a parameter that 
+    outputs from an OMX function at the same time.  This designation will
+    also be used in the case of a pointer that  points to a parameter that
     is used both as an input and an output. */
 #ifndef OMX_INOUT
 #define OMX_INOUT
@@ -103,53 +105,53 @@
 /** @defgroup core OpenMAX IL core
  * Functions and structure related to the OMX IL core
  */
- 
+
  /** @defgroup comp OpenMAX IL component
  * Functions and structure related to the OMX IL component
  */
- 
-/** @defgroup rpm Resource and Policy Management 
+
+/** @defgroup rpm Resource and Policy Management
  * Structures for resource and policy management of components
  */
 
 /** @defgroup buf Buffer Management
  * Buffer handling functions and structures
  */
-  
+
 /** @defgroup tun Tunneling
  * @ingroup core comp
  * Structures and functions to manage tunnels among component ports
  */
- 
+
 /** @defgroup cp Content Pipes
  *  @ingroup core
  */
- 
+
  /** @defgroup metadata Metadata handling
-  * 
-  */ 
+  *
+  */
 
 /** OMX_U8 is an 8 bit unsigned quantity that is byte aligned */
-typedef unsigned char OMX_U8;
+typedef uint8_t OMX_U8;
 
 /** OMX_S8 is an 8 bit signed quantity that is byte aligned */
-typedef signed char OMX_S8;
+typedef int8_t OMX_S8;
 
 /** OMX_U16 is a 16 bit unsigned quantity that is 16 bit word aligned */
-typedef unsigned short OMX_U16;
+typedef uint16_t OMX_U16;
 
 /** OMX_S16 is a 16 bit signed quantity that is 16 bit word aligned */
-typedef signed short OMX_S16;
+typedef int16_t OMX_S16;
 
 /** OMX_U32 is a 32 bit unsigned quantity that is 32 bit word aligned */
-typedef unsigned long OMX_U32;
+typedef uint32_t OMX_U32;
 
 /** OMX_S32 is a 32 bit signed quantity that is 32 bit word aligned */
-typedef signed long OMX_S32;
+typedef int32_t OMX_S32;
 
 
 /* Users with compilers that cannot accept the "long long" designation should
-   define the OMX_SKIP64BIT macro.  It should be noted that this may cause 
+   define the OMX_SKIP64BIT macro.  It should be noted that this may cause
    some components to fail to compile if the component was written to require
    64 bit integral types.  However, these components would NOT compile anyway
    since the compiler does not support the way the component was written.
@@ -164,7 +166,7 @@
 
 #elif defined(WIN32)
 
-/** OMX_U64 is a 64 bit unsigned quantity that is 64 bit word aligned */   
+/** OMX_U64 is a 64 bit unsigned quantity that is 64 bit word aligned */
 typedef unsigned __int64  OMX_U64;
 
 /** OMX_S64 is a 64 bit signed quantity that is 64 bit word aligned */
@@ -173,16 +175,16 @@
 #else /* WIN32 */
 
 /** OMX_U64 is a 64 bit unsigned quantity that is 64 bit word aligned */
-typedef unsigned long long OMX_U64;
+typedef uint64_t OMX_U64;
 
 /** OMX_S64 is a 64 bit signed quantity that is 64 bit word aligned */
-typedef signed long long OMX_S64;
+typedef int64_t OMX_S64;
 
 #endif /* WIN32 */
 #endif
 
 
-/** The OMX_BOOL type is intended to be used to represent a true or a false 
+/** The OMX_BOOL type is intended to be used to represent a true or a false
     value when passing parameters to and from the OMX core and components.  The
     OMX_BOOL is a 32 bit quantity and is aligned on a 32 bit word boundary.
  */
@@ -190,8 +192,8 @@
     OMX_FALSE = 0,
     OMX_TRUE = !OMX_FALSE,
     OMX_BOOL_MAX = 0x7FFFFFFF
-} OMX_BOOL; 
- 
+} OMX_BOOL;
+
 /** The OMX_PTR type is intended to be used to pass pointers between the OMX
     applications and the OMX Core and components.  This is a 32 bit pointer and
     is aligned on a 32 bit boundary.
@@ -199,14 +201,14 @@
 typedef void* OMX_PTR;
 
 /** The OMX_STRING type is intended to be used to pass "C" type strings between
-    the application and the core and component.  The OMX_STRING type is a 32 
-    bit pointer to a zero terminated string.  The  pointer is word aligned and 
-    the string is byte aligned.  
+    the application and the core and component.  The OMX_STRING type is a 32
+    bit pointer to a zero terminated string.  The  pointer is word aligned and
+    the string is byte aligned.
  */
 typedef char* OMX_STRING;
 
 /** The OMX_BYTE type is intended to be used to pass arrays of bytes such as
-    buffers between the application and the component and core.  The OMX_BYTE 
+    buffers between the application and the component and core.  The OMX_BYTE
     type is a 32 bit pointer to a zero terminated string.  The  pointer is word
     aligned and the string is byte aligned.
  */
@@ -219,7 +221,7 @@
 typedef unsigned char OMX_UUIDTYPE[128];
 
 /** The OMX_DIRTYPE enumeration is used to indicate if a port is an input or
-    an output port.  This enumeration is common across all component types.    
+    an output port.  This enumeration is common across all component types.
  */
 typedef enum OMX_DIRTYPE
 {
@@ -228,8 +230,8 @@
     OMX_DirMax = 0x7FFFFFFF
 } OMX_DIRTYPE;
 
-/** The OMX_ENDIANTYPE enumeration is used to indicate the bit ordering 
-    for numerical data (i.e. big endian, or little endian).    
+/** The OMX_ENDIANTYPE enumeration is used to indicate the bit ordering
+    for numerical data (i.e. big endian, or little endian).
  */
 typedef enum OMX_ENDIANTYPE
 {
@@ -239,7 +241,7 @@
 } OMX_ENDIANTYPE;
 
 
-/** The OMX_NUMERICALDATATYPE enumeration is used to indicate if data 
+/** The OMX_NUMERICALDATATYPE enumeration is used to indicate if data
     is signed or unsigned
  */
 typedef enum OMX_NUMERICALDATATYPE
@@ -267,16 +269,16 @@
 
 
 /** Structure representing some time or duration in microseconds. This structure
-  *  must be interpreted as a signed 64 bit value. The quantity is signed to accommodate 
-  *  negative deltas and preroll scenarios. The quantity is represented in microseconds 
+  *  must be interpreted as a signed 64 bit value. The quantity is signed to accommodate
+  *  negative deltas and preroll scenarios. The quantity is represented in microseconds
   *  to accomodate high resolution timestamps (e.g. DVD presentation timestamps based
-  *  on a 90kHz clock) and to allow more accurate and synchronized delivery (e.g. 
-  *  individual audio samples delivered at 192 kHz). The quantity is 64 bit to 
+  *  on a 90kHz clock) and to allow more accurate and synchronized delivery (e.g.
+  *  individual audio samples delivered at 192 kHz). The quantity is 64 bit to
   *  accommodate a large dynamic range (signed 32 bit values would allow only for plus
   *  or minus 35 minutes).
   *
-  *  Implementations with limited precision may convert the signed 64 bit value to 
-  *  a signed 32 bit value internally but risk loss of precision.  
+  *  Implementations with limited precision may convert the signed 64 bit value to
+  *  a signed 32 bit value internally but risk loss of precision.
   */
 #ifndef OMX_SKIP64BIT
 typedef OMX_S64 OMX_TICKS;
@@ -296,17 +298,17 @@
 
 typedef struct OMX_MARKTYPE
 {
-    OMX_HANDLETYPE hMarkTargetComponent;   /**< The component that will 
-                                                generate a mark event upon 
+    OMX_HANDLETYPE hMarkTargetComponent;   /**< The component that will
+                                                generate a mark event upon
                                                 processing the mark. */
-    OMX_PTR pMarkData;   /**< Application specific data associated with 
-                              the mark sent on a mark event to disambiguate 
+    OMX_PTR pMarkData;   /**< Application specific data associated with
+                              the mark sent on a mark event to disambiguate
                               this mark from others. */
 } OMX_MARKTYPE;
 
 
 /** OMX_NATIVE_DEVICETYPE is used to map a OMX video port to the
- *  platform & operating specific object used to reference the display 
+ *  platform & operating specific object used to reference the display
  *  or can be used by a audio port for native audio rendering */
 typedef void* OMX_NATIVE_DEVICETYPE;
 
@@ -329,7 +331,7 @@
 /** The OMX_VERSIONTYPE union is used to specify the version for
     a structure or component.  For a component, the version is entirely
     specified by the component vendor.  Components doing the same function
-    from different vendors may or may not have the same version.  For 
+    from different vendors may or may not have the same version.  For
     structures, the version shall be set by the entity that allocates the
     structure.  For structures specified in the OMX 1.1 specification, the
     value of the version shall be set to 1.1.0.0 in all cases.  Access to the
Index: gst-omx-1.22.0/omx/openmax/OMX_Video.h
===================================================================
--- gst-omx-1.22.0.orig/omx/openmax/OMX_Video.h	2023-03-02 08:48:43.000000000 +0000
+++ gst-omx-1.22.0/omx/openmax/OMX_Video.h	2023-03-02 08:58:22.000000000 +0000
@@ -1,29 +1,29 @@
 /**
- * Copyright (c) 2008 The Khronos Group Inc. 
- * 
+ * Copyright (c) 2008 The Khronos Group Inc.
+ *
  * Permission is hereby granted, free of charge, to any person obtaining
  * a copy of this software and associated documentation files (the
  * "Software"), to deal in the Software without restriction, including
  * without limitation the rights to use, copy, modify, merge, publish,
  * distribute, sublicense, and/or sell copies of the Software, and to
  * permit persons to whom the Software is furnished to do so, subject
- * to the following conditions: 
+ * to the following conditions:
  * The above copyright notice and this permission notice shall be included
- * in all copies or substantial portions of the Software. 
- * 
+ * in all copies or substantial portions of the Software.
+ *
  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
  * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
  * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  *
  */
 
-/** 
+/**
  *  @file OMX_Video.h - OpenMax IL version 1.1.2
- *  The structures is needed by Video components to exchange parameters 
+ *  The structures is needed by Video components to exchange parameters
  *  and configuration data with OMX components.
  */
 #ifndef OMX_Video_h
@@ -43,19 +43,19 @@
 /**
  * Each OMX header must include all required header files to allow the
  * header to compile without errors.  The includes below are required
- * for this header file to compile successfully 
+ * for this header file to compile successfully
  */
 
 #include <OMX_IVCommon.h>
 
 
 /**
- * Enumeration used to define the possible video compression codings.  
- * NOTE:  This essentially refers to file extensions. If the coding is 
- *        being used to specify the ENCODE type, then additional work 
- *        must be done to configure the exact flavor of the compression 
- *        to be used.  For decode cases where the user application can 
- *        not differentiate between MPEG-4 and H.264 bit streams, it is 
+ * Enumeration used to define the possible video compression codings.
+ * NOTE:  This essentially refers to file extensions. If the coding is
+ *        being used to specify the ENCODE type, then additional work
+ *        must be done to configure the exact flavor of the compression
+ *        to be used.  For decode cases where the user application can
+ *        not differentiate between MPEG-4 and H.264 bit streams, it is
  *        up to the codec to handle this.
  */
 typedef enum OMX_VIDEO_CODINGTYPE {
@@ -68,58 +68,61 @@
     OMX_VIDEO_CodingRV,         /**< all versions of Real Video */
     OMX_VIDEO_CodingAVC,        /**< H.264/AVC */
     OMX_VIDEO_CodingMJPEG,      /**< Motion JPEG */
-    OMX_VIDEO_CodingKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_VIDEO_CodingVP8,        /**< Google VP8, formerly known as On2 VP8 */
+    OMX_VIDEO_CodingVP9,        /**< Google VP9 */
+    OMX_VIDEO_CodingHEVC,       /**< ITU H.265/HEVC */
+    OMX_VIDEO_CodingKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
     OMX_VIDEO_CodingVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_VIDEO_CodingMax = 0x7FFFFFFF
 } OMX_VIDEO_CODINGTYPE;
 
 
 /**
- * Data structure used to define a video path.  The number of Video paths for 
- * input and output will vary by type of the Video component.  
- * 
+ * Data structure used to define a video path.  The number of Video paths for
+ * input and output will vary by type of the Video component.
+ *
  *    Input (aka Source) : zero Inputs, one Output,
  *    Splitter           : one Input, 2 or more Outputs,
  *    Processing Element : one Input, one output,
  *    Mixer              : 2 or more inputs, one output,
  *    Output (aka Sink)  : one Input, zero outputs.
- * 
- * The PortDefinition structure is used to define all of the parameters 
- * necessary for the compliant component to setup an input or an output video 
- * path.  If additional vendor specific data is required, it should be 
- * transmitted to the component using the CustomCommand function.  Compliant 
- * components will prepopulate this structure with optimal values during the 
+ *
+ * The PortDefinition structure is used to define all of the parameters
+ * necessary for the compliant component to setup an input or an output video
+ * path.  If additional vendor specific data is required, it should be
+ * transmitted to the component using the CustomCommand function.  Compliant
+ * components will prepopulate this structure with optimal values during the
  * GetDefaultInitParams command.
  *
  * STRUCT MEMBERS:
  *  cMIMEType             : MIME type of data for the port
- *  pNativeRender         : Platform specific reference for a display if a 
+ *  pNativeRender         : Platform specific reference for a display if a
  *                          sync, otherwise this field is 0
- *  nFrameWidth           : Width of frame to be used on channel if 
+ *  nFrameWidth           : Width of frame to be used on channel if
  *                          uncompressed format is used.  Use 0 for unknown,
  *                          don't care or variable
- *  nFrameHeight          : Height of frame to be used on channel if 
+ *  nFrameHeight          : Height of frame to be used on channel if
  *                          uncompressed format is used. Use 0 for unknown,
  *                          don't care or variable
- *  nStride               : Number of bytes per span of an image 
+ *  nStride               : Number of bytes per span of an image
  *                          (i.e. indicates the number of bytes to get
  *                          from span N to span N+1, where negative stride
  *                          indicates the image is bottom up
  *  nSliceHeight          : Height used when encoding in slices
- *  nBitrate              : Bit rate of frame to be used on channel if 
- *                          compressed format is used. Use 0 for unknown, 
+ *  nBitrate              : Bit rate of frame to be used on channel if
+ *                          compressed format is used. Use 0 for unknown,
  *                          don't care or variable
- *  xFramerate            : Frame rate to be used on channel if uncompressed 
- *                          format is used. Use 0 for unknown, don't care or 
+ *  xFramerate            : Frame rate to be used on channel if uncompressed
+ *                          format is used. Use 0 for unknown, don't care or
  *                          variable.  Units are Q16 frames per second.
- *  bFlagErrorConcealment : Turns on error concealment if it is supported by 
+ *  bFlagErrorConcealment : Turns on error concealment if it is supported by
  *                          the OMX component
- *  eCompressionFormat    : Compression format used in this instance of the 
- *                          component. When OMX_VIDEO_CodingUnused is 
+ *  eCompressionFormat    : Compression format used in this instance of the
+ *                          component. When OMX_VIDEO_CodingUnused is
  *                          specified, eColorFormat is used
  *  eColorFormat : Decompressed format used by this component
- *  pNativeWindow : Platform specific reference for a window object if a 
- *                          display sink , otherwise this field is 0x0. 
+ *  pNativeWindow : Platform specific reference for a window object if a
+ *                          display sink , otherwise this field is 0x0.
  */
 typedef struct OMX_VIDEO_PORTDEFINITIONTYPE {
     OMX_STRING cMIMEType;
@@ -136,19 +139,19 @@
     OMX_NATIVE_WINDOWTYPE pNativeWindow;
 } OMX_VIDEO_PORTDEFINITIONTYPE;
 
-/**  
- * Port format parameter.  This structure is used to enumerate the various 
+/**
+ * Port format parameter.  This structure is used to enumerate the various
  * data input/output format supported by the port.
- * 
+ *
  * STRUCT MEMBERS:
  *  nSize              : Size of the structure in bytes
  *  nVersion           : OMX specification version information
  *  nPortIndex         : Indicates which port to set
- *  nIndex             : Indicates the enumeration index for the format from 
+ *  nIndex             : Indicates the enumeration index for the format from
  *                       0x0 to N-1
- *  eCompressionFormat : Compression format used in this instance of the 
- *                       component. When OMX_VIDEO_CodingUnused is specified, 
- *                       eColorFormat is used 
+ *  eCompressionFormat : Compression format used in this instance of the
+ *                       component. When OMX_VIDEO_CodingUnused is specified,
+ *                       eColorFormat is used
  *  eColorFormat       : Decompressed format used by this component
  *  xFrameRate         : Indicates the video frame rate in Q16 format
  */
@@ -157,14 +160,14 @@
     OMX_VERSIONTYPE nVersion;
     OMX_U32 nPortIndex;
     OMX_U32 nIndex;
-    OMX_VIDEO_CODINGTYPE eCompressionFormat; 
+    OMX_VIDEO_CODINGTYPE eCompressionFormat;
     OMX_COLOR_FORMATTYPE eColorFormat;
     OMX_U32 xFramerate;
 } OMX_VIDEO_PARAM_PORTFORMATTYPE;
 
 
 /**
- * This is a structure for configuring video compression quantization 
+ * This is a structure for configuring video compression quantization
  * parameter values.  Codecs may support different QP values for different
  * frame types.
  *
@@ -174,10 +177,10 @@
  *  nPortIndex : Port that this structure applies to
  *  nQpI       : QP value to use for index frames
  *  nQpP       : QP value to use for P frames
- *  nQpB       : QP values to use for bidirectional frames 
+ *  nQpB       : QP values to use for bidirectional frames
  */
 typedef struct OMX_VIDEO_PARAM_QUANTIZATIONTYPE {
-    OMX_U32 nSize;            
+    OMX_U32 nSize;
     OMX_VERSIONTYPE nVersion;
     OMX_U32 nPortIndex;
     OMX_U32 nQpI;
@@ -186,32 +189,32 @@
 } OMX_VIDEO_PARAM_QUANTIZATIONTYPE;
 
 
-/** 
- * Structure for configuration of video fast update parameters. 
- *  
+/**
+ * Structure for configuration of video fast update parameters.
+ *
  * STRUCT MEMBERS:
  *  nSize      : Size of the structure in bytes
- *  nVersion   : OMX specification version info 
+ *  nVersion   : OMX specification version info
  *  nPortIndex : Port that this structure applies to
  *  bEnableVFU : Enable/Disable video fast update
  *  nFirstGOB  : Specifies the number of the first macroblock row
  *  nFirstMB   : specifies the first MB relative to the specified first GOB
- *  nNumMBs    : Specifies the number of MBs to be refreshed from nFirstGOB 
+ *  nNumMBs    : Specifies the number of MBs to be refreshed from nFirstGOB
  *               and nFirstMB
  */
 typedef struct OMX_VIDEO_PARAM_VIDEOFASTUPDATETYPE {
-    OMX_U32 nSize;            
-    OMX_VERSIONTYPE nVersion; 
-    OMX_U32 nPortIndex;       
-    OMX_BOOL bEnableVFU;      
-    OMX_U32 nFirstGOB;                            
-    OMX_U32 nFirstMB;                            
-    OMX_U32 nNumMBs;                                  
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_BOOL bEnableVFU;
+    OMX_U32 nFirstGOB;
+    OMX_U32 nFirstMB;
+    OMX_U32 nNumMBs;
 } OMX_VIDEO_PARAM_VIDEOFASTUPDATETYPE;
 
 
-/** 
- * Enumeration of possible bitrate control types 
+/**
+ * Enumeration of possible bitrate control types
  */
 typedef enum OMX_VIDEO_CONTROLRATETYPE {
     OMX_Video_ControlRateDisable,
@@ -219,14 +222,14 @@
     OMX_Video_ControlRateConstant,
     OMX_Video_ControlRateVariableSkipFrames,
     OMX_Video_ControlRateConstantSkipFrames,
-    OMX_Video_ControlRateKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_Video_ControlRateKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
     OMX_Video_ControlRateVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_Video_ControlRateMax = 0x7FFFFFFF
 } OMX_VIDEO_CONTROLRATETYPE;
 
 
-/** 
- * Structure for configuring bitrate mode of a codec. 
+/**
+ * Structure for configuring bitrate mode of a codec.
  *
  * STRUCT MEMBERS:
  *  nSize          : Size of the struct in bytes
@@ -236,23 +239,23 @@
  *  nTargetBitrate : Target bitrate to encode with
  */
 typedef struct OMX_VIDEO_PARAM_BITRATETYPE {
-    OMX_U32 nSize;                          
-    OMX_VERSIONTYPE nVersion;               
-    OMX_U32 nPortIndex;                     
-    OMX_VIDEO_CONTROLRATETYPE eControlRate; 
-    OMX_U32 nTargetBitrate;                 
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_VIDEO_CONTROLRATETYPE eControlRate;
+    OMX_U32 nTargetBitrate;
 } OMX_VIDEO_PARAM_BITRATETYPE;
 
 
-/** 
- * Enumeration of possible motion vector (MV) types 
+/**
+ * Enumeration of possible motion vector (MV) types
  */
 typedef enum OMX_VIDEO_MOTIONVECTORTYPE {
     OMX_Video_MotionVectorPixel,
     OMX_Video_MotionVectorHalfPel,
     OMX_Video_MotionVectorQuarterPel,
     OMX_Video_MotionVectorEighthPel,
-    OMX_Video_MotionVectorKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_Video_MotionVectorKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
     OMX_Video_MotionVectorVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_Video_MotionVectorMax = 0x7FFFFFFF
 } OMX_VIDEO_MOTIONVECTORTYPE;
@@ -261,7 +264,7 @@
 /**
  * Structure for configuring the number of motion vectors used as well
  * as their accuracy.
- * 
+ *
  * STRUCT MEMBERS:
  *  nSize            : Size of the struct in bytes
  *  nVersion         : OMX spec version info
@@ -284,32 +287,32 @@
 } OMX_VIDEO_PARAM_MOTIONVECTORTYPE;
 
 
-/** 
- * Enumeration of possible methods to use for Intra Refresh 
+/**
+ * Enumeration of possible methods to use for Intra Refresh
  */
 typedef enum OMX_VIDEO_INTRAREFRESHTYPE {
     OMX_VIDEO_IntraRefreshCyclic,
     OMX_VIDEO_IntraRefreshAdaptive,
     OMX_VIDEO_IntraRefreshBoth,
-    OMX_VIDEO_IntraRefreshKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_VIDEO_IntraRefreshKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
     OMX_VIDEO_IntraRefreshVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_VIDEO_IntraRefreshMax = 0x7FFFFFFF
 } OMX_VIDEO_INTRAREFRESHTYPE;
 
 
 /**
- * Structure for configuring intra refresh mode 
- * 
+ * Structure for configuring intra refresh mode
+ *
  * STRUCT MEMBERS:
  *  nSize        : Size of the structure in bytes
  *  nVersion     : OMX specification version information
  *  nPortIndex   : Port that this structure applies to
  *  eRefreshMode : Cyclic, Adaptive, or Both
- *  nAirMBs      : Number of intra macroblocks to refresh in a frame when 
+ *  nAirMBs      : Number of intra macroblocks to refresh in a frame when
  *                 AIR is enabled
- *  nAirRef      : Number of times a motion marked macroblock has to be  
+ *  nAirRef      : Number of times a motion marked macroblock has to be
  *                 intra coded
- *  nCirMBs      : Number of consecutive macroblocks to be coded as "intra"  
+ *  nCirMBs      : Number of consecutive macroblocks to be coded as "intra"
  *                 when CIR is enabled
  */
 typedef struct OMX_VIDEO_PARAM_INTRAREFRESHTYPE {
@@ -324,19 +327,19 @@
 
 
 /**
- * Structure for enabling various error correction methods for video 
+ * Structure for enabling various error correction methods for video
  * compression.
  *
  * STRUCT MEMBERS:
  *  nSize                   : Size of the structure in bytes
- *  nVersion                : OMX specification version information 
- *  nPortIndex              : Port that this structure applies to 
+ *  nVersion                : OMX specification version information
+ *  nPortIndex              : Port that this structure applies to
  *  bEnableHEC              : Enable/disable header extension codes (HEC)
  *  bEnableResync           : Enable/disable resynchronization markers
- *  nResynchMarkerSpacing   : Resynch markers interval (in bits) to be 
- *                            applied in the stream 
- *  bEnableDataPartitioning : Enable/disable data partitioning 
- *  bEnableRVLC             : Enable/disable reversible variable length 
+ *  nResynchMarkerSpacing   : Resynch markers interval (in bits) to be
+ *                            applied in the stream
+ *  bEnableDataPartitioning : Enable/disable data partitioning
+ *  bEnableRVLC             : Enable/disable reversible variable length
  *                            coding
  */
 typedef struct OMX_VIDEO_PARAM_ERRORCORRECTIONTYPE {
@@ -351,12 +354,12 @@
 } OMX_VIDEO_PARAM_ERRORCORRECTIONTYPE;
 
 
-/** 
- * Configuration of variable block-size motion compensation (VBSMC) 
- * 
+/**
+ * Configuration of variable block-size motion compensation (VBSMC)
+ *
  * STRUCT MEMBERS:
  *  nSize      : Size of the structure in bytes
- *  nVersion   : OMX specification version information 
+ *  nVersion   : OMX specification version information
  *  nPortIndex : Port that this structure applies to
  *  b16x16     : Enable inter block search 16x16
  *  b16x8      : Enable inter block search 16x8
@@ -367,11 +370,11 @@
  *  b4x4       : Enable inter block search 4x4
  */
 typedef struct OMX_VIDEO_PARAM_VBSMCTYPE {
-    OMX_U32 nSize; 
-    OMX_VERSIONTYPE nVersion; 
-    OMX_U32 nPortIndex;       
-    OMX_BOOL b16x16; 
-    OMX_BOOL b16x8; 
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_BOOL b16x16;
+    OMX_BOOL b16x8;
     OMX_BOOL b8x16;
     OMX_BOOL b8x8;
     OMX_BOOL b8x4;
@@ -380,67 +383,67 @@
 } OMX_VIDEO_PARAM_VBSMCTYPE;
 
 
-/** 
- * H.263 profile types, each profile indicates support for various 
+/**
+ * H.263 profile types, each profile indicates support for various
  * performance bounds and different annexes.
  *
  * ENUMS:
- *  Baseline           : Baseline Profile: H.263 (V1), no optional modes                                                    
- *  H320 Coding        : H.320 Coding Efficiency Backward Compatibility 
+ *  Baseline           : Baseline Profile: H.263 (V1), no optional modes
+ *  H320 Coding        : H.320 Coding Efficiency Backward Compatibility
  *                       Profile: H.263+ (V2), includes annexes I, J, L.4
  *                       and T
- *  BackwardCompatible : Backward Compatibility Profile: H.263 (V1), 
- *                       includes annex F                                    
- *  ISWV2              : Interactive Streaming Wireless Profile: H.263+ 
- *                       (V2), includes annexes I, J, K and T                 
- *  ISWV3              : Interactive Streaming Wireless Profile: H.263++  
- *                       (V3), includes profile 3 and annexes V and W.6.3.8   
- *  HighCompression    : Conversational High Compression Profile: H.263++  
- *                       (V3), includes profiles 1 & 2 and annexes D and U   
- *  Internet           : Conversational Internet Profile: H.263++ (V3),  
- *                       includes profile 5 and annex K                       
- *  Interlace          : Conversational Interlace Profile: H.263++ (V3),  
- *                       includes profile 5 and annex W.6.3.11               
- *  HighLatency        : High Latency Profile: H.263++ (V3), includes  
- *                       profile 6 and annexes O.1 and P.5                       
+ *  BackwardCompatible : Backward Compatibility Profile: H.263 (V1),
+ *                       includes annex F
+ *  ISWV2              : Interactive Streaming Wireless Profile: H.263+
+ *                       (V2), includes annexes I, J, K and T
+ *  ISWV3              : Interactive Streaming Wireless Profile: H.263++
+ *                       (V3), includes profile 3 and annexes V and W.6.3.8
+ *  HighCompression    : Conversational High Compression Profile: H.263++
+ *                       (V3), includes profiles 1 & 2 and annexes D and U
+ *  Internet           : Conversational Internet Profile: H.263++ (V3),
+ *                       includes profile 5 and annex K
+ *  Interlace          : Conversational Interlace Profile: H.263++ (V3),
+ *                       includes profile 5 and annex W.6.3.11
+ *  HighLatency        : High Latency Profile: H.263++ (V3), includes
+ *                       profile 6 and annexes O.1 and P.5
  */
 typedef enum OMX_VIDEO_H263PROFILETYPE {
-    OMX_VIDEO_H263ProfileBaseline            = 0x01,        
-    OMX_VIDEO_H263ProfileH320Coding          = 0x02,          
-    OMX_VIDEO_H263ProfileBackwardCompatible  = 0x04,  
-    OMX_VIDEO_H263ProfileISWV2               = 0x08,               
-    OMX_VIDEO_H263ProfileISWV3               = 0x10,               
-    OMX_VIDEO_H263ProfileHighCompression     = 0x20,     
-    OMX_VIDEO_H263ProfileInternet            = 0x40,            
-    OMX_VIDEO_H263ProfileInterlace           = 0x80,           
-    OMX_VIDEO_H263ProfileHighLatency         = 0x100,         
-    OMX_VIDEO_H263ProfileKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_VIDEO_H263ProfileBaseline            = 0x01,
+    OMX_VIDEO_H263ProfileH320Coding          = 0x02,
+    OMX_VIDEO_H263ProfileBackwardCompatible  = 0x04,
+    OMX_VIDEO_H263ProfileISWV2               = 0x08,
+    OMX_VIDEO_H263ProfileISWV3               = 0x10,
+    OMX_VIDEO_H263ProfileHighCompression     = 0x20,
+    OMX_VIDEO_H263ProfileInternet            = 0x40,
+    OMX_VIDEO_H263ProfileInterlace           = 0x80,
+    OMX_VIDEO_H263ProfileHighLatency         = 0x100,
+    OMX_VIDEO_H263ProfileKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
     OMX_VIDEO_H263ProfileVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_VIDEO_H263ProfileMax                 = 0x7FFFFFFF  
+    OMX_VIDEO_H263ProfileMax                 = 0x7FFFFFFF
 } OMX_VIDEO_H263PROFILETYPE;
 
 
-/** 
- * H.263 level types, each level indicates support for various frame sizes, 
+/**
+ * H.263 level types, each level indicates support for various frame sizes,
  * bit rates, decoder frame rates.
  */
 typedef enum OMX_VIDEO_H263LEVELTYPE {
-    OMX_VIDEO_H263Level10  = 0x01,  
-    OMX_VIDEO_H263Level20  = 0x02,      
-    OMX_VIDEO_H263Level30  = 0x04,      
-    OMX_VIDEO_H263Level40  = 0x08,      
-    OMX_VIDEO_H263Level45  = 0x10,      
-    OMX_VIDEO_H263Level50  = 0x20,      
-    OMX_VIDEO_H263Level60  = 0x40,      
-    OMX_VIDEO_H263Level70  = 0x80, 
-    OMX_VIDEO_H263LevelKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_VIDEO_H263Level10  = 0x01,
+    OMX_VIDEO_H263Level20  = 0x02,
+    OMX_VIDEO_H263Level30  = 0x04,
+    OMX_VIDEO_H263Level40  = 0x08,
+    OMX_VIDEO_H263Level45  = 0x10,
+    OMX_VIDEO_H263Level50  = 0x20,
+    OMX_VIDEO_H263Level60  = 0x40,
+    OMX_VIDEO_H263Level70  = 0x80,
+    OMX_VIDEO_H263LevelKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
     OMX_VIDEO_H263LevelVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_VIDEO_H263LevelMax = 0x7FFFFFFF  
+    OMX_VIDEO_H263LevelMax = 0x7FFFFFFF
 } OMX_VIDEO_H263LEVELTYPE;
 
 
-/** 
- * Specifies the picture type. These values should be OR'd to signal all 
+/**
+ * Specifies the picture type. These values should be OR'd to signal all
  * pictures types which are allowed.
  *
  * ENUMS:
@@ -458,36 +461,36 @@
     OMX_VIDEO_PictureTypeEI  = 0x11,
     OMX_VIDEO_PictureTypeEP  = 0x12,
     OMX_VIDEO_PictureTypeS   = 0x14,
-    OMX_VIDEO_PictureTypeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_VIDEO_PictureTypeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
     OMX_VIDEO_PictureTypeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_VIDEO_PictureTypeMax = 0x7FFFFFFF
 } OMX_VIDEO_PICTURETYPE;
 
 
-/** 
- * H.263 Params 
+/**
+ * H.263 Params
  *
  * STRUCT MEMBERS:
  *  nSize                    : Size of the structure in bytes
- *  nVersion                 : OMX specification version information 
+ *  nVersion                 : OMX specification version information
  *  nPortIndex               : Port that this structure applies to
  *  nPFrames                 : Number of P frames between each I frame
  *  nBFrames                 : Number of B frames between each I frame
  *  eProfile                 : H.263 profile(s) to use
  *  eLevel                   : H.263 level(s) to use
- *  bPLUSPTYPEAllowed        : Indicating that it is allowed to use PLUSPTYPE 
- *                             (specified in the 1998 version of H.263) to 
- *                             indicate custom picture sizes or clock 
- *                             frequencies 
- *  nAllowedPictureTypes     : Specifies the picture types allowed in the 
+ *  bPLUSPTYPEAllowed        : Indicating that it is allowed to use PLUSPTYPE
+ *                             (specified in the 1998 version of H.263) to
+ *                             indicate custom picture sizes or clock
+ *                             frequencies
+ *  nAllowedPictureTypes     : Specifies the picture types allowed in the
  *                             bitstream
- *  bForceRoundingTypeToZero : value of the RTYPE bit (bit 6 of MPPTYPE) is 
- *                             not constrained. It is recommended to change 
- *                             the value of the RTYPE bit for each reference 
+ *  bForceRoundingTypeToZero : value of the RTYPE bit (bit 6 of MPPTYPE) is
+ *                             not constrained. It is recommended to change
+ *                             the value of the RTYPE bit for each reference
  *                             picture in error-free communication
- *  nPictureHeaderRepetition : Specifies the frequency of picture header 
+ *  nPictureHeaderRepetition : Specifies the frequency of picture header
  *                             repetition
- *  nGOBHeaderInterval       : Specifies the interval of non-empty GOB  
+ *  nGOBHeaderInterval       : Specifies the interval of non-empty GOB
  *                             headers in units of GOBs
  */
 typedef struct OMX_VIDEO_PARAM_H263TYPE {
@@ -497,7 +500,7 @@
     OMX_U32 nPFrames;
     OMX_U32 nBFrames;
     OMX_VIDEO_H263PROFILETYPE eProfile;
-	OMX_VIDEO_H263LEVELTYPE eLevel;
+    OMX_VIDEO_H263LEVELTYPE eLevel;
     OMX_BOOL bPLUSPTYPEAllowed;
     OMX_U32 nAllowedPictureTypes;
     OMX_BOOL bForceRoundingTypeToZero;
@@ -506,8 +509,8 @@
 } OMX_VIDEO_PARAM_H263TYPE;
 
 
-/** 
- * MPEG-2 profile types, each profile indicates support for various 
+/**
+ * MPEG-2 profile types, each profile indicates support for various
  * performance bounds and different annexes.
  */
 typedef enum OMX_VIDEO_MPEG2PROFILETYPE {
@@ -517,29 +520,29 @@
     OMX_VIDEO_MPEG2ProfileSNR,         /**< SNR Profile */
     OMX_VIDEO_MPEG2ProfileSpatial,     /**< Spatial Profile */
     OMX_VIDEO_MPEG2ProfileHigh,        /**< High Profile */
-    OMX_VIDEO_MPEG2ProfileKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_VIDEO_MPEG2ProfileKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
     OMX_VIDEO_MPEG2ProfileVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_VIDEO_MPEG2ProfileMax = 0x7FFFFFFF  
+    OMX_VIDEO_MPEG2ProfileMax = 0x7FFFFFFF
 } OMX_VIDEO_MPEG2PROFILETYPE;
 
 
-/** 
- * MPEG-2 level types, each level indicates support for various frame 
- * sizes, bit rates, decoder frame rates.  No need 
+/**
+ * MPEG-2 level types, each level indicates support for various frame
+ * sizes, bit rates, decoder frame rates.  No need
  */
 typedef enum OMX_VIDEO_MPEG2LEVELTYPE {
-    OMX_VIDEO_MPEG2LevelLL = 0,  /**< Low Level */ 
-    OMX_VIDEO_MPEG2LevelML,      /**< Main Level */ 
-    OMX_VIDEO_MPEG2LevelH14,     /**< High 1440 */ 
-    OMX_VIDEO_MPEG2LevelHL,      /**< High Level */   
-    OMX_VIDEO_MPEG2LevelKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_VIDEO_MPEG2LevelLL = 0,  /**< Low Level */
+    OMX_VIDEO_MPEG2LevelML,      /**< Main Level */
+    OMX_VIDEO_MPEG2LevelH14,     /**< High 1440 */
+    OMX_VIDEO_MPEG2LevelHL,      /**< High Level */
+    OMX_VIDEO_MPEG2LevelKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
     OMX_VIDEO_MPEG2LevelVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_VIDEO_MPEG2LevelMax = 0x7FFFFFFF  
+    OMX_VIDEO_MPEG2LevelMax = 0x7FFFFFFF
 } OMX_VIDEO_MPEG2LEVELTYPE;
 
 
-/** 
- * MPEG-2 params 
+/**
+ * MPEG-2 params
  *
  * STRUCT MEMBERS:
  *  nSize      : Size of the structure in bytes
@@ -551,20 +554,20 @@
  *  eLevel     : MPEG-2 levels(s) to use
  */
 typedef struct OMX_VIDEO_PARAM_MPEG2TYPE {
-    OMX_U32 nSize;           
+    OMX_U32 nSize;
     OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;      
-    OMX_U32 nPFrames;        
-    OMX_U32 nBFrames;        
+    OMX_U32 nPortIndex;
+    OMX_U32 nPFrames;
+    OMX_U32 nBFrames;
     OMX_VIDEO_MPEG2PROFILETYPE eProfile;
-	OMX_VIDEO_MPEG2LEVELTYPE eLevel;   
+    OMX_VIDEO_MPEG2LEVELTYPE eLevel;
 } OMX_VIDEO_PARAM_MPEG2TYPE;
 
 
-/** 
- * MPEG-4 profile types, each profile indicates support for various 
+/**
+ * MPEG-4 profile types, each profile indicates support for various
  * performance bounds and different annexes.
- * 
+ *
  * ENUMS:
  *  - Simple Profile, Levels 1-3
  *  - Simple Scalable Profile, Levels 1-2
@@ -583,48 +586,48 @@
  *  - Advanced Scalable Texture, Levels 2-3
  */
 typedef enum OMX_VIDEO_MPEG4PROFILETYPE {
-    OMX_VIDEO_MPEG4ProfileSimple           = 0x01,        
-    OMX_VIDEO_MPEG4ProfileSimpleScalable   = 0x02,    
-    OMX_VIDEO_MPEG4ProfileCore             = 0x04,              
-    OMX_VIDEO_MPEG4ProfileMain             = 0x08,             
-    OMX_VIDEO_MPEG4ProfileNbit             = 0x10,              
-    OMX_VIDEO_MPEG4ProfileScalableTexture  = 0x20,   
-    OMX_VIDEO_MPEG4ProfileSimpleFace       = 0x40,        
-    OMX_VIDEO_MPEG4ProfileSimpleFBA        = 0x80,         
-    OMX_VIDEO_MPEG4ProfileBasicAnimated    = 0x100,     
-    OMX_VIDEO_MPEG4ProfileHybrid           = 0x200,            
-    OMX_VIDEO_MPEG4ProfileAdvancedRealTime = 0x400,  
-    OMX_VIDEO_MPEG4ProfileCoreScalable     = 0x800,      
-    OMX_VIDEO_MPEG4ProfileAdvancedCoding   = 0x1000,    
-    OMX_VIDEO_MPEG4ProfileAdvancedCore     = 0x2000,      
+    OMX_VIDEO_MPEG4ProfileSimple           = 0x01,
+    OMX_VIDEO_MPEG4ProfileSimpleScalable   = 0x02,
+    OMX_VIDEO_MPEG4ProfileCore             = 0x04,
+    OMX_VIDEO_MPEG4ProfileMain             = 0x08,
+    OMX_VIDEO_MPEG4ProfileNbit             = 0x10,
+    OMX_VIDEO_MPEG4ProfileScalableTexture  = 0x20,
+    OMX_VIDEO_MPEG4ProfileSimpleFace       = 0x40,
+    OMX_VIDEO_MPEG4ProfileSimpleFBA        = 0x80,
+    OMX_VIDEO_MPEG4ProfileBasicAnimated    = 0x100,
+    OMX_VIDEO_MPEG4ProfileHybrid           = 0x200,
+    OMX_VIDEO_MPEG4ProfileAdvancedRealTime = 0x400,
+    OMX_VIDEO_MPEG4ProfileCoreScalable     = 0x800,
+    OMX_VIDEO_MPEG4ProfileAdvancedCoding   = 0x1000,
+    OMX_VIDEO_MPEG4ProfileAdvancedCore     = 0x2000,
     OMX_VIDEO_MPEG4ProfileAdvancedScalable = 0x4000,
     OMX_VIDEO_MPEG4ProfileAdvancedSimple   = 0x8000,
-    OMX_VIDEO_MPEG4ProfileKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_VIDEO_MPEG4ProfileKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
     OMX_VIDEO_MPEG4ProfileVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_VIDEO_MPEG4ProfileMax              = 0x7FFFFFFF  
+    OMX_VIDEO_MPEG4ProfileMax              = 0x7FFFFFFF
 } OMX_VIDEO_MPEG4PROFILETYPE;
 
 
-/** 
- * MPEG-4 level types, each level indicates support for various frame 
- * sizes, bit rates, decoder frame rates.  No need 
+/**
+ * MPEG-4 level types, each level indicates support for various frame
+ * sizes, bit rates, decoder frame rates.  No need
  */
 typedef enum OMX_VIDEO_MPEG4LEVELTYPE {
-    OMX_VIDEO_MPEG4Level0  = 0x01,   /**< Level 0 */   
-    OMX_VIDEO_MPEG4Level0b = 0x02,   /**< Level 0b */   
-    OMX_VIDEO_MPEG4Level1  = 0x04,   /**< Level 1 */ 
-    OMX_VIDEO_MPEG4Level2  = 0x08,   /**< Level 2 */ 
-    OMX_VIDEO_MPEG4Level3  = 0x10,   /**< Level 3 */ 
-    OMX_VIDEO_MPEG4Level4  = 0x20,   /**< Level 4 */  
-    OMX_VIDEO_MPEG4Level4a = 0x40,   /**< Level 4a */  
-    OMX_VIDEO_MPEG4Level5  = 0x80,   /**< Level 5 */  
-    OMX_VIDEO_MPEG4LevelKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_VIDEO_MPEG4Level0  = 0x01,   /**< Level 0 */
+    OMX_VIDEO_MPEG4Level0b = 0x02,   /**< Level 0b */
+    OMX_VIDEO_MPEG4Level1  = 0x04,   /**< Level 1 */
+    OMX_VIDEO_MPEG4Level2  = 0x08,   /**< Level 2 */
+    OMX_VIDEO_MPEG4Level3  = 0x10,   /**< Level 3 */
+    OMX_VIDEO_MPEG4Level4  = 0x20,   /**< Level 4 */
+    OMX_VIDEO_MPEG4Level4a = 0x40,   /**< Level 4a */
+    OMX_VIDEO_MPEG4Level5  = 0x80,   /**< Level 5 */
+    OMX_VIDEO_MPEG4LevelKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
     OMX_VIDEO_MPEG4LevelVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_VIDEO_MPEG4LevelMax = 0x7FFFFFFF  
+    OMX_VIDEO_MPEG4LevelMax = 0x7FFFFFFF
 } OMX_VIDEO_MPEG4LEVELTYPE;
 
 
-/** 
+/**
  * MPEG-4 configuration.  This structure handles configuration options
  * which are specific to MPEG4 algorithms
  *
@@ -632,24 +635,24 @@
  *  nSize                : Size of the structure in bytes
  *  nVersion             : OMX specification version information
  *  nPortIndex           : Port that this structure applies to
- *  nSliceHeaderSpacing  : Number of macroblocks between slice header (H263+ 
+ *  nSliceHeaderSpacing  : Number of macroblocks between slice header (H263+
  *                         Annex K). Put zero if not used
  *  bSVH                 : Enable Short Video Header mode
  *  bGov                 : Flag to enable GOV
- *  nPFrames             : Number of P frames between each I frame (also called 
+ *  nPFrames             : Number of P frames between each I frame (also called
  *                         GOV period)
  *  nBFrames             : Number of B frames between each I frame
  *  nIDCVLCThreshold     : Value of intra DC VLC threshold
  *  bACPred              : Flag to use ac prediction
  *  nMaxPacketSize       : Maximum size of packet in bytes.
- *  nTimeIncRes          : Used to pass VOP time increment resolution for MPEG4. 
+ *  nTimeIncRes          : Used to pass VOP time increment resolution for MPEG4.
  *                         Interpreted as described in MPEG4 standard.
  *  eProfile             : MPEG-4 profile(s) to use.
  *  eLevel               : MPEG-4 level(s) to use.
  *  nAllowedPictureTypes : Specifies the picture types allowed in the bitstream
  *  nHeaderExtension     : Specifies the number of consecutive video packet
  *                         headers within a VOP
- *  bReversibleVLC       : Specifies whether reversible variable length coding 
+ *  bReversibleVLC       : Specifies whether reversible variable length coding
  *                         is in use
  */
 typedef struct OMX_VIDEO_PARAM_MPEG4TYPE {
@@ -673,22 +676,22 @@
 } OMX_VIDEO_PARAM_MPEG4TYPE;
 
 
-/** 
- * WMV Versions 
+/**
+ * WMV Versions
  */
 typedef enum OMX_VIDEO_WMVFORMATTYPE {
     OMX_VIDEO_WMVFormatUnused = 0x01,   /**< Format unused or unknown */
     OMX_VIDEO_WMVFormat7      = 0x02,   /**< Windows Media Video format 7 */
     OMX_VIDEO_WMVFormat8      = 0x04,   /**< Windows Media Video format 8 */
     OMX_VIDEO_WMVFormat9      = 0x08,   /**< Windows Media Video format 9 */
-    OMX_VIDEO_WMFFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_VIDEO_WMFFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
     OMX_VIDEO_WMFFormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_VIDEO_WMVFormatMax    = 0x7FFFFFFF
 } OMX_VIDEO_WMVFORMATTYPE;
 
 
-/** 
- * WMV Params 
+/**
+ * WMV Params
  *
  * STRUCT MEMBERS:
  *  nSize      : Size of the structure in bytes
@@ -697,33 +700,33 @@
  *  eFormat    : Version of WMV stream / data
  */
 typedef struct OMX_VIDEO_PARAM_WMVTYPE {
-    OMX_U32 nSize; 
+    OMX_U32 nSize;
     OMX_VERSIONTYPE nVersion;
     OMX_U32 nPortIndex;
     OMX_VIDEO_WMVFORMATTYPE eFormat;
 } OMX_VIDEO_PARAM_WMVTYPE;
 
 
-/** 
- * Real Video Version 
+/**
+ * Real Video Version
  */
 typedef enum OMX_VIDEO_RVFORMATTYPE {
     OMX_VIDEO_RVFormatUnused = 0, /**< Format unused or unknown */
     OMX_VIDEO_RVFormat8,          /**< Real Video format 8 */
     OMX_VIDEO_RVFormat9,          /**< Real Video format 9 */
     OMX_VIDEO_RVFormatG2,         /**< Real Video Format G2 */
-    OMX_VIDEO_RVFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_VIDEO_RVFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
     OMX_VIDEO_RVFormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_VIDEO_RVFormatMax = 0x7FFFFFFF
 } OMX_VIDEO_RVFORMATTYPE;
 
 
-/** 
- * Real Video Params 
+/**
+ * Real Video Params
  *
  * STUCT MEMBERS:
  *  nSize              : Size of the structure in bytes
- *  nVersion           : OMX specification version information 
+ *  nVersion           : OMX specification version information
  *  nPortIndex         : Port that this structure applies to
  *  eFormat            : Version of RV stream / data
  *  nBitsPerPixel      : Bits per pixel coded in the frame
@@ -735,11 +738,11 @@
  *  nMaxEncodeFrameSize: Max encoded frame size
  *  bEnablePostFilter  : Turn on/off post filter
  *  bEnableTemporalInterpolation : Turn on/off temporal interpolation
- *  bEnableLatencyMode : When enabled, the decoder does not display a decoded 
- *                       frame until it has detected that no enhancement layer 
- *  					 frames or dependent B frames will be coming. This 
- *  					 detection usually occurs when a subsequent non-B 
- *  					 frame is encountered 
+ *  bEnableLatencyMode : When enabled, the decoder does not display a decoded
+ *                       frame until it has detected that no enhancement layer
+ *                       frames or dependent B frames will be coming. This
+ *                       detection usually occurs when a subsequent non-B
+ *                       frame is encountered
  */
 typedef struct OMX_VIDEO_PARAM_RVTYPE {
     OMX_U32 nSize;
@@ -759,8 +762,8 @@
 } OMX_VIDEO_PARAM_RVTYPE;
 
 
-/** 
- * AVC profile types, each profile indicates support for various 
+/**
+ * AVC profile types, each profile indicates support for various
  * performance bounds and different annexes.
  */
 typedef enum OMX_VIDEO_AVCPROFILETYPE {
@@ -771,15 +774,15 @@
     OMX_VIDEO_AVCProfileHigh10   = 0x10,   /**< High 10 profile */
     OMX_VIDEO_AVCProfileHigh422  = 0x20,   /**< High 4:2:2 profile */
     OMX_VIDEO_AVCProfileHigh444  = 0x40,   /**< High 4:4:4 profile */
-    OMX_VIDEO_AVCProfileKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_VIDEO_AVCProfileKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
     OMX_VIDEO_AVCProfileVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_VIDEO_AVCProfileMax      = 0x7FFFFFFF  
+    OMX_VIDEO_AVCProfileMax      = 0x7FFFFFFF
 } OMX_VIDEO_AVCPROFILETYPE;
 
 
-/** 
- * AVC level types, each level indicates support for various frame sizes, 
- * bit rates, decoder frame rates.  No need 
+/**
+ * AVC level types, each level indicates support for various frame sizes,
+ * bit rates, decoder frame rates.  No need
  */
 typedef enum OMX_VIDEO_AVCLEVELTYPE {
     OMX_VIDEO_AVCLevel1   = 0x01,     /**< Level 1 */
@@ -798,14 +801,15 @@
     OMX_VIDEO_AVCLevel42  = 0x2000,   /**< Level 4.2 */
     OMX_VIDEO_AVCLevel5   = 0x4000,   /**< Level 5 */
     OMX_VIDEO_AVCLevel51  = 0x8000,   /**< Level 5.1 */
-    OMX_VIDEO_AVCLevelKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_VIDEO_AVCLevel52  = 0x10000,  /**< Level 5.2 */
+    OMX_VIDEO_AVCLevelKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
     OMX_VIDEO_AVCLevelVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
-    OMX_VIDEO_AVCLevelMax = 0x7FFFFFFF  
+    OMX_VIDEO_AVCLevelMax = 0x7FFFFFFF
 } OMX_VIDEO_AVCLEVELTYPE;
 
 
-/** 
- * AVC loop filter modes 
+/**
+ * AVC loop filter modes
  *
  * OMX_VIDEO_AVCLoopFilterEnable               : Enable
  * OMX_VIDEO_AVCLoopFilterDisable              : Disable
@@ -815,20 +819,20 @@
     OMX_VIDEO_AVCLoopFilterEnable = 0,
     OMX_VIDEO_AVCLoopFilterDisable,
     OMX_VIDEO_AVCLoopFilterDisableSliceBoundary,
-    OMX_VIDEO_AVCLoopFilterKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_VIDEO_AVCLoopFilterKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
     OMX_VIDEO_AVCLoopFilterVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_VIDEO_AVCLoopFilterMax = 0x7FFFFFFF
 } OMX_VIDEO_AVCLOOPFILTERTYPE;
 
 
-/** 
- * AVC params 
+/**
+ * AVC params
  *
  * STRUCT MEMBERS:
  *  nSize                     : Size of the structure in bytes
  *  nVersion                  : OMX specification version information
  *  nPortIndex                : Port that this structure applies to
- *  nSliceHeaderSpacing       : Number of macroblocks between slice header, put  
+ *  nSliceHeaderSpacing       : Number of macroblocks between slice header, put
  *                              zero if not used
  *  nPFrames                  : Number of P frames between each I frame
  *  nBFrames                  : Number of B frames between each I frame
@@ -841,85 +845,85 @@
  *  nRefIdxForward            : Pic param set ref frame index (index into ref
  *                              frame buffer of forward frames list), B frame
  *                              support
- *  bEnableUEP                : Enable/disable unequal error protection. This 
+ *  bEnableUEP                : Enable/disable unequal error protection. This
  *                              is only valid of data partitioning is enabled.
  *  bEnableFMO                : Enable/disable flexible macroblock ordering
  *  bEnableASO                : Enable/disable arbitrary slice ordering
  *  bEnableRS                 : Enable/disable sending of redundant slices
  *  eProfile                  : AVC profile(s) to use
  *  eLevel                    : AVC level(s) to use
- *  nAllowedPictureTypes      : Specifies the picture types allowed in the 
+ *  nAllowedPictureTypes      : Specifies the picture types allowed in the
  *                              bitstream
- *  bFrameMBsOnly             : specifies that every coded picture of the 
- *                              coded video sequence is a coded frame 
+ *  bFrameMBsOnly             : specifies that every coded picture of the
+ *                              coded video sequence is a coded frame
  *                              containing only frame macroblocks
- *  bMBAFF                    : Enable/disable switching between frame and 
+ *  bMBAFF                    : Enable/disable switching between frame and
  *                              field macroblocks within a picture
- *  bEntropyCodingCABAC       : Entropy decoding method to be applied for the 
- *                              syntax elements for which two descriptors appear 
+ *  bEntropyCodingCABAC       : Entropy decoding method to be applied for the
+ *                              syntax elements for which two descriptors appear
  *                              in the syntax tables
- *  bWeightedPPrediction      : Enable/disable weighted prediction shall not 
+ *  bWeightedPPrediction      : Enable/disable weighted prediction shall not
  *                              be applied to P and SP slices
- *  nWeightedBipredicitonMode : Default weighted prediction is applied to B 
- *                              slices 
+ *  nWeightedBipredicitonMode : Default weighted prediction is applied to B
+ *                              slices
  *  bconstIpred               : Enable/disable intra prediction
- *  bDirect8x8Inference       : Specifies the method used in the derivation 
- *                              process for luma motion vectors for B_Skip, 
- *                              B_Direct_16x16 and B_Direct_8x8 as specified 
- *                              in subclause 8.4.1.2 of the AVC spec 
+ *  bDirect8x8Inference       : Specifies the method used in the derivation
+ *                              process for luma motion vectors for B_Skip,
+ *                              B_Direct_16x16 and B_Direct_8x8 as specified
+ *                              in subclause 8.4.1.2 of the AVC spec
  *  bDirectSpatialTemporal    : Flag indicating spatial or temporal direct
- *                              mode used in B slice coding (related to 
- *                              bDirect8x8Inference) . Spatial direct mode is 
+ *                              mode used in B slice coding (related to
+ *                              bDirect8x8Inference) . Spatial direct mode is
  *                              more common and should be the default.
  *  nCabacInitIdx             : Index used to init CABAC contexts
  *  eLoopFilterMode           : Enable/disable loop filter
  */
 typedef struct OMX_VIDEO_PARAM_AVCTYPE {
-    OMX_U32 nSize;                 
-    OMX_VERSIONTYPE nVersion;      
-    OMX_U32 nPortIndex;            
-    OMX_U32 nSliceHeaderSpacing;  
-    OMX_U32 nPFrames;     
-    OMX_U32 nBFrames;     
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nSliceHeaderSpacing;
+    OMX_U32 nPFrames;
+    OMX_U32 nBFrames;
     OMX_BOOL bUseHadamard;
-    OMX_U32 nRefFrames;  
-	OMX_U32 nRefIdx10ActiveMinus1;
-	OMX_U32 nRefIdx11ActiveMinus1;
-    OMX_BOOL bEnableUEP;  
-    OMX_BOOL bEnableFMO;  
-    OMX_BOOL bEnableASO;  
-    OMX_BOOL bEnableRS;   
+    OMX_U32 nRefFrames;
+    OMX_U32 nRefIdx10ActiveMinus1;
+    OMX_U32 nRefIdx11ActiveMinus1;
+    OMX_BOOL bEnableUEP;
+    OMX_BOOL bEnableFMO;
+    OMX_BOOL bEnableASO;
+    OMX_BOOL bEnableRS;
     OMX_VIDEO_AVCPROFILETYPE eProfile;
-	OMX_VIDEO_AVCLEVELTYPE eLevel; 
-    OMX_U32 nAllowedPictureTypes;  
-	OMX_BOOL bFrameMBsOnly;        									
-    OMX_BOOL bMBAFF;               
-    OMX_BOOL bEntropyCodingCABAC;  
-    OMX_BOOL bWeightedPPrediction; 
-    OMX_U32 nWeightedBipredicitonMode; 
+    OMX_VIDEO_AVCLEVELTYPE eLevel;
+    OMX_U32 nAllowedPictureTypes;
+    OMX_BOOL bFrameMBsOnly;
+    OMX_BOOL bMBAFF;
+    OMX_BOOL bEntropyCodingCABAC;
+    OMX_BOOL bWeightedPPrediction;
+    OMX_U32 nWeightedBipredicitonMode;
     OMX_BOOL bconstIpred ;
-    OMX_BOOL bDirect8x8Inference;  
-	OMX_BOOL bDirectSpatialTemporal;
-	OMX_U32 nCabacInitIdc;
-	OMX_VIDEO_AVCLOOPFILTERTYPE eLoopFilterMode;
+    OMX_BOOL bDirect8x8Inference;
+    OMX_BOOL bDirectSpatialTemporal;
+    OMX_U32 nCabacInitIdc;
+    OMX_VIDEO_AVCLOOPFILTERTYPE eLoopFilterMode;
 } OMX_VIDEO_PARAM_AVCTYPE;
 
 typedef struct OMX_VIDEO_PARAM_PROFILELEVELTYPE {
-   OMX_U32 nSize;                 
-   OMX_VERSIONTYPE nVersion;      
-   OMX_U32 nPortIndex;            
-   OMX_U32 eProfile;      /**< type is OMX_VIDEO_AVCPROFILETYPE, OMX_VIDEO_H263PROFILETYPE, 
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 eProfile;      /**< type is OMX_VIDEO_AVCPROFILETYPE, OMX_VIDEO_H263PROFILETYPE,
                                  or OMX_VIDEO_MPEG4PROFILETYPE depending on context */
-   OMX_U32 eLevel;        /**< type is OMX_VIDEO_AVCLEVELTYPE, OMX_VIDEO_H263LEVELTYPE, 
+    OMX_U32 eLevel;        /**< type is OMX_VIDEO_AVCLEVELTYPE, OMX_VIDEO_H263LEVELTYPE,
                                  or OMX_VIDEO_MPEG4PROFILETYPE depending on context */
-   OMX_U32 nProfileIndex; /**< Used to query for individual profile support information,
-                               This parameter is valid only for 
+    OMX_U32 nProfileIndex; /**< Used to query for individual profile support information,
+                               This parameter is valid only for
                                OMX_IndexParamVideoProfileLevelQuerySupported index,
                                For all other indices this parameter is to be ignored. */
 } OMX_VIDEO_PARAM_PROFILELEVELTYPE;
 
-/** 
- * Structure for dynamically configuring bitrate mode of a codec. 
+/**
+ * Structure for dynamically configuring bitrate mode of a codec.
  *
  * STRUCT MEMBERS:
  *  nSize          : Size of the struct in bytes
@@ -928,18 +932,18 @@
  *  nEncodeBitrate : Target average bitrate to be generated in bps
  */
 typedef struct OMX_VIDEO_CONFIG_BITRATETYPE {
-    OMX_U32 nSize;                          
-    OMX_VERSIONTYPE nVersion;               
-    OMX_U32 nPortIndex;                     
-    OMX_U32 nEncodeBitrate;                 
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nEncodeBitrate;
 } OMX_VIDEO_CONFIG_BITRATETYPE;
 
-/** 
+/**
  * Defines Encoder Frame Rate setting
  *
  * STRUCT MEMBERS:
  *  nSize            : Size of the structure in bytes
- *  nVersion         : OMX specification version information 
+ *  nVersion         : OMX specification version information
  *  nPortIndex       : Port that this structure applies to
  *  xEncodeFramerate : Encoding framerate represented in Q16 format
  */
@@ -979,8 +983,85 @@
     OMX_U32 nMacroblocks;
 } OMX_PARAM_MACROBLOCKSTYPE;
 
-/** 
- * AVC Slice Mode modes 
+
+#ifdef AVS80
+/**
+ * Aspects of color.
+ */
+
+// NOTE: this structure is expected to grow in the future if new color aspects are
+// added to codec bitstreams. OMX component should not require a specific nSize
+// though could verify that nSize is at least the size of the structure at the
+// time of implementation. All new fields will be added at the end of the structure
+// ensuring backward compatibility.
+
+typedef enum OMX_RANGE {
+    RangeUnspecified,
+    RangeFull,
+    RangeLimited,
+    RangeOther = 0xff,
+} OMX_RANGE;
+
+typedef enum OMX_PRIMARIES {
+    PrimariesUnspecified,
+    PrimariesBT709_5,		// Rec.ITU-R BT.709-5 or equivalent
+    PrimariesBT470_6M,		// Rec.ITU-R BT.470-6 System M or equivalent
+    PrimariesBT601_6_625,	// Rec.ITU-R BT.601-6 625 or equivalent
+    PrimariesBT601_6_525,	// Rec.ITU-R BT.601-6 525 or equivalent
+    PrimariesGenericFilm,	// Generic Film
+    PrimariesBT2020,		// Rec.ITU-R BT.2020 or equivalent
+    PrimariesOther = 0xff,
+} OMX_PRIMARIES;
+
+typedef enum OMX_TRANSFER {
+    TransferUnspecified,
+    TransferLinear, 		// Linear transfer characteristics
+    TransferSRGB,			// sRGB or equivalent
+    TransferSMPTE170M,		// SMPTE 170M or equivalent (e.g. BT.601/709/2020)
+    TransferGamma22,		// Assumed display gamma 2.2
+    TransferGamma28,		// Assumed display gamma 2.8
+    TransferST2084, 		// SMPTE ST 2084 for 10/12/14/16 bit systems
+    TransferHLG,			// ARIB STD-B67 hybrid-log-gamma
+    // transfers unlikely to be required by Android
+    TransferSMPTE240M = 0x40, // SMPTE 240M
+    TransferXvYCC,			// IEC 61966-2-4
+    TransferBT1361, 		// Rec.ITU-R BT.1361 extended gamut
+    TransferST428,			// SMPTE ST 428-1
+    TransferOther = 0xff,
+} OMX_TRANSFER;
+
+typedef enum OMX_MATRIXCOEFFS {
+    MatrixUnspecified,
+    MatrixBT709_5,			// Rec.ITU-R BT.709-5 or equivalent
+    MatrixBT470_6M, 		// KR=0.30, KB=0.11 or equivalent
+    MatrixBT601_6,			// Rec.ITU-R BT.601-6 625 or equivalent
+    MatrixSMPTE240M,		// SMPTE 240M or equivalent
+    MatrixBT2020,			// Rec.ITU-R BT.2020 non-constant luminance
+    MatrixBT2020Constant,	// Rec.ITU-R BT.2020 constant luminance
+    MatrixOther = 0xff,
+} OMX_MATRIXCOEFFS;
+
+typedef struct OMX_COLORASPECTS {
+    OMX_RANGE mRange;                // IN/OUT
+    OMX_PRIMARIES mPrimaries;        // IN/OUT
+    OMX_TRANSFER mTransfer;          // IN/OUT
+    OMX_MATRIXCOEFFS mMatrixCoeffs;  // IN/OUT
+} OMX_COLORASPECTS;
+
+typedef struct OMX_CONFIG_DESCRIBECOLORASPECTSPARAMS {
+    OMX_U32  nSize;                // IN
+    OMX_VERSIONTYPE nVersion;      // IN
+    OMX_U32  nPortIndex;           // IN
+    OMX_BOOL bRequestingDataSpace; // IN
+    OMX_BOOL bDataSpaceChanged;    // IN
+    OMX_U32  nPixelFormat;         // IN
+    OMX_U32  nDataSpace;           // OUT
+    OMX_COLORASPECTS sAspects;  // IN/OUT
+} OMX_CONFIG_DESCRIBECOLORASPECTSPARAMS;
+#endif
+
+/**
+ * AVC Slice Mode modes
  *
  * OMX_VIDEO_SLICEMODE_AVCDefault   : Normal frame encoding, one slice per frame
  * OMX_VIDEO_SLICEMODE_AVCMBSlice   : NAL mode, number of MBs per frame
@@ -990,13 +1071,13 @@
     OMX_VIDEO_SLICEMODE_AVCDefault = 0,
     OMX_VIDEO_SLICEMODE_AVCMBSlice,
     OMX_VIDEO_SLICEMODE_AVCByteSlice,
-    OMX_VIDEO_SLICEMODE_AVCKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_VIDEO_SLICEMODE_AVCKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
     OMX_VIDEO_SLICEMODE_AVCVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_VIDEO_SLICEMODE_AVCLevelMax = 0x7FFFFFFF
 } OMX_VIDEO_AVCSLICEMODETYPE;
 
-/** 
- * AVC FMO Slice Mode Params 
+/**
+ * AVC FMO Slice Mode Params
  *
  * STRUCT MEMBERS:
  *  nSize      : Size of the structure in bytes
@@ -1007,7 +1088,7 @@
  *  eSliceMode : Specifies the type of slice
  */
 typedef struct OMX_VIDEO_PARAM_AVCSLICEFMO {
-    OMX_U32 nSize; 
+    OMX_U32 nSize;
     OMX_VERSIONTYPE nVersion;
     OMX_U32 nPortIndex;
     OMX_U8 nNumSliceGroups;
@@ -1015,7 +1096,7 @@
     OMX_VIDEO_AVCSLICEMODETYPE eSliceMode;
 } OMX_VIDEO_PARAM_AVCSLICEFMO;
 
-/** 
+/**
  * AVC IDR Period Configs
  *
  * STRUCT MEMBERS:
@@ -1026,14 +1107,14 @@
  *  nPFrames : Specifies internal of coding Intra frames
  */
 typedef struct OMX_VIDEO_CONFIG_AVCINTRAPERIOD {
-    OMX_U32 nSize; 
+    OMX_U32 nSize;
     OMX_VERSIONTYPE nVersion;
     OMX_U32 nPortIndex;
     OMX_U32 nIDRPeriod;
     OMX_U32 nPFrames;
 } OMX_VIDEO_CONFIG_AVCINTRAPERIOD;
 
-/** 
+/**
  * AVC NAL Size Configs
  *
  * STRUCT MEMBERS:
@@ -1043,7 +1124,7 @@
  *  nNaluBytes : Specifies the NAL unit size
  */
 typedef struct OMX_VIDEO_CONFIG_NALSIZE {
-    OMX_U32 nSize; 
+    OMX_U32 nSize;
     OMX_VERSIONTYPE nVersion;
     OMX_U32 nPortIndex;
     OMX_U32 nNaluBytes;
Index: gst-omx-1.22.0/omx/openmax/OMX_VideoExt.h
===================================================================
--- gst-omx-1.22.0.orig/omx/openmax/OMX_VideoExt.h	2023-03-02 08:48:43.000000000 +0000
+++ gst-omx-1.22.0/omx/openmax/OMX_VideoExt.h	2023-03-02 08:58:22.000000000 +0000
@@ -1,69 +1,401 @@
-/*
- * Copyright (c) 2010 The Khronos Group Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject
- * to the following conditions:
- * The above copyright notice and this permission notice shall be included
- * in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
- * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
- * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- */
-
-/** OMX_VideoExt.h - OpenMax IL version 1.1.2
- * The OMX_VideoExt header file contains extensions to the
- * definitions used by both the application and the component to
- * access video items.
- */
-
-#ifndef OMX_VideoExt_h
-#define OMX_VideoExt_h
-
-#ifdef __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-
-/* Each OMX header shall include all required header files to allow the
- * header to compile without errors.  The includes below are required
- * for this header file to compile successfully
- */
-#include <OMX_Core.h>
-
-/** NALU Formats */
-typedef enum OMX_NALUFORMATSTYPE {
-    OMX_NaluFormatStartCodes = 1,
-    OMX_NaluFormatOneNaluPerBuffer = 2,
-    OMX_NaluFormatOneByteInterleaveLength = 4,
-    OMX_NaluFormatTwoByteInterleaveLength = 8,
-    OMX_NaluFormatFourByteInterleaveLength = 16,
-    OMX_NaluFormatCodingMax = 0x7FFFFFFF
-} OMX_NALUFORMATSTYPE;
-
-
-/** NAL Stream Format */
-typedef struct OMX_NALSTREAMFORMATTYPE{
-    OMX_U32 nSize;
-    OMX_VERSIONTYPE nVersion;
-    OMX_U32 nPortIndex;
-    OMX_NALUFORMATSTYPE eNaluFormat;
-} OMX_NALSTREAMFORMATTYPE;
-
-
-
-#ifdef __cplusplus
-}
-#endif /* __cplusplus */
-
-#endif /* OMX_VideoExt_h */
-/* File EOF */
+/*
+ * Copyright (c) 2010 The Khronos Group Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions:
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+/** OMX_VideoExt.h - OpenMax IL version 1.1.2
+ * The OMX_VideoExt header file contains extensions to the
+ * definitions used by both the application and the component to
+ * access video items.
+ */
+
+#ifndef OMX_VideoExt_h
+#define OMX_VideoExt_h
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/* Each OMX header shall include all required header files to allow the
+ * header to compile without errors.  The includes below are required
+ * for this header file to compile successfully
+ */
+#include <OMX_Core.h>
+
+/** NALU Formats */
+typedef enum OMX_NALUFORMATSTYPE {
+    OMX_NaluFormatStartCodes = 1,
+    OMX_NaluFormatOneNaluPerBuffer = 2,
+    OMX_NaluFormatOneByteInterleaveLength = 4,
+    OMX_NaluFormatTwoByteInterleaveLength = 8,
+    OMX_NaluFormatFourByteInterleaveLength = 16,
+    OMX_NaluFormatCodingMax = 0x7FFFFFFF
+} OMX_NALUFORMATSTYPE;
+
+/** NAL Stream Format */
+typedef struct OMX_NALSTREAMFORMATTYPE{
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_NALUFORMATSTYPE eNaluFormat;
+} OMX_NALSTREAMFORMATTYPE;
+
+/** VP8 profiles */
+typedef enum OMX_VIDEO_VP8PROFILETYPE {
+    OMX_VIDEO_VP8ProfileMain = 0x01,
+    OMX_VIDEO_VP8ProfileUnknown = 0x6EFFFFFF,
+    OMX_VIDEO_VP8ProfileMax = 0x7FFFFFFF
+} OMX_VIDEO_VP8PROFILETYPE;
+
+/** VP8 levels */
+typedef enum OMX_VIDEO_VP8LEVELTYPE {
+    OMX_VIDEO_VP8Level_Version0 = 0x01,
+    OMX_VIDEO_VP8Level_Version1 = 0x02,
+    OMX_VIDEO_VP8Level_Version2 = 0x04,
+    OMX_VIDEO_VP8Level_Version3 = 0x08,
+    OMX_VIDEO_VP8LevelUnknown = 0x6EFFFFFF,
+    OMX_VIDEO_VP8LevelMax = 0x7FFFFFFF
+} OMX_VIDEO_VP8LEVELTYPE;
+
+/** VP9 profiles */
+typedef enum OMX_VIDEO_VP9PROFILETYPE {
+    OMX_VIDEO_VP9Profile0       = 0x1,
+    OMX_VIDEO_VP9Profile1       = 0x2,
+    OMX_VIDEO_VP9Profile2       = 0x4,
+    OMX_VIDEO_VP9Profile3       = 0x8,
+    // HDR profiles also support passing HDR metadata
+    OMX_VIDEO_VP9Profile2HDR    = 0x1000,
+    OMX_VIDEO_VP9Profile3HDR    = 0x2000,
+    OMX_VIDEO_VP9ProfileUnknown = 0x6EFFFFFF,
+    OMX_VIDEO_VP9ProfileMax     = 0x7FFFFFFF
+} OMX_VIDEO_VP9PROFILETYPE;
+
+/** VP9 levels */
+typedef enum OMX_VIDEO_VP9LEVELTYPE {
+    OMX_VIDEO_VP9Level1       = 0x1,
+    OMX_VIDEO_VP9Level11      = 0x2,
+    OMX_VIDEO_VP9Level2       = 0x4,
+    OMX_VIDEO_VP9Level21      = 0x8,
+    OMX_VIDEO_VP9Level3       = 0x10,
+    OMX_VIDEO_VP9Level31      = 0x20,
+    OMX_VIDEO_VP9Level4       = 0x40,
+    OMX_VIDEO_VP9Level41      = 0x80,
+    OMX_VIDEO_VP9Level5       = 0x100,
+    OMX_VIDEO_VP9Level51      = 0x200,
+    OMX_VIDEO_VP9Level52      = 0x400,
+    OMX_VIDEO_VP9Level6       = 0x800,
+    OMX_VIDEO_VP9Level61      = 0x1000,
+    OMX_VIDEO_VP9Level62      = 0x2000,
+    OMX_VIDEO_VP9LevelUnknown = 0x6EFFFFFF,
+    OMX_VIDEO_VP9LevelMax     = 0x7FFFFFFF
+} OMX_VIDEO_VP9LEVELTYPE;
+
+/** VP8 Param */
+typedef struct OMX_VIDEO_PARAM_VP8TYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_VIDEO_VP8PROFILETYPE eProfile;
+    OMX_VIDEO_VP8LEVELTYPE eLevel;
+    OMX_U32 nDCTPartitions;
+    OMX_BOOL bErrorResilientMode;
+} OMX_VIDEO_PARAM_VP8TYPE;
+
+/** Structure for configuring VP8 reference frames */
+typedef struct OMX_VIDEO_VP8REFERENCEFRAMETYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_BOOL bPreviousFrameRefresh;
+    OMX_BOOL bGoldenFrameRefresh;
+    OMX_BOOL bAlternateFrameRefresh;
+    OMX_BOOL bUsePreviousFrame;
+    OMX_BOOL bUseGoldenFrame;
+    OMX_BOOL bUseAlternateFrame;
+} OMX_VIDEO_VP8REFERENCEFRAMETYPE;
+
+/** Structure for querying VP8 reference frame type */
+typedef struct OMX_VIDEO_VP8REFERENCEFRAMEINFOTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_BOOL bIsIntraFrame;
+    OMX_BOOL bIsGoldenOrAlternateFrame;
+} OMX_VIDEO_VP8REFERENCEFRAMEINFOTYPE;
+
+/** Maximum number of VP8 temporal layers */
+#define OMX_VIDEO_ANDROID_MAXVP8TEMPORALLAYERS 3
+
+/** VP8 temporal layer patterns */
+typedef enum OMX_VIDEO_ANDROID_VPXTEMPORALLAYERPATTERNTYPE {
+    OMX_VIDEO_VPXTemporalLayerPatternNone = 0,
+    OMX_VIDEO_VPXTemporalLayerPatternWebRTC = 1,
+    OMX_VIDEO_VPXTemporalLayerPatternMax = 0x7FFFFFFF
+} OMX_VIDEO_ANDROID_VPXTEMPORALLAYERPATTERNTYPE;
+
+/**
+ * Android specific VP8 encoder params
+ *
+ * STRUCT MEMBERS:
+ *  nSize                      : Size of the structure in bytes
+ *  nVersion                   : OMX specification version information
+ *  nPortIndex                 : Port that this structure applies to
+ *  nKeyFrameInterval          : Key frame interval in frames
+ *  eTemporalPattern           : Type of temporal layer pattern
+ *  nTemporalLayerCount        : Number of temporal coding layers
+ *  nTemporalLayerBitrateRatio : Bitrate ratio allocation between temporal
+ *                               streams in percentage
+ *  nMinQuantizer              : Minimum (best quality) quantizer
+ *  nMaxQuantizer              : Maximum (worst quality) quantizer
+ */
+typedef struct OMX_VIDEO_PARAM_ANDROID_VP8ENCODERTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nKeyFrameInterval;        // distance between consecutive key_frames (including one
+                                      // of the key_frames). 0 means interval is unspecified and
+                                      // can be freely chosen by the codec. 1 means a stream of
+                                      // only key_frames.
+
+    OMX_VIDEO_ANDROID_VPXTEMPORALLAYERPATTERNTYPE eTemporalPattern;
+    OMX_U32 nTemporalLayerCount;
+    OMX_U32 nTemporalLayerBitrateRatio[OMX_VIDEO_ANDROID_MAXVP8TEMPORALLAYERS];
+    OMX_U32 nMinQuantizer;
+    OMX_U32 nMaxQuantizer;
+} OMX_VIDEO_PARAM_ANDROID_VP8ENCODERTYPE;
+
+/** HEVC Profile enum type */
+typedef enum OMX_VIDEO_HEVCPROFILETYPE {
+    OMX_VIDEO_HEVCProfileUnknown      = 0x0,
+    OMX_VIDEO_HEVCProfileMain         = 0x1,
+    OMX_VIDEO_HEVCProfileMain10       = 0x2,
+    // Main10 profile with HDR SEI support.
+    OMX_VIDEO_HEVCProfileMain10HDR10  = 0x1000,
+    OMX_VIDEO_HEVCProfileMax          = 0x7FFFFFFF
+} OMX_VIDEO_HEVCPROFILETYPE;
+
+/** HEVC Level enum type */
+typedef enum OMX_VIDEO_HEVCLEVELTYPE {
+    OMX_VIDEO_HEVCLevelUnknown    = 0x0,
+    OMX_VIDEO_HEVCMainTierLevel1  = 0x1,
+    OMX_VIDEO_HEVCHighTierLevel1  = 0x2,
+    OMX_VIDEO_HEVCMainTierLevel2  = 0x4,
+    OMX_VIDEO_HEVCHighTierLevel2  = 0x8,
+    OMX_VIDEO_HEVCMainTierLevel21 = 0x10,
+    OMX_VIDEO_HEVCHighTierLevel21 = 0x20,
+    OMX_VIDEO_HEVCMainTierLevel3  = 0x40,
+    OMX_VIDEO_HEVCHighTierLevel3  = 0x80,
+    OMX_VIDEO_HEVCMainTierLevel31 = 0x100,
+    OMX_VIDEO_HEVCHighTierLevel31 = 0x200,
+    OMX_VIDEO_HEVCMainTierLevel4  = 0x400,
+    OMX_VIDEO_HEVCHighTierLevel4  = 0x800,
+    OMX_VIDEO_HEVCMainTierLevel41 = 0x1000,
+    OMX_VIDEO_HEVCHighTierLevel41 = 0x2000,
+    OMX_VIDEO_HEVCMainTierLevel5  = 0x4000,
+    OMX_VIDEO_HEVCHighTierLevel5  = 0x8000,
+    OMX_VIDEO_HEVCMainTierLevel51 = 0x10000,
+    OMX_VIDEO_HEVCHighTierLevel51 = 0x20000,
+    OMX_VIDEO_HEVCMainTierLevel52 = 0x40000,
+    OMX_VIDEO_HEVCHighTierLevel52 = 0x80000,
+    OMX_VIDEO_HEVCMainTierLevel6  = 0x100000,
+    OMX_VIDEO_HEVCHighTierLevel6  = 0x200000,
+    OMX_VIDEO_HEVCMainTierLevel61 = 0x400000,
+    OMX_VIDEO_HEVCHighTierLevel61 = 0x800000,
+    OMX_VIDEO_HEVCMainTierLevel62 = 0x1000000,
+    OMX_VIDEO_HEVCHighTierLevel62 = 0x2000000,
+    OMX_VIDEO_HEVCHighTiermax     = 0x7FFFFFFF
+} OMX_VIDEO_HEVCLEVELTYPE;
+
+/** Structure for controlling HEVC video encoding */
+typedef struct OMX_VIDEO_PARAM_HEVCTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_VIDEO_HEVCPROFILETYPE eProfile;
+    OMX_VIDEO_HEVCLEVELTYPE eLevel;
+    OMX_U32 nKeyFrameInterval;        // distance between consecutive I-frames (including one
+                                      // of the I frames). 0 means interval is unspecified and
+                                      // can be freely chosen by the codec. 1 means a stream of
+                                      // only I frames.
+} OMX_VIDEO_PARAM_HEVCTYPE;
+
+/** Structure to define if dependent slice segments should be used */
+typedef struct OMX_VIDEO_SLICESEGMENTSTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_BOOL bDepedentSegments;
+    OMX_BOOL bEnableLoopFilterAcrossSlices;
+} OMX_VIDEO_SLICESEGMENTSTYPE;
+
+/** Structure to return timestamps of rendered output frames as well as EOS
+ *  for tunneled components.
+ */
+typedef struct OMX_VIDEO_RENDEREVENTTYPE {
+    OMX_S64 nMediaTimeUs;  // timestamp of rendered video frame
+    OMX_S64 nSystemTimeNs; // system monotonic time at the time frame was rendered
+                           // Use INT64_MAX for nMediaTimeUs to signal that the EOS
+                           // has been reached. In this case, nSystemTimeNs MUST be
+                           // the system time when the last frame was rendered.
+                           // This MUST be done in addition to returning (and
+                           // following) the render information for the last frame.
+} OMX_VIDEO_RENDEREVENTTYPE;
+
+/** Dolby Vision Profile enum type */
+typedef enum OMX_VIDEO_DOLBYVISIONPROFILETYPE {
+    OMX_VIDEO_DolbyVisionProfileUnknown = 0x0,
+    OMX_VIDEO_DolbyVisionProfileDvavPer = 0x1,
+    OMX_VIDEO_DolbyVisionProfileDvavPen = 0x2,
+    OMX_VIDEO_DolbyVisionProfileDvheDer = 0x4,
+    OMX_VIDEO_DolbyVisionProfileDvheDen = 0x8,
+    OMX_VIDEO_DolbyVisionProfileDvheDtr = 0x10,
+    OMX_VIDEO_DolbyVisionProfileDvheStn = 0x20,
+    OMX_VIDEO_DolbyVisionProfileDvheDth = 0x40,
+    OMX_VIDEO_DolbyVisionProfileDvheDtb = 0x80,
+    OMX_VIDEO_DolbyVisionProfileMax     = 0x7FFFFFFF
+} OMX_VIDEO_DOLBYVISIONPROFILETYPE;
+
+/** Dolby Vision Level enum type */
+typedef enum OMX_VIDEO_DOLBYVISIONLEVELTYPE {
+    OMX_VIDEO_DolbyVisionLevelUnknown = 0x0,
+    OMX_VIDEO_DolbyVisionLevelHd24    = 0x1,
+    OMX_VIDEO_DolbyVisionLevelHd30    = 0x2,
+    OMX_VIDEO_DolbyVisionLevelFhd24   = 0x4,
+    OMX_VIDEO_DolbyVisionLevelFhd30   = 0x8,
+    OMX_VIDEO_DolbyVisionLevelFhd60   = 0x10,
+    OMX_VIDEO_DolbyVisionLevelUhd24   = 0x20,
+    OMX_VIDEO_DolbyVisionLevelUhd30   = 0x40,
+    OMX_VIDEO_DolbyVisionLevelUhd48   = 0x80,
+    OMX_VIDEO_DolbyVisionLevelUhd60   = 0x100,
+    OMX_VIDEO_DolbyVisionLevelmax     = 0x7FFFFFFF
+} OMX_VIDEO_DOLBYVISIONLEVELTYPE;
+
+/**
+ * Structure for configuring video compression intra refresh period
+ *
+ * STRUCT MEMBERS:
+ *  nSize               : Size of the structure in bytes
+ *  nVersion            : OMX specification version information
+ *  nPortIndex          : Port that this structure applies to
+ *  nRefreshPeriod      : Intra refreh period in frames. Value 0 means disable intra refresh
+ */
+typedef struct OMX_VIDEO_CONFIG_ANDROID_INTRAREFRESHTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nRefreshPeriod;
+} OMX_VIDEO_CONFIG_ANDROID_INTRAREFRESHTYPE;
+
+/** Maximum number of temporal layers supported by AVC/HEVC */
+#define OMX_VIDEO_ANDROID_MAXTEMPORALLAYERS 8
+
+/** temporal layer patterns */
+typedef enum OMX_VIDEO_ANDROID_TEMPORALLAYERINGPATTERNTYPE {
+    OMX_VIDEO_AndroidTemporalLayeringPatternNone = 0,
+    // pattern as defined by WebRTC
+    OMX_VIDEO_AndroidTemporalLayeringPatternWebRTC = 1 << 0,
+    // pattern where frames in any layer other than the base layer only depend on at most the very
+    // last frame from each preceding layer (other than the base layer.)
+    OMX_VIDEO_AndroidTemporalLayeringPatternAndroid = 1 << 1,
+} OMX_VIDEO_ANDROID_TEMPORALLAYERINGPATTERNTYPE;
+
+/**
+ * Android specific param for configuration of temporal layering.
+ * Android only supports temporal layering where successive layers each double the
+ * previous layer's framerate.
+ * NOTE: Reading this parameter at run-time SHALL return actual run-time values.
+ *
+ *  nSize                      : Size of the structure in bytes
+ *  nVersion                   : OMX specification version information
+ *  nPortIndex                 : Port that this structure applies to (output port for encoders)
+ *  eSupportedPatterns         : A bitmask of supported layering patterns
+ *  nLayerCountMax             : Max number of temporal coding layers supported
+ *                               by the encoder (must be at least 1, 1 meaning temporal layering
+ *                               is NOT supported)
+ *  nBLayerCountMax            : Max number of layers that can contain B frames
+ *                               (0) to (nLayerCountMax - 1)
+ *  ePattern                   : Layering pattern.
+ *  nPLayerCountActual         : Number of temporal layers to be coded with non-B frames,
+ *                               starting from and including the base-layer.
+ *                               (1 to nLayerCountMax - nBLayerCountActual)
+ *                               If nPLayerCountActual is 1 and nBLayerCountActual is 0, temporal
+ *                               layering is disabled. Otherwise, it is enabled.
+ *  nBLayerCountActual         : Number of temporal layers to be coded with B frames,
+ *                               starting after non-B layers.
+ *                               (0 to nBLayerCountMax)
+ *  bBitrateRatiosSpecified    : Flag to indicate if layer-wise bitrate
+ *                               distribution is specified.
+ *  nBitrateRatios             : Bitrate ratio (100 based) per layer (index 0 is base layer).
+ *                               Honored if bBitrateRatiosSpecified is set.
+ *                               i.e for 4 layers with desired distribution (25% 25% 25% 25%),
+ *                               nBitrateRatio = {25, 50, 75, 100, ... }
+ *                               Values in indices not less than 'the actual number of layers
+ *                               minus 1' MAY be ignored and assumed to be 100.
+ */
+typedef struct OMX_VIDEO_PARAM_ANDROID_TEMPORALLAYERINGTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_VIDEO_ANDROID_TEMPORALLAYERINGPATTERNTYPE eSupportedPatterns;
+    OMX_U32 nLayerCountMax;
+    OMX_U32 nBLayerCountMax;
+    OMX_VIDEO_ANDROID_TEMPORALLAYERINGPATTERNTYPE ePattern;
+    OMX_U32 nPLayerCountActual;
+    OMX_U32 nBLayerCountActual;
+    OMX_BOOL bBitrateRatiosSpecified;
+    OMX_U32 nBitrateRatios[OMX_VIDEO_ANDROID_MAXTEMPORALLAYERS];
+} OMX_VIDEO_PARAM_ANDROID_TEMPORALLAYERINGTYPE;
+
+/**
+ * Android specific config for changing the temporal-layer count or
+ * bitrate-distribution at run-time.
+ *
+ *  nSize                      : Size of the structure in bytes
+ *  nVersion                   : OMX specification version information
+ *  nPortIndex                 : Port that this structure applies to (output port for encoders)
+ *  ePattern                   : Layering pattern.
+ *  nPLayerCountActual         : Number of temporal layers to be coded with non-B frames.
+ *                               (same OMX_VIDEO_PARAM_ANDROID_TEMPORALLAYERINGTYPE limits apply.)
+ *  nBLayerCountActual         : Number of temporal layers to be coded with B frames.
+ *                               (same OMX_VIDEO_PARAM_ANDROID_TEMPORALLAYERINGTYPE limits apply.)
+ *  bBitrateRatiosSpecified    : Flag to indicate if layer-wise bitrate
+ *                               distribution is specified.
+ *  nBitrateRatios             : Bitrate ratio (100 based, Q16 values) per layer (0 is base layer).
+ *                               Honored if bBitrateRatiosSpecified is set.
+ *                               (same OMX_VIDEO_PARAM_ANDROID_TEMPORALLAYERINGTYPE limits apply.)
+ */
+typedef struct OMX_VIDEO_CONFIG_ANDROID_TEMPORALLAYERINGTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_VIDEO_ANDROID_TEMPORALLAYERINGPATTERNTYPE ePattern;
+    OMX_U32 nPLayerCountActual;
+    OMX_U32 nBLayerCountActual;
+    OMX_BOOL bBitrateRatiosSpecified;
+    OMX_U32 nBitrateRatios[OMX_VIDEO_ANDROID_MAXTEMPORALLAYERS];
+} OMX_VIDEO_CONFIG_ANDROID_TEMPORALLAYERINGTYPE;
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* OMX_VideoExt_h */
+/* File EOF */
